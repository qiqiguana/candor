<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>
    <!-- NOTE: This is the properties used for tests! -->

    <!-- 'First' index location;
         Used only for testing;
         create symlink from the actual index location to /tmp/index:
         ln -s indexlocation /tmp/index -->
    <entry key="directory_name">/tmp/index</entry>
    <!-- Parallel cluster index location -->
    <entry key="directory_name1">/tmp/par_clu_ind</entry>

    <!-- Default field; where is this used? -->
    <entry key="default_field">freetext</entry>

    <!-- ******************************************************************* -->
    <!-- Cluster presentation -->
    <!-- ******************************************************************* -->

    <entry key="default_maxClusterFacets">30</entry>
    <entry key="default_maxClusterTags">5</entry>
    <entry key="default_maxClusterObjects">5</entry>

    <!-- Expand hits to shortformat -->
    <entry key="default_expandObjects">true</entry>

    <!-- -1: No limit -->
    <entry key="default_maxResults">10000</entry>

    <!-- -1: No limit -->
    <entry key="default_maxMS">-1</entry>

    <!--
    0: Use program default
    1: Type only
    2: Fields
    3: Fields + TermVector + Specials
    This is largely deprecated in favor of the more specific settings below.
    -->
    <entry key="default_completeness">3</entry>

    <!-- Except for sort_title, these are defined by Dorete -->
<!--    <entry key="ClusterTermVectors">author_normalised, lsu_oai, llang, ldbk</entry>-->
<!--    <entry key="ClusterTermVectors">location_normalised, series_normalised, llcl, lnlm, ldbk, ludk, ldds, lkl, lfn, linst, ldk5, lma_long, su_pe, su_corp, su_lc, mesh, su_dk, lsu_oai, llang</entry>-->

    <!-- A list of the wanted facets. The facet names in the list must be exactly
         the same for building and displaying, including order, excluding
         maxTags.
         If the number of maxTags for a given Facet should be different than
         the default one (default_maxClusterTags), this can be stated in a
         paranthesis.
         Example: lma_long (200)
         There MUST be a space before the paranthesis.
         A facet name MUST NOT contain spaces. -->
    <entry key="ClusterTermVectors">commercials_subject (25), su_lc, ldk5, lma_long (100), lkl, lnlm, linst, location_normalised, llang, su_dk, lddc, llcc, mesh, cluster, ludk, sort_title, lsu_oai, ldbk, su_corp, series_normalised, lfn, author_normalised, su_pe, lcsa</entry>
    <!--    <entry key="ClusterTermVectors">author_normalised, sort_title, location_normalised, series_normalised, llcc, lnlm, ldbk, ludk, lddc, lkl, lfn, linst, ldk5, lma_long (200), su_pe, su_corp, su_lc, mesh, su_dk, lsu_oai, llang, cluster, commercials_subject</entry>-->
    <entry key="Cluster_vector_exceptions_freetext">og, er, den</entry>
    <entry key="ClusterFields"></entry>
    <!--
    frbr: Add the facet "FRBR" and populate with
          tags (aka clusters) "author - title".
          WARNING: Don't use FRBR in its current
          incarnation, as it does not provide
          queries. Use manyInOne instead.
    type: Extract the types from shortformat
    creator: Extrach the creators from shortformat
    autoClusters: Experimental clusters, generated by Bolette and Toke
    -->
    <entry key="ClusterSpecialFacets">manyInOne, autoCluster</entry>
    <entry key="ClusterManyInOneKeys">sort_title, author_normalised</entry>
    <entry key="ClusterManyInOneFailOnMissingKey">false</entry>

    <!--
    INSERT: Insertion order
    ALPHA:  Alpha numerical order
    REVERSEALPHA: Reverse alpha
    SCORE:  Score, from the highest to the lowest
    REVERSESCORE: Reverse score
    CUSTOM: Order specified by Cluster*SortCustom
    REVERSECUSTOM: Reverse custom
    SIZE: The size of Facet (the number of contained tags) or the size of the Tag (the number of contained objects)
    -->
    <entry key="ClusterFacetSort">CUSTOM, SIZE</entry>
    <entry key="ClusterFacetSortCustom">author_normalised, location_normalised, series_normalised</entry>
    <entry key="ClusterTagSort">SCORE, ALPHA</entry>
    <entry key="ClusterTagSortCustom"></entry>

    <!-- ******************************************************************* -->
    <!-- Complete cluster -->
    <!-- ******************************************************************* -->

    <!-- Where to store the map of all the wanted facets and tags in the
         index, meant for complete cluster processing. -->
    <entry key="CompleteClustermapLocation">/tmp/completeClustermap</entry>

    <!-- The number of threads used for building the real-time cluster
         presentation structure -->
    <entry key="ClusterMapThreads">2</entry>

    <!-- The tag handler is responsible to translate the internal references to
         tag names. Valid values are
         MemoryTagHandler: Loads all tagnames in memory. Fast, but requires
                           a lot of memory (ca. ½ GB / million documents).
         DiskTagHandler:   Performs lookup on disk. Relies on disk-cache for
                           quick response-time. Worst-case (if no tags names are
                           cached) is about 1 extra second.
                           It requires 8 * the number of tags bytes in RAM.
                           The number of tags is (_very_ roughly) 4-5 million /
                           1 million documents.
                           Note that indexes for the tag names needs to be build
                           each time the taglists have changed. This is done
                           automatically and tages about 2 minutes / 1 million
                           documents.-->
    <entry key="TagHandler">DiskTagHandler</entry>

    <!-- ******************************************************************* -->
    <!-- Cluster creation -->
    <!-- ******************************************************************* -->

    <!-- cluster map location used for testing -->
    <entry key="ClusterMapLocation">/tmp/auto_clusters_dist_based.map</entry>

    <!-- The fields to use as facets for cluster creation (initial clusters) -->
    <entry key="CCFields">su_pe|su_corp|su_lc|mesh|su_dk|lsu_oai</entry>
    <!-- <entry key="CCFields">subject_controlled|subject_other|subject_dk</entry> -->
    <!-- The fields not to use as facets for cluster creation -->
    <entry key="CCNegativeFields"></entry>
    <!-- The terms to use as tags for cluster creation -->
    <entry key="CCTerms"></entry>
    <!-- The terms not to use as tags for cluster creation -->
    <!-- qzwq is a delimiter -->
    <entry key="CCNegativeTerms">[0-9]+[.]?-? ?[0-9]+|[0-9]|og|view|and|of|the|.|new|with|on|to|etc|den|for|in|von|qzwq|til|med|om|af|på|det|er|as|ii|ud|no|st|se|na|al|is|man|it</entry>

    <!-- The minimum number of times that the terms has to occur in the
         index for a given field, in order to be considered tag candidates -->
    <entry key="CCMinTermSum">15</entry><!-- TODO test 100 / small clusters 25 -->
    <!-- The minimum number of times that the terms has to occur in the
         index for a single field_X, in order to be considered tag candidates.
         If collapse is false, this should be equal to CCMinTermSum. -->
    <entry key="CCMinTermLocalSum">15</entry><!-- TODO 100 / 25 -->
    <!-- The maximum number of times that the terms must occur in the
         index, in order to be considered tag candidates -->
    <entry key="CCMaxTermSum">99999</entry><!-- TODO used to be 999999 -->

    <!-- Note: the following settings are not used in simple cluster creation -->

    <!-- The minimum number of unique Terms that a Field must
         have in ordet to be tagged as valid -->
    <entry key="CCMinTermCount">1</entry>
    <!-- The maximum number of unique Terms that a Field can
         have in ordet to be tagged as valid -->
    <entry key="CCMaxTermCount">99999</entry>
    <!-- Stop the searching for clusters in a specific Field, if no candidates
         has been found after searching this number of terms -->
    <entry key="CCSkipAfterXWithNoHits">1000000</entry>
    <!-- Reduce the list of candidates to this number after searching. The most
         promising candidates are kept; applies to each considered field (CCFields) -->
    <!-- Remember to set this high in production -->
    <entry key="CCReduceTo">300</entry>
    <!-- Collapse fields like creator_1 and creator_2 to creator. This is not
         needed in the current index (20060626) -->
    <entry key="CCCollapseFields">false</entry>

    <!-- The maximum number of documents, that are used for calculating a
         centroid for a given cluster candidate -->
    <!-- This should probably be a fairly large number in production -->
    <!-- Note: currently not used in distance based creation -->
    <!-- Still used in 'first generation' cluster creation-->
    <entry key="CCMaxPointsInCentroid">67</entry><!-- TODO used to be 6700... -->

    <!-- The maximum size (number of terms) that a centroid can have after
         a reduce has been performed. This is a performance tweak. Lower
         values = better performance and worse approximation to the ideal
         result. -->
    <entry key="CCMaximumCentroidReduceSize">300</entry>
    <!-- The maximum size (number of terms) that a centroid can have after it
         has been build -->
    <entry key="CCMaximumCentroidFinalSize">50</entry>

    <!-- The normalize average number of usages for a given term needs to be
         above this number (tricky: We probably need to experiment a lot to
         get the right value here; OR since CCMaximumCentroidFinalSize is set
         low we can simply ignore this value (set it to zero) -->
    <entry key="CCMinimumCentroidEntrySize">0.01</entry>

    <entry key="CCOptimizeCentroidEveryXPoints">500</entry>

    <!-- This should probably be a very large number in production -->
    <!-- Note: currently not used in distance based creation -->
    <!-- Is used in simple clusters (getSimpleClusters) -->
    <entry key="CCMaxClusterSize">80000</entry><!-- TODO used to be 200000 -->
    <!-- NEW Thu Sep 07 -->
    <entry key="CCMaxClusterSizeFractionOfSearchResult">.6</entry>
    <!-- NEW Thu Sep 07 -->
    <entry key="CCScoreCutoffForClusterMembersFractionOfTopScore">.2</entry>
    <!-- Documents need to have at least this score, to be considered part of
         a cluster -->
    <!-- Note: not used in distance based creation -->
    <entry key="CCScoreCutoffForClusterMembers">1</entry>
    <!-- 1: out of memory (512MB) ved 2977/4233 -->

    <!-- Store the ClusterMap on the file system for every X clusters created
         Note: currently not used in distance based creation
         Note: set to zero for no check point saves (used to be 50) -->
    <entry key="CCCheckpointEveryXClusters">0</entry>

    <!-- NEW PARAMETERS USED IN DISTANCE BASED CLUSTERING -->

    <!-- Fields used for document vectors (inclusive list) -->
    <!-- no longer used in vectors: author_normalised|author_coorporation|author_person -->
    <entry key="FieldsUsedInVectors">su_pe|su_corp|su_lc|mesh|su_dk|lsu_oai|title|main_titel|subject_controlled|subject_dk5|no</entry>
    <!-- Fields NOT used for document vectors (exclusive list) -->
    <entry key="VectorNegativeFields"></entry>

    <!-- Should the points (corresponding to the documents) be normalised when
         added to the incremental centroid? -->
    <entry key="NormalisePointsWhenAddingToCentroid">false</entry><!--TODO: true ?-->

    <!-- How many (fraction) of the original cluster members (search based cluster)
         should be inside the defined cluster diameter? -->
    <entry key="ClusterDiameterCut">.6</entry>

    <!-- How distant should the (normalised) centroids of two different clusters be?
         If two centroids are closer than this distance,
         the two corresponding clusters are joined. -->
    <entry key="MinimumDistanceBetweenCentroids">.01</entry>

    <!-- How distant should the centroids of two different clusters
         with the same name be? -->
    <entry key="MinimumDistanceBetweenCentroidsWithTheSameName">1</entry>

    <!-- Should the original cluster members be kept in the cluster though,
         though they are not within the defined cluster diameter? -->
    <entry key="KeepInitialClusterMembers">true</entry>

    <!-- TODO: tidy up cluster.properties! -->

    <!-- Location of temporary cluster map used by ParallelIndexCreator;
         the directory is assumed to exists!!! -->
    <entry key="tmpCCmap">/tmp/tmpCCmaps/map</entry>

    <!-- Should parallel index building be resumed?
         If false, ClusterAndParallelIndexCreator is run from the beginning. -->
    <entry key="resumeCC">false</entry>

    <!-- Which cluster creation algorithm should be used?
         Currently the choices are 'FG' (First Generation), 'DB'
         (Distance Based) and 'simple'. The default is 'simple'.-->
    <entry key="CCalgorithm">simple</entry>

</properties>

