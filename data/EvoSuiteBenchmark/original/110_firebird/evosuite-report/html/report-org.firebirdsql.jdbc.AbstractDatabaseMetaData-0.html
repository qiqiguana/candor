<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
<html>
<head>
<title>
org.firebirdsql.jdbc.AbstractDatabaseMetaData
</title>
<link href="files/prettify.css" type="text/css" rel="stylesheet" />
<link href="files/style.css" rel="stylesheet" type="text/css" media="screen"/>
<script type="text/javascript" src="files/prettify.js"></script>
<script type="text/javascript" src="files/jquery.js"></script>
<script type="text/javascript" src="files/foldButton.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    $('H2#tests').foldButton();
    $('H2#source').foldButton();
    $('H2#parameters').foldButton();
  });</script>
<link href="files/foldButton.css" rel="stylesheet" type="text/css">
</head>
<body onload="prettyPrint()">
<div id="wrapper">
<img src="files/evosuite.png" height="40"/>
<br><br><h2 class=title>Summary</h2>
<ul><li>Target class: org.firebirdsql.jdbc.AbstractDatabaseMetaData: 6.88%</ul><ul>
<li>228 fitness evaluations, 6 generations, 1380 statements, 398 tests.
<li>Time: 0:01:11(Search: 0:01:02, minimization: 0:00:09)
<li>Coverage: 35/630 branches, 31/202 methods, 54/785 total goals
<li>Mutation score: 1%
</ul>
<div id="page"><div id="page-bgtop"><div id="page-bgbtm"><div id="content"><div id="post"><h2 class=title id=tests>Test suite</h2>
<div class=tests>
<h3>Test case 1</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>// Undeclared exception!
<span class="nocode"><a name="3">  3: </a></span>try {
<span class="nocode"><a name="4">  4: </a></span>  fBDatabaseMetaData0.getProcedureColumns(&quot;org.firebirdsql.jdbc.pid&quot;, &quot;org.firebirdsql.jdbc.pid&quot;, &quot;org.firebirdsql.jdbc.pid&quot;, &quot;org.firebirdsql.jdbc.pid&quot;);
<span class="nocode"><a name="5">  5: </a></span>  fail(&quot;Expecting exception: NullPointerException&quot;);
<span class="nocode"><a name="6">  6: </a></span>} catch(NullPointerException e) {
<span class="nocode"><a name="7">  7: </a></span>}
</pre>
<h3>Test case 2</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.othersInsertsAreVisible((-1));
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 3</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>// Undeclared exception!
<span class="nocode"><a name="3">  3: </a></span>try {
<span class="nocode"><a name="4">  4: </a></span>  fBDatabaseMetaData0.getOdsMinorVersion();
<span class="nocode"><a name="5">  5: </a></span>  fail(&quot;Expecting exception: NullPointerException&quot;);
<span class="nocode"><a name="6">  6: </a></span>} catch(NullPointerException e) {
<span class="nocode"><a name="7">  7: </a></span>}
</pre>
<h3>Test case 4</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = null;
<span class="nocode"><a name="2">  2: </a></span>try {
<span class="nocode"><a name="3">  3: </a></span>  fBDatabaseMetaData0 = new FBDatabaseMetaData((AbstractConnection) null);
<span class="nocode"><a name="4">  4: </a></span>  fail(&quot;Expecting exception: NullPointerException&quot;);
<span class="nocode"><a name="5">  5: </a></span>} catch(NullPointerException e) {
<span class="nocode"><a name="6">  6: </a></span>}
</pre>
<h3>Test case 5</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsDifferentTableCorrelationNames();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 6</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.storesUpperCaseIdentifiers();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(true, boolean0);
</pre>
<h3>Test case 7</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsMultipleTransactions();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(true, boolean0);
</pre>
<h3>Test case 8</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>FBResultSet fBResultSet0 = (FBResultSet)fBDatabaseMetaData0.getTypeInfo();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, fBResultSet0.isClosed());
</pre>
<h3>Test case 9</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.storesUpperCaseQuotedIdentifiers();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 10</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsMultipleResultSets();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 11</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsOpenCursorsAcrossCommit();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 12</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>int int0 = fBDatabaseMetaData0.getSQLStateType();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(2, int0);
</pre>
<h3>Test case 13</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsMultipleOpenResults();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 14</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>int[] intArray0 = new int[2];
<span class="nocode"><a name="3">  3: </a></span>FBResultSet fBResultSet0 = (FBResultSet)fBDatabaseMetaData0.getUDTs(&quot;[NULL Xid]&quot;, &quot;[NULL Xid]&quot;, &quot;[NULL Xid]&quot;, intArray0);
<span class="nocode"><a name="4">  4: </a></span>assertEquals(false, fBResultSet0.isBeforeFirst());
</pre>
<h3>Test case 15</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.nullsAreSortedHigh();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 16</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsSubqueriesInQuantifieds();
<span class="nocode"><a name="3">  3: </a></span>assertEquals(true, boolean0);
</pre>
<h3>Test case 17</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>boolean boolean0 = fBDatabaseMetaData0.supportsTransactionIsolationLevel((-1));
<span class="nocode"><a name="3">  3: </a></span>assertEquals(false, boolean0);
</pre>
<h3>Test case 18</h3>
<pre class="prettyprint" style="border: 1px solid #888;padding: 2px">
<span class="nocode"><a name="1">  1: </a></span>FBDatabaseMetaData fBDatabaseMetaData0 = new FBDatabaseMetaData((GDSHelper) null);
<span class="nocode"><a name="2">  2: </a></span>// Undeclared exception!
<span class="nocode"><a name="3">  3: </a></span>try {
<span class="nocode"><a name="4">  4: </a></span>  fBDatabaseMetaData0.getCrossReference(&quot;J4]^i&gt;HKh&quot;, &quot;J4]^i&gt;HKh&quot;, &quot;J4]^i&gt;HKh&quot;, &quot;&quot;, &quot;&quot;, &quot;J4]^i&gt;HKh&quot;);
<span class="nocode"><a name="5">  5: </a></span>  fail(&quot;Expecting exception: NullPointerException&quot;);
<span class="nocode"><a name="6">  6: </a></span>} catch(NullPointerException e) {
<span class="nocode"><a name="7">  7: </a></span>}
</pre>
</div></div><div id="post"></div><div id="post"><h2 class=title id=source>Source Code</h2>
<div class=source><p><pre class="prettyprint" style="border: 1px solid #888;padding: 2px"><span class="nocode"><a name="1">  1: </a></span>/*
<span class="nocode"><a name="2">  2: </a></span> * $Id: AbstractDatabaseMetaData.java 57147 2012-09-19 17:21:00Z mrotteveel $
<span class="nocode"><a name="3">  3: </a></span> * 
<span class="nocode"><a name="4">  4: </a></span> * Firebird Open Source J2ee connector - jdbc driver
<span class="nocode"><a name="5">  5: </a></span> *
<span class="nocode"><a name="6">  6: </a></span> * Distributable under LGPL license.
<span class="nocode"><a name="7">  7: </a></span> * You may obtain a copy of the License at http://www.gnu.org/copyleft/lgpl.html
<span class="nocode"><a name="8">  8: </a></span> *
<span class="nocode"><a name="9">  9: </a></span> * This program is distributed in the hope that it will be useful,
<span class="nocode"><a name="10"> 10: </a></span> * but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="nocode"><a name="11"> 11: </a></span> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="nocode"><a name="12"> 12: </a></span> * LGPL License for more details.
<span class="nocode"><a name="13"> 13: </a></span> *
<span class="nocode"><a name="14"> 14: </a></span> * This file was created by members of the firebird development team.
<span class="nocode"><a name="15"> 15: </a></span> * All individual contributions remain the Copyright (C) of those
<span class="nocode"><a name="16"> 16: </a></span> * individuals.  Contributors to this file are either listed here or
<span class="nocode"><a name="17"> 17: </a></span> * can be obtained from a CVS history command.
<span class="nocode"><a name="18"> 18: </a></span> *
<span class="nocode"><a name="19"> 19: </a></span> * All rights reserved.
<span class="nocode"><a name="20"> 20: </a></span> */
<span class="nocode"><a name="21"> 21: </a></span>package org.firebirdsql.jdbc;
<span class="nocode"><a name="22"> 22: </a></span>
<span class="nocode"><a name="23"> 23: </a></span>import java.sql.*;
<span class="nocode"><a name="24"> 24: </a></span>import java.util.*;
<span class="nocode"><a name="25"> 25: </a></span>
<span class="nocode"><a name="26"> 26: </a></span>import org.firebirdsql.gds.*;
<span class="nocode"><a name="27"> 27: </a></span>import org.firebirdsql.gds.impl.AbstractGDS;
<span class="nocode"><a name="28"> 28: </a></span>import org.firebirdsql.gds.impl.GDSFactory;
<span class="nocode"><a name="29"> 29: </a></span>import org.firebirdsql.gds.impl.GDSHelper;
<span class="nocode"><a name="30"> 30: </a></span>import org.firebirdsql.logging.Logger;
<span class="nocode"><a name="31"> 31: </a></span>import org.firebirdsql.logging.LoggerFactory;
<span class="nocode"><a name="32"> 32: </a></span>
<span class="nocode"><a name="33"> 33: </a></span>/**
<span class="nocode"><a name="34"> 34: </a></span> * Comprehensive information about the database as a whole.
<span class="nocode"><a name="35"> 35: </a></span> *
<span class="nocode"><a name="36"> 36: </a></span> * &lt;P&gt;Many of the methods here return lists of information in
<span class="nocode"><a name="37"> 37: </a></span> * the form of &lt;code&gt;ResultSet&lt;/code&gt; objects.
<span class="nocode"><a name="38"> 38: </a></span> * You can use the normal &lt;code&gt;ResultSet&lt;/code&gt; methods such as getString and getInt
<span class="nocode"><a name="39"> 39: </a></span> * to retrieve the data from these &lt;code&gt;ResultSet&lt;/code&gt;.  If a given form of
<span class="nocode"><a name="40"> 40: </a></span> * metadata is not available, these methods should throw an SQLException.
<span class="nocode"><a name="41"> 41: </a></span> *
<span class="nocode"><a name="42"> 42: </a></span> * &lt;P&gt;Some of these methods take arguments that are String patterns.  These
<span class="nocode"><a name="43"> 43: </a></span> * arguments all have names such as fooPattern.  Within a pattern String, &quot;%&quot;
<span class="nocode"><a name="44"> 44: </a></span> * means match any substring of 0 or more characters, and &quot;_&quot; means match
<span class="nocode"><a name="45"> 45: </a></span> * any one character. Only metadata entries matching the search pattern
<span class="nocode"><a name="46"> 46: </a></span> * are returned. If a search pattern argument is set to a null ref,
<span class="nocode"><a name="47"> 47: </a></span> * that argument's criteria will be dropped from the search.
<span class="nocode"><a name="48"> 48: </a></span> *
<span class="nocode"><a name="49"> 49: </a></span> * &lt;P&gt;An &lt;code&gt;SQLException&lt;/code&gt; will be thrown if a driver does not support a meta
<span class="nocode"><a name="50"> 50: </a></span> * data method.  In the case of methods that return a &lt;code&gt;ResultSet&lt;/code&gt;,
<span class="nocode"><a name="51"> 51: </a></span> * either a &lt;code&gt;ResultSet&lt;/code&gt; (which may be empty) is returned or a
<span class="nocode"><a name="52"> 52: </a></span> * SQLException is thrown.
<span class="nocode"><a name="53"> 53: </a></span> *
<span class="nocode"><a name="54"> 54: </a></span> * @author &lt;a href=&quot;mailto:d_jencks@users.sourceforge.net&quot;&gt;David Jencks&lt;/a&gt;
<span class="nocode"><a name="55"> 55: </a></span> * @author &lt;a href=&quot;mailto:mrotteveel@users.sourceforge.net&quot;&gt;Mark Rotteveel&lt;/a&gt;
<span class="nocode"><a name="56"> 56: </a></span> */
<span class="nocode"><a name="57"> 57: </a></span>public abstract class AbstractDatabaseMetaData implements FirebirdDatabaseMetaData {
<span class="nocode"><a name="58"> 58: </a></span>
<span class="nocode"><a name="59"> 59: </a></span>    private final static Logger log = LoggerFactory.getLogger(FBDatabaseMetaData.class,false);
<span class="nocode"><a name="60"> 60: </a></span>    public static final String SPACES = &quot;                               &quot;;//31 spaces
<span class="nocode"><a name="61"> 61: </a></span>
<span class="nocode"><a name="62"> 62: </a></span>    private GDSHelper gdsHelper;
<span class="nocode"><a name="63"> 63: </a></span>    private AbstractConnection connection;
<span class="nocode"><a name="64"> 64: </a></span>
<span class="nocode"><a name="65"> 65: </a></span><span style="background-color: #ffffcc">    protected final Map&lt;String, AbstractPreparedStatement&gt; statements = new HashMap&lt;String, AbstractPreparedStatement&gt;();</span>
<span class="nocode"><a name="66"> 66: </a></span>
<span class="nocode"><a name="67"> 67: </a></span>    protected AbstractDatabaseMetaData(GDSHelper gdsHelper) {
<span class="nocode"><a name="68"> 68: </a></span><span style="background-color: #ffffcc">        this.gdsHelper = gdsHelper;</span>
<span class="nocode"><a name="69"> 69: </a></span><span style="background-color: #ffffcc">    }</span>
<span class="nocode"><a name="70"> 70: </a></span>    
<span class="nocode"><a name="71"> 71: </a></span>    protected AbstractDatabaseMetaData(AbstractConnection c) throws GDSException {
<span class="nocode"><a name="72"> 72: </a></span><span style="background-color: #ffffcc">        this.gdsHelper = c.getGDSHelper();</span>
<span class="nocode"><a name="73"> 73: </a></span>        this.connection = c;
<span class="nocode"><a name="74"> 74: </a></span>    }
<span class="nocode"><a name="75"> 75: </a></span>
<span class="nocode"><a name="76"> 76: </a></span>    protected void close() {
<span class="nocode"><a name="77"> 77: </a></span>        try {
<span class="nocode"><a name="78"> 78: </a></span>            for (AbstractStatement stmt : statements.values()) {
<span class="nocode"><a name="79"> 79: </a></span>                if (!stmt.isClosed())
<span class="nocode"><a name="80"> 80: </a></span>                    stmt.close();
<span class="nocode"><a name="81"> 81: </a></span>            }
<span class="nocode"><a name="82"> 82: </a></span>            statements.clear();
<span class="nocode"><a name="83"> 83: </a></span>        }
<span class="nocode"><a name="84"> 84: </a></span>        catch (SQLException e) {
<span class="nocode"><a name="85"> 85: </a></span>           if (log!=null) log.warn(&quot;error in DatabaseMetaData.close&quot;, e);
<span class="nocode"><a name="86"> 86: </a></span>        }
<span class="nocode"><a name="87"> 87: </a></span>    }
<span class="nocode"><a name="88"> 88: </a></span>
<span class="nocode"><a name="89"> 89: </a></span>    //----------------------------------------------------------------------
<span class="nocode"><a name="90"> 90: </a></span>    // First, a variety of minor information about the target database.
<span class="nocode"><a name="91"> 91: </a></span>
<span class="nocode"><a name="92"> 92: </a></span>    /**
<span class="nocode"><a name="93"> 93: </a></span>     * Can all the procedures returned by getProcedures be called by the
<span class="nocode"><a name="94"> 94: </a></span>     * current user?
<span class="nocode"><a name="95"> 95: </a></span>     *
<span class="nocode"><a name="96"> 96: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="97"> 97: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="98"> 98: </a></span>     */
<span class="nocode"><a name="99"> 99: </a></span>    public  boolean allProceduresAreCallable() throws SQLException {
<span class="nocode"><a name="100">100: </a></span>        //returns all procedures whether or not you have execute permission
<span class="nocode"><a name="101">101: </a></span>        return false;
<span class="nocode"><a name="102">102: </a></span>    }
<span class="nocode"><a name="103">103: </a></span>
<span class="nocode"><a name="104">104: </a></span>
<span class="nocode"><a name="105">105: </a></span>    /**
<span class="nocode"><a name="106">106: </a></span>     * Can all the tables returned by getTable be SELECTed by the
<span class="nocode"><a name="107">107: </a></span>     * current user?
<span class="nocode"><a name="108">108: </a></span>     *
<span class="nocode"><a name="109">109: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="110">110: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="111">111: </a></span>     */
<span class="nocode"><a name="112">112: </a></span>    public  boolean allTablesAreSelectable() throws SQLException {
<span class="nocode"><a name="113">113: </a></span>        //returns all tables matching criteria independent of access permissions.
<span class="nocode"><a name="114">114: </a></span>        return false;
<span class="nocode"><a name="115">115: </a></span>    }
<span class="nocode"><a name="116">116: </a></span>
<span class="nocode"><a name="117">117: </a></span>
<span class="nocode"><a name="118">118: </a></span>    /**
<span class="nocode"><a name="119">119: </a></span>     * What's the url for this database?
<span class="nocode"><a name="120">120: </a></span>     *
<span class="nocode"><a name="121">121: </a></span>     * @return the url or null if it cannot be generated
<span class="nocode"><a name="122">122: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="123">123: </a></span>     */
<span class="nocode"><a name="124">124: </a></span>    public  String getURL() throws SQLException {
<span class="nocode"><a name="125">125: </a></span>        AbstractGDS gds = ((AbstractGDS) connection.getInternalAPIHandler());
<span class="nocode"><a name="126">126: </a></span>        
<span class="nocode"><a name="127">127: </a></span>        return GDSFactory.getJdbcUrl(gds.getType(), connection.mc.getDatabase());
<span class="nocode"><a name="128">128: </a></span>    }
<span class="nocode"><a name="129">129: </a></span>
<span class="nocode"><a name="130">130: </a></span>
<span class="nocode"><a name="131">131: </a></span>    /**
<span class="nocode"><a name="132">132: </a></span>     * What's our user name as known to the database?
<span class="nocode"><a name="133">133: </a></span>     * 
<span class="nocode"><a name="134">134: </a></span>     * @return our database user name
<span class="nocode"><a name="135">135: </a></span>     * @exception SQLException
<span class="nocode"><a name="136">136: </a></span>     *                if a database access error occurs
<span class="nocode"><a name="137">137: </a></span>     */
<span class="nocode"><a name="138">138: </a></span>    public  String getUserName() throws SQLException {
<span class="nocode"><a name="139">139: </a></span>        return gdsHelper.getUserName();
<span class="nocode"><a name="140">140: </a></span>    }
<span class="nocode"><a name="141">141: </a></span>
<span class="nocode"><a name="142">142: </a></span>
<span class="nocode"><a name="143">143: </a></span>    /**
<span class="nocode"><a name="144">144: </a></span>     * Is the database in read-only mode?
<span class="nocode"><a name="145">145: </a></span>     *
<span class="nocode"><a name="146">146: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="147">147: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="148">148: </a></span>     */
<span class="nocode"><a name="149">149: </a></span>    public  boolean isReadOnly() throws SQLException {
<span class="nocode"><a name="150">150: </a></span>        return false;//could be true, not yetimplemented
<span class="nocode"><a name="151">151: </a></span>    }
<span class="nocode"><a name="152">152: </a></span>
<span class="nocode"><a name="153">153: </a></span>
<span class="nocode"><a name="154">154: </a></span>    /**
<span class="nocode"><a name="155">155: </a></span>     * Are NULL values sorted high?
<span class="nocode"><a name="156">156: </a></span>     *
<span class="nocode"><a name="157">157: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="158">158: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="159">159: </a></span>     */
<span class="nocode"><a name="160">160: </a></span>    public  boolean nullsAreSortedHigh() throws SQLException {
<span class="nocode"><a name="161">161: </a></span>        // in Firebird 1.5.x NULLs are always sorted at the end
<span class="nocode"><a name="162">162: </a></span>        // in Firebird 2.0.x NULLs are sorted low
<span class="nocode"><a name="163">163: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="164">164: </a></span>    }
<span class="nocode"><a name="165">165: </a></span>
<span class="nocode"><a name="166">166: </a></span>
<span class="nocode"><a name="167">167: </a></span>    /**
<span class="nocode"><a name="168">168: </a></span>     * Are NULL values sorted low?
<span class="nocode"><a name="169">169: </a></span>     *
<span class="nocode"><a name="170">170: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="171">171: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="172">172: </a></span>     */
<span class="nocode"><a name="173">173: </a></span>    public  boolean nullsAreSortedLow() throws SQLException {
<span class="nocode"><a name="174">174: </a></span>        // in Firebird 1.5.x NULLs are always sorted at the end
<span class="nocode"><a name="175">175: </a></span>        // in Firebird 2.0.x NULLs are sorted low
<span class="nocode"><a name="176">176: </a></span>        return gdsHelper.compareToVersion(2, 0) &gt;= 0;
<span class="nocode"><a name="177">177: </a></span>    }
<span class="nocode"><a name="178">178: </a></span>
<span class="nocode"><a name="179">179: </a></span>
<span class="nocode"><a name="180">180: </a></span>    /**
<span class="nocode"><a name="181">181: </a></span>     * Are NULL values sorted at the start regardless of sort order?
<span class="nocode"><a name="182">182: </a></span>     *
<span class="nocode"><a name="183">183: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="184">184: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="185">185: </a></span>     */
<span class="nocode"><a name="186">186: </a></span>    public  boolean nullsAreSortedAtStart() throws SQLException {
<span class="nocode"><a name="187">187: </a></span>        // in Firebird 1.5.x NULLs are always sorted at the end
<span class="nocode"><a name="188">188: </a></span>        // in Firebird 2.0.x NULLs are sorted low
<span class="nocode"><a name="189">189: </a></span>        return false;
<span class="nocode"><a name="190">190: </a></span>    }
<span class="nocode"><a name="191">191: </a></span>
<span class="nocode"><a name="192">192: </a></span>
<span class="nocode"><a name="193">193: </a></span>    /**
<span class="nocode"><a name="194">194: </a></span>     * Are NULL values sorted at the end regardless of sort order?
<span class="nocode"><a name="195">195: </a></span>     *
<span class="nocode"><a name="196">196: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="197">197: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="198">198: </a></span>     */
<span class="nocode"><a name="199">199: </a></span>    public  boolean nullsAreSortedAtEnd() throws SQLException {
<span class="nocode"><a name="200">200: </a></span>        // in Firebird 1.5.x NULLs are always sorted at the end
<span class="nocode"><a name="201">201: </a></span>        // in Firebird 2.0.x NULLs are sorted low
<span class="nocode"><a name="202">202: </a></span>        return gdsHelper.compareToVersion(2, 0) &lt; 0;
<span class="nocode"><a name="203">203: </a></span>    }
<span class="nocode"><a name="204">204: </a></span>
<span class="nocode"><a name="205">205: </a></span>
<span class="nocode"><a name="206">206: </a></span>    /**
<span class="nocode"><a name="207">207: </a></span>     * What's the name of this database product?
<span class="nocode"><a name="208">208: </a></span>     *
<span class="nocode"><a name="209">209: </a></span>     * @return database product name
<span class="nocode"><a name="210">210: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="211">211: </a></span>     */
<span class="nocode"><a name="212">212: </a></span>    public  String getDatabaseProductName() throws SQLException {
<span class="nocode"><a name="213">213: </a></span>        return gdsHelper.getDatabaseProductName();
<span class="nocode"><a name="214">214: </a></span>    }
<span class="nocode"><a name="215">215: </a></span>
<span class="nocode"><a name="216">216: </a></span>
<span class="nocode"><a name="217">217: </a></span>    /**
<span class="nocode"><a name="218">218: </a></span>     * What's the version of this database product?
<span class="nocode"><a name="219">219: </a></span>     *
<span class="nocode"><a name="220">220: </a></span>     * @return database version
<span class="nocode"><a name="221">221: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="222">222: </a></span>     */
<span class="nocode"><a name="223">223: </a></span>    public  String getDatabaseProductVersion() throws SQLException {
<span class="nocode"><a name="224">224: </a></span>        return gdsHelper.getDatabaseProductVersion();
<span class="nocode"><a name="225">225: </a></span>    }
<span class="nocode"><a name="226">226: </a></span>
<span class="nocode"><a name="227">227: </a></span>
<span class="nocode"><a name="228">228: </a></span>    /**
<span class="nocode"><a name="229">229: </a></span>     * What's the name of this JDBC driver?
<span class="nocode"><a name="230">230: </a></span>     *
<span class="nocode"><a name="231">231: </a></span>     * @return JDBC driver name
<span class="nocode"><a name="232">232: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="233">233: </a></span>     */
<span class="nocode"><a name="234">234: </a></span>    public  String getDriverName() throws SQLException {
<span class="nocode"><a name="235">235: </a></span>        return &quot;Jaybird JCA/JDBC driver&quot;;
<span class="nocode"><a name="236">236: </a></span>    }
<span class="nocode"><a name="237">237: </a></span>
<span class="nocode"><a name="238">238: </a></span>
<span class="nocode"><a name="239">239: </a></span>    /**
<span class="nocode"><a name="240">240: </a></span>     * What's the version of this JDBC driver?
<span class="nocode"><a name="241">241: </a></span>     *
<span class="nocode"><a name="242">242: </a></span>     * @return JDBC driver version
<span class="nocode"><a name="243">243: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="244">244: </a></span>     */
<span class="nocode"><a name="245">245: </a></span>    public  String getDriverVersion() throws SQLException {
<span class="nocode"><a name="246">246: </a></span>        return &quot;2.2&quot;;
<span class="nocode"><a name="247">247: </a></span>    }
<span class="nocode"><a name="248">248: </a></span>
<span class="nocode"><a name="249">249: </a></span>
<span class="nocode"><a name="250">250: </a></span>    /**
<span class="nocode"><a name="251">251: </a></span>     * What's this JDBC driver's major version number?
<span class="nocode"><a name="252">252: </a></span>     *
<span class="nocode"><a name="253">253: </a></span>     * @return JDBC driver major version
<span class="nocode"><a name="254">254: </a></span>     */
<span class="nocode"><a name="255">255: </a></span>    public  int getDriverMajorVersion() {
<span class="nocode"><a name="256">256: </a></span>        return 2;
<span class="nocode"><a name="257">257: </a></span>    }
<span class="nocode"><a name="258">258: </a></span>
<span class="nocode"><a name="259">259: </a></span>
<span class="nocode"><a name="260">260: </a></span>    /**
<span class="nocode"><a name="261">261: </a></span>     * What's this JDBC driver's minor version number?
<span class="nocode"><a name="262">262: </a></span>     *
<span class="nocode"><a name="263">263: </a></span>     * @return JDBC driver minor version number
<span class="nocode"><a name="264">264: </a></span>     */
<span class="nocode"><a name="265">265: </a></span>    public  int getDriverMinorVersion() {
<span class="nocode"><a name="266">266: </a></span>        return 2;
<span class="nocode"><a name="267">267: </a></span>    }
<span class="nocode"><a name="268">268: </a></span>
<span class="nocode"><a name="269">269: </a></span>
<span class="nocode"><a name="270">270: </a></span>    /**
<span class="nocode"><a name="271">271: </a></span>     * Does the database store tables in a local file?
<span class="nocode"><a name="272">272: </a></span>     *
<span class="nocode"><a name="273">273: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="274">274: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="275">275: </a></span>     */
<span class="nocode"><a name="276">276: </a></span>    public  boolean usesLocalFiles() throws SQLException {
<span class="nocode"><a name="277">277: </a></span>        return false;
<span class="nocode"><a name="278">278: </a></span>    }
<span class="nocode"><a name="279">279: </a></span>
<span class="nocode"><a name="280">280: </a></span>
<span class="nocode"><a name="281">281: </a></span>    /**
<span class="nocode"><a name="282">282: </a></span>     * Does the database use a file for each table?
<span class="nocode"><a name="283">283: </a></span>     *
<span class="nocode"><a name="284">284: </a></span>     * @return true if the database uses a local file for each table
<span class="nocode"><a name="285">285: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="286">286: </a></span>     */
<span class="nocode"><a name="287">287: </a></span>    public  boolean usesLocalFilePerTable() throws SQLException {
<span class="nocode"><a name="288">288: </a></span>        return false;
<span class="nocode"><a name="289">289: </a></span>    }
<span class="nocode"><a name="290">290: </a></span>
<span class="nocode"><a name="291">291: </a></span>
<span class="nocode"><a name="292">292: </a></span>    /**
<span class="nocode"><a name="293">293: </a></span>     * Does the database treat mixed case unquoted SQL identifiers as
<span class="nocode"><a name="294">294: </a></span>     * case sensitive and as a result store them in mixed case?
<span class="nocode"><a name="295">295: </a></span>     *
<span class="nocode"><a name="296">296: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver will always return false.
<span class="nocode"><a name="297">297: </a></span>     *
<span class="nocode"><a name="298">298: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="299">299: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="300">300: </a></span>     */
<span class="nocode"><a name="301">301: </a></span>    public  boolean supportsMixedCaseIdentifiers() throws SQLException {
<span class="nocode"><a name="302">302: </a></span>        return false;
<span class="nocode"><a name="303">303: </a></span>    }
<span class="nocode"><a name="304">304: </a></span>
<span class="nocode"><a name="305">305: </a></span>    /**
<span class="nocode"><a name="306">306: </a></span>     *
<span class="nocode"><a name="307">307: </a></span>     * @return a &lt;code&gt;boolean&lt;/code&gt; value
<span class="nocode"><a name="308">308: </a></span>     * @exception SQLException if an error occurs
<span class="nocode"><a name="309">309: </a></span>     * TODO implement statement pooling on the server.. then in the driver
<span class="nocode"><a name="310">310: </a></span>     */
<span class="nocode"><a name="311">311: </a></span>    public boolean supportsStatementPooling() throws SQLException {
<span class="nocode"><a name="312">312: </a></span>        return false;
<span class="nocode"><a name="313">313: </a></span>    }
<span class="nocode"><a name="314">314: </a></span>
<span class="nocode"><a name="315">315: </a></span>    public boolean locatorsUpdateCopy() throws SQLException {
<span class="nocode"><a name="316">316: </a></span>        // Firebird creates a new blob when making changes
<span class="nocode"><a name="317">317: </a></span>        return true;
<span class="nocode"><a name="318">318: </a></span>    }
<span class="nocode"><a name="319">319: </a></span>
<span class="nocode"><a name="320">320: </a></span>    /**
<span class="nocode"><a name="321">321: </a></span>     * Does the database treat mixed case unquoted SQL identifiers as
<span class="nocode"><a name="322">322: </a></span>     * case insensitive and store them in upper case?
<span class="nocode"><a name="323">323: </a></span>     *
<span class="nocode"><a name="324">324: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="325">325: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="326">326: </a></span>     */
<span class="nocode"><a name="327">327: </a></span>    public  boolean storesUpperCaseIdentifiers() throws SQLException {
<span class="nocode"><a name="328">328: </a></span><span style="background-color: #ffffcc">        return true;</span>
<span class="nocode"><a name="329">329: </a></span>    }
<span class="nocode"><a name="330">330: </a></span>
<span class="nocode"><a name="331">331: </a></span>
<span class="nocode"><a name="332">332: </a></span>    /**
<span class="nocode"><a name="333">333: </a></span>     * Does the database treat mixed case unquoted SQL identifiers as
<span class="nocode"><a name="334">334: </a></span>     * case insensitive and store them in lower case?
<span class="nocode"><a name="335">335: </a></span>     *
<span class="nocode"><a name="336">336: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="337">337: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="338">338: </a></span>     */
<span class="nocode"><a name="339">339: </a></span>    public  boolean storesLowerCaseIdentifiers() throws SQLException {
<span class="nocode"><a name="340">340: </a></span>        return false;
<span class="nocode"><a name="341">341: </a></span>    }
<span class="nocode"><a name="342">342: </a></span>
<span class="nocode"><a name="343">343: </a></span>
<span class="nocode"><a name="344">344: </a></span>    /**
<span class="nocode"><a name="345">345: </a></span>     * Does the database treat mixed case unquoted SQL identifiers as
<span class="nocode"><a name="346">346: </a></span>     * case insensitive and store them in mixed case?
<span class="nocode"><a name="347">347: </a></span>     *
<span class="nocode"><a name="348">348: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="349">349: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="350">350: </a></span>     */
<span class="nocode"><a name="351">351: </a></span>    public  boolean storesMixedCaseIdentifiers() throws SQLException {
<span class="nocode"><a name="352">352: </a></span>        return false;
<span class="nocode"><a name="353">353: </a></span>    }
<span class="nocode"><a name="354">354: </a></span>
<span class="nocode"><a name="355">355: </a></span>
<span class="nocode"><a name="356">356: </a></span>    /**
<span class="nocode"><a name="357">357: </a></span>     * Does the database treat mixed case quoted SQL identifiers as
<span class="nocode"><a name="358">358: </a></span>     * case sensitive and as a result store them in mixed case?
<span class="nocode"><a name="359">359: </a></span>     *
<span class="nocode"><a name="360">360: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver will always return true.
<span class="nocode"><a name="361">361: </a></span>     *
<span class="nocode"><a name="362">362: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="363">363: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="364">364: </a></span>     */
<span class="nocode"><a name="365">365: </a></span>    public  boolean supportsMixedCaseQuotedIdentifiers() throws SQLException {
<span class="nocode"><a name="366">366: </a></span>        return true;
<span class="nocode"><a name="367">367: </a></span>    }
<span class="nocode"><a name="368">368: </a></span>
<span class="nocode"><a name="369">369: </a></span>
<span class="nocode"><a name="370">370: </a></span>    /**
<span class="nocode"><a name="371">371: </a></span>     * Does the database treat mixed case quoted SQL identifiers as
<span class="nocode"><a name="372">372: </a></span>     * case insensitive and store them in upper case?
<span class="nocode"><a name="373">373: </a></span>     *
<span class="nocode"><a name="374">374: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="375">375: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="376">376: </a></span>     */
<span class="nocode"><a name="377">377: </a></span>    public  boolean storesUpperCaseQuotedIdentifiers() throws SQLException {
<span class="nocode"><a name="378">378: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="379">379: </a></span>    }
<span class="nocode"><a name="380">380: </a></span>
<span class="nocode"><a name="381">381: </a></span>
<span class="nocode"><a name="382">382: </a></span>    /**
<span class="nocode"><a name="383">383: </a></span>     * Does the database treat mixed case quoted SQL identifiers as
<span class="nocode"><a name="384">384: </a></span>     * case insensitive and store them in lower case?
<span class="nocode"><a name="385">385: </a></span>     *
<span class="nocode"><a name="386">386: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="387">387: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="388">388: </a></span>     */
<span class="nocode"><a name="389">389: </a></span>    public  boolean storesLowerCaseQuotedIdentifiers() throws SQLException {
<span class="nocode"><a name="390">390: </a></span>        return false;
<span class="nocode"><a name="391">391: </a></span>    }
<span class="nocode"><a name="392">392: </a></span>
<span class="nocode"><a name="393">393: </a></span>
<span class="nocode"><a name="394">394: </a></span>    /**
<span class="nocode"><a name="395">395: </a></span>     * Does the database treat mixed case quoted SQL identifiers as
<span class="nocode"><a name="396">396: </a></span>     * case insensitive and store them in mixed case?
<span class="nocode"><a name="397">397: </a></span>     *
<span class="nocode"><a name="398">398: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="399">399: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="400">400: </a></span>     */
<span class="nocode"><a name="401">401: </a></span>    public  boolean storesMixedCaseQuotedIdentifiers() throws SQLException {
<span class="nocode"><a name="402">402: </a></span>        return false;
<span class="nocode"><a name="403">403: </a></span>    }
<span class="nocode"><a name="404">404: </a></span>
<span class="nocode"><a name="405">405: </a></span>
<span class="nocode"><a name="406">406: </a></span>    /**
<span class="nocode"><a name="407">407: </a></span>     * What's the string used to quote SQL identifiers?
<span class="nocode"><a name="408">408: </a></span>     * This returns a space &quot; &quot; if identifier quoting isn't supported.
<span class="nocode"><a name="409">409: </a></span>     *
<span class="nocode"><a name="410">410: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt;
<span class="nocode"><a name="411">411: </a></span>     * driver always uses a double quote character.
<span class="nocode"><a name="412">412: </a></span>     *
<span class="nocode"><a name="413">413: </a></span>     * @return the quoting string
<span class="nocode"><a name="414">414: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="415">415: </a></span>     */
<span class="nocode"><a name="416">416: </a></span>    public  String getIdentifierQuoteString() throws SQLException {
<span class="nocode"><a name="417">417: </a></span>        return &quot;\&quot;&quot;;
<span class="nocode"><a name="418">418: </a></span>    }
<span class="nocode"><a name="419">419: </a></span>
<span class="nocode"><a name="420">420: </a></span>    /**
<span class="nocode"><a name="421">421: </a></span>     * Describe constant &lt;code&gt;fbSQLKeywords&lt;/code&gt; here.
<span class="nocode"><a name="422">422: </a></span>     * Derived from firebird2/src/dsql/keywords.cpp.
<span class="nocode"><a name="423">423: </a></span>     * Exclusions from list of sql-92 keywords in SQL Instant Reference,
<span class="nocode"><a name="424">424: </a></span>     * Martin Gruber (1993) Sybex.
<span class="nocode"><a name="425">425: </a></span>     *
<span class="nocode"><a name="426">426: </a></span>     */
<span class="nocode"><a name="427">427: </a></span>    private final static String fbSQLKeywords =
<span class="nocode"><a name="428">428: </a></span>    //&quot;ACTION,&quot; +
<span class="nocode"><a name="429">429: </a></span>    &quot;ACTIVE,&quot; +
<span class="nocode"><a name="430">430: </a></span>    //&quot;ADD,&quot; +
<span class="nocode"><a name="431">431: </a></span>    &quot;ADMIN,&quot; +
<span class="nocode"><a name="432">432: </a></span>    &quot;AFTER,&quot; +
<span class="nocode"><a name="433">433: </a></span>    //&quot;ALL,&quot; +
<span class="nocode"><a name="434">434: </a></span>    //&quot;ALTER,&quot; + 
<span class="nocode"><a name="435">435: </a></span>    //&quot;AND,&quot; + 
<span class="nocode"><a name="436">436: </a></span>    //&quot;ANY,&quot; + 
<span class="nocode"><a name="437">437: </a></span>    //&quot;AS,&quot; + 
<span class="nocode"><a name="438">438: </a></span>    //&quot;ASC,&quot; +    /* Alias of ASCENDING */
<span class="nocode"><a name="439">439: </a></span>    &quot;ASCENDING,&quot; +
<span class="nocode"><a name="440">440: </a></span>    //&quot;AT,&quot; +
<span class="nocode"><a name="441">441: </a></span>    &quot;AUTO,&quot; +
<span class="nocode"><a name="442">442: </a></span>    //&quot;AVG,&quot; +
<span class="nocode"><a name="443">443: </a></span>    &quot;BASE_NAME,&quot; +
<span class="nocode"><a name="444">444: </a></span>    &quot;BEFORE,&quot; +
<span class="nocode"><a name="445">445: </a></span>    //&quot;BEGIN,&quot; +
<span class="nocode"><a name="446">446: </a></span>    //&quot;BETWEEN,&quot; +
<span class="nocode"><a name="447">447: </a></span>    &quot;BIGINT,&quot; +
<span class="nocode"><a name="448">448: </a></span>    &quot;BLOB,&quot; +
<span class="nocode"><a name="449">449: </a></span>    &quot;BREAK,&quot; + 
<span class="nocode"><a name="450">450: </a></span>    //&quot;BY,&quot; +
<span class="nocode"><a name="451">451: </a></span>    &quot;CACHE,&quot; +
<span class="nocode"><a name="452">452: </a></span>    //&quot;CASCADE,&quot; +
<span class="nocode"><a name="453">453: </a></span>    //&quot;CASE,&quot; +
<span class="nocode"><a name="454">454: </a></span>    //&quot;CAST,&quot; +
<span class="nocode"><a name="455">455: </a></span>    //&quot;CHAR,&quot; +
<span class="nocode"><a name="456">456: </a></span>    //&quot;CHARACTER,&quot; +
<span class="nocode"><a name="457">457: </a></span>    //&quot;CHECK,&quot; +
<span class="nocode"><a name="458">458: </a></span>    &quot;CHECK_POINT_LENGTH,&quot; +
<span class="nocode"><a name="459">459: </a></span>    //&quot;COALESCE,&quot; +
<span class="nocode"><a name="460">460: </a></span>    //&quot;COLLATE,&quot; +
<span class="nocode"><a name="461">461: </a></span>    //&quot;COLUMN,&quot; +
<span class="nocode"><a name="462">462: </a></span>    //&quot;COMMIT,&quot; +
<span class="nocode"><a name="463">463: </a></span>    //&quot;COMMITTED,&quot; +
<span class="nocode"><a name="464">464: </a></span>    &quot;COMPUTED,&quot; +
<span class="nocode"><a name="465">465: </a></span>    &quot;CONDITIONAL,&quot; +
<span class="nocode"><a name="466">466: </a></span>    &quot;CONNECTION_ID,&quot; +
<span class="nocode"><a name="467">467: </a></span>    //&quot;CONSTRAINT,&quot; +
<span class="nocode"><a name="468">468: </a></span>    &quot;CONTAINING,&quot; +
<span class="nocode"><a name="469">469: </a></span>    //&quot;COUNT,&quot; +
<span class="nocode"><a name="470">470: </a></span>    //&quot;CREATE,&quot; +
<span class="nocode"><a name="471">471: </a></span>    &quot;CSTRING,&quot; +
<span class="nocode"><a name="472">472: </a></span>    //&quot;CURRENT,&quot; +
<span class="nocode"><a name="473">473: </a></span>    //&quot;CURRENT_DATE,&quot; +
<span class="nocode"><a name="474">474: </a></span>    &quot;CURRENT_ROLE,&quot; +
<span class="nocode"><a name="475">475: </a></span>    //&quot;CURRENT_TIME,&quot; +
<span class="nocode"><a name="476">476: </a></span>    //&quot;CURRENT_TIMESTAMP,&quot; +
<span class="nocode"><a name="477">477: </a></span>    //&quot;CURRENT_USER,&quot; +
<span class="nocode"><a name="478">478: </a></span>    //&quot;CURSOR,&quot; +
<span class="nocode"><a name="479">479: </a></span>    &quot;DATABASE,&quot; +
<span class="nocode"><a name="480">480: </a></span>    //&quot;DATE,&quot; +
<span class="nocode"><a name="481">481: </a></span>    //&quot;DAY,&quot; +
<span class="nocode"><a name="482">482: </a></span>    &quot;DEBUG,&quot; +
<span class="nocode"><a name="483">483: </a></span>    //&quot;DEC,&quot; +
<span class="nocode"><a name="484">484: </a></span>    //&quot;DECIMAL,&quot; +
<span class="nocode"><a name="485">485: </a></span>    //&quot;DECLARE,&quot; +
<span class="nocode"><a name="486">486: </a></span>    //&quot;DEFAULT,&quot; + 
<span class="nocode"><a name="487">487: </a></span>    //&quot;DELETE,&quot; + 
<span class="nocode"><a name="488">488: </a></span>    //&quot;DESC,&quot; +    /* Alias of DESCENDING */
<span class="nocode"><a name="489">489: </a></span>    &quot;DESCENDING,&quot; +
<span class="nocode"><a name="490">490: </a></span>    //&quot;DESCRIPTOR,&quot; +
<span class="nocode"><a name="491">491: </a></span>    //&quot;DISTINCT,&quot; +
<span class="nocode"><a name="492">492: </a></span>    &quot;DO,&quot; +
<span class="nocode"><a name="493">493: </a></span>    //&quot;DOMAIN,&quot; +
<span class="nocode"><a name="494">494: </a></span>    //&quot;DOUBLE,&quot; +
<span class="nocode"><a name="495">495: </a></span>    //&quot;DROP,&quot; +
<span class="nocode"><a name="496">496: </a></span>    //&quot;ELSE,&quot; +
<span class="nocode"><a name="497">497: </a></span>    //&quot;END,&quot; +
<span class="nocode"><a name="498">498: </a></span>    &quot;ENTRY_POINT,&quot; +
<span class="nocode"><a name="499">499: </a></span>    //&quot;ESCAPE,&quot; +
<span class="nocode"><a name="500">500: </a></span>    //&quot;EXCEPTION,&quot; +
<span class="nocode"><a name="501">501: </a></span>    //&quot;EXECUTE,&quot; +
<span class="nocode"><a name="502">502: </a></span>    //&quot;EXISTS,&quot; +
<span class="nocode"><a name="503">503: </a></span>    &quot;EXIT,&quot; +
<span class="nocode"><a name="504">504: </a></span>    //&quot;EXTERNAL,&quot; +
<span class="nocode"><a name="505">505: </a></span>    //&quot;EXTRACT,&quot; +
<span class="nocode"><a name="506">506: </a></span>    &quot;FILE,&quot; +
<span class="nocode"><a name="507">507: </a></span>    &quot;FILTER,&quot; +
<span class="nocode"><a name="508">508: </a></span>    //&quot;FIRST,&quot; +
<span class="nocode"><a name="509">509: </a></span>    //&quot;FLOAT,&quot; +
<span class="nocode"><a name="510">510: </a></span>    //&quot;FOR,&quot; +
<span class="nocode"><a name="511">511: </a></span>    //&quot;FOREIGN,&quot; +
<span class="nocode"><a name="512">512: </a></span>    &quot;FREE_IT,&quot; +
<span class="nocode"><a name="513">513: </a></span>    //&quot;FROM,&quot; +
<span class="nocode"><a name="514">514: </a></span>    //&quot;FULL,&quot; +
<span class="nocode"><a name="515">515: </a></span>    &quot;FUNCTION,&quot; +
<span class="nocode"><a name="516">516: </a></span>    &quot;GDSCODE,&quot; +
<span class="nocode"><a name="517">517: </a></span>    &quot;GENERATOR,&quot; +
<span class="nocode"><a name="518">518: </a></span>    &quot;GEN_ID,&quot; +
<span class="nocode"><a name="519">519: </a></span>    //&quot;GRANT,&quot; +
<span class="nocode"><a name="520">520: </a></span>    //&quot;GROUP,&quot; +
<span class="nocode"><a name="521">521: </a></span>    &quot;GROUP_COMMIT_WAIT_TIME,&quot; +
<span class="nocode"><a name="522">522: </a></span>    //&quot;HAVING,&quot; +
<span class="nocode"><a name="523">523: </a></span>    //&quot;HOUR,&quot; +
<span class="nocode"><a name="524">524: </a></span>    &quot;IF,&quot; +
<span class="nocode"><a name="525">525: </a></span>    //&quot;IN,&quot; +
<span class="nocode"><a name="526">526: </a></span>    &quot;INACTIVE,&quot; +
<span class="nocode"><a name="527">527: </a></span>    &quot;INDEX,&quot; +
<span class="nocode"><a name="528">528: </a></span>    //&quot;INNER,&quot; +
<span class="nocode"><a name="529">529: </a></span>    &quot;INPUT_TYPE,&quot; +
<span class="nocode"><a name="530">530: </a></span>    //&quot;INSERT,&quot; +
<span class="nocode"><a name="531">531: </a></span>    //&quot;INT,&quot; +
<span class="nocode"><a name="532">532: </a></span>    //&quot;INTEGER,&quot; +
<span class="nocode"><a name="533">533: </a></span>    //&quot;INTO,&quot; +
<span class="nocode"><a name="534">534: </a></span>    //&quot;IS,&quot; +
<span class="nocode"><a name="535">535: </a></span>    //&quot;ISOLATION,&quot; +
<span class="nocode"><a name="536">536: </a></span>    //&quot;JOIN,&quot; +
<span class="nocode"><a name="537">537: </a></span>    //&quot;KEY,&quot; +
<span class="nocode"><a name="538">538: </a></span>    //&quot;LAST,&quot; +
<span class="nocode"><a name="539">539: </a></span>    //&quot;LEFT,&quot; +
<span class="nocode"><a name="540">540: </a></span>    //&quot;LENGTH,&quot; +
<span class="nocode"><a name="541">541: </a></span>    //&quot;LEVEL,&quot; +
<span class="nocode"><a name="542">542: </a></span>    //&quot;LIKE,&quot; +
<span class="nocode"><a name="543">543: </a></span>    &quot;LOGFILE,&quot; +
<span class="nocode"><a name="544">544: </a></span>    &quot;LOG_BUFFER_SIZE,&quot; +
<span class="nocode"><a name="545">545: </a></span>    &quot;LONG,&quot; +
<span class="nocode"><a name="546">546: </a></span>    &quot;MANUAL,&quot; +
<span class="nocode"><a name="547">547: </a></span>    //&quot;MAX,&quot; +
<span class="nocode"><a name="548">548: </a></span>    &quot;MAXIMUM_SEGMENT,&quot; +
<span class="nocode"><a name="549">549: </a></span>    &quot;MERGE,&quot; +
<span class="nocode"><a name="550">550: </a></span>    &quot;MESSAGE,&quot; +
<span class="nocode"><a name="551">551: </a></span>    //&quot;MIN,&quot; +
<span class="nocode"><a name="552">552: </a></span>    //&quot;MINUTE,&quot; +
<span class="nocode"><a name="553">553: </a></span>    &quot;MODULE_NAME,&quot; +
<span class="nocode"><a name="554">554: </a></span>    //&quot;MONTH,&quot; +
<span class="nocode"><a name="555">555: </a></span>    //&quot;NAMES,&quot; +
<span class="nocode"><a name="556">556: </a></span>    //&quot;NATIONAL,&quot; +
<span class="nocode"><a name="557">557: </a></span>    //&quot;NATURAL,&quot; +
<span class="nocode"><a name="558">558: </a></span>    //&quot;NCHAR,&quot; +
<span class="nocode"><a name="559">559: </a></span>    //&quot;NO,&quot; +
<span class="nocode"><a name="560">560: </a></span>    //&quot;NOT,&quot; +
<span class="nocode"><a name="561">561: </a></span>    //&quot;NULLIF,&quot; +
<span class="nocode"><a name="562">562: </a></span>    //&quot;NULL,&quot; +
<span class="nocode"><a name="563">563: </a></span>    &quot;NULLS,&quot; +
<span class="nocode"><a name="564">564: </a></span>    &quot;LOCK,&quot; +
<span class="nocode"><a name="565">565: </a></span>    //&quot;NUMERIC,&quot; +
<span class="nocode"><a name="566">566: </a></span>    &quot;NUM_LOG_BUFFERS,&quot; +
<span class="nocode"><a name="567">567: </a></span>    //&quot;OF,&quot; +
<span class="nocode"><a name="568">568: </a></span>    //&quot;ON,&quot; +
<span class="nocode"><a name="569">569: </a></span>    //&quot;ONLY,&quot; +
<span class="nocode"><a name="570">570: </a></span>    //&quot;OPTION,&quot; +
<span class="nocode"><a name="571">571: </a></span>    //&quot;OR,&quot; +
<span class="nocode"><a name="572">572: </a></span>    //&quot;ORDER,&quot; +
<span class="nocode"><a name="573">573: </a></span>    //&quot;OUTER,&quot; +
<span class="nocode"><a name="574">574: </a></span>    &quot;OUTPUT_TYPE,&quot; +
<span class="nocode"><a name="575">575: </a></span>    &quot;OVERFLOW,&quot; +
<span class="nocode"><a name="576">576: </a></span>    &quot;PAGE,&quot; +
<span class="nocode"><a name="577">577: </a></span>    &quot;PAGES,&quot; +
<span class="nocode"><a name="578">578: </a></span>    &quot;PAGE_SIZE,&quot; +
<span class="nocode"><a name="579">579: </a></span>    &quot;PARAMETER,&quot; +
<span class="nocode"><a name="580">580: </a></span>    &quot;PASSWORD,&quot; +
<span class="nocode"><a name="581">581: </a></span>    &quot;PLAN,&quot; +
<span class="nocode"><a name="582">582: </a></span>    //&quot;POSITION,&quot; +
<span class="nocode"><a name="583">583: </a></span>    &quot;POST_EVENT,&quot; +
<span class="nocode"><a name="584">584: </a></span>    //&quot;PRECISION,&quot; +
<span class="nocode"><a name="585">585: </a></span>    //&quot;PRIMARY,&quot; +
<span class="nocode"><a name="586">586: </a></span>    //&quot;PRIVILEGES,&quot; +
<span class="nocode"><a name="587">587: </a></span>    //&quot;PROCEDURE,&quot; +
<span class="nocode"><a name="588">588: </a></span>    &quot;PROTECTED,&quot; +
<span class="nocode"><a name="589">589: </a></span>    &quot;RAW_PARTITIONS,&quot; +
<span class="nocode"><a name="590">590: </a></span>    &quot;RDB$DB_KEY,&quot; +
<span class="nocode"><a name="591">591: </a></span>    //&quot;READ,&quot; +
<span class="nocode"><a name="592">592: </a></span>    //&quot;REAL,&quot; +
<span class="nocode"><a name="593">593: </a></span>    &quot;RECORD_VERSION,&quot; +
<span class="nocode"><a name="594">594: </a></span>    &quot;RECREATE,&quot; +
<span class="nocode"><a name="595">595: </a></span>    //&quot;REFERENCES,&quot; + 
<span class="nocode"><a name="596">596: </a></span>    &quot;RESERV,&quot; +    /* Alias of RESERVING */
<span class="nocode"><a name="597">597: </a></span>    &quot;RESERVING,&quot; +
<span class="nocode"><a name="598">598: </a></span>    //&quot;RESTRICT,&quot; +
<span class="nocode"><a name="599">599: </a></span>    &quot;RETAIN,&quot; +
<span class="nocode"><a name="600">600: </a></span>    &quot;RETURNING_VALUES,&quot; +
<span class="nocode"><a name="601">601: </a></span>    &quot;RETURNS,&quot; +
<span class="nocode"><a name="602">602: </a></span>    //&quot;REVOKE,&quot; +
<span class="nocode"><a name="603">603: </a></span>    //&quot;RIGHT,&quot; +
<span class="nocode"><a name="604">604: </a></span>    &quot;ROLE,&quot; + 
<span class="nocode"><a name="605">605: </a></span>    //&quot;ROLLBACK,&quot; + 
<span class="nocode"><a name="606">606: </a></span>    &quot;ROWS_AFFECTED,&quot; +
<span class="nocode"><a name="607">607: </a></span>    &quot;SAVEPOINT,&quot; +
<span class="nocode"><a name="608">608: </a></span>    //&quot;SCHEMA,&quot; +    /* Alias of DATABASE */
<span class="nocode"><a name="609">609: </a></span>    //&quot;SECOND,&quot; +
<span class="nocode"><a name="610">610: </a></span>    &quot;SEGMENT,&quot; +
<span class="nocode"><a name="611">611: </a></span>    //&quot;SELECT,&quot; +
<span class="nocode"><a name="612">612: </a></span>    //&quot;SET,&quot; +
<span class="nocode"><a name="613">613: </a></span>    &quot;SHADOW,&quot; +
<span class="nocode"><a name="614">614: </a></span>    &quot;SHARED,&quot; +
<span class="nocode"><a name="615">615: </a></span>    &quot;SINGULAR,&quot; +
<span class="nocode"><a name="616">616: </a></span>    //&quot;SIZE,&quot; +
<span class="nocode"><a name="617">617: </a></span>    &quot;SKIP,&quot; +
<span class="nocode"><a name="618">618: </a></span>    //&quot;SMALLINT,&quot; +
<span class="nocode"><a name="619">619: </a></span>    &quot;SNAPSHOT,&quot; +
<span class="nocode"><a name="620">620: </a></span>    //&quot;SOME,&quot; +
<span class="nocode"><a name="621">621: </a></span>    &quot;SORT,&quot; +
<span class="nocode"><a name="622">622: </a></span>    //&quot;SQLCODE,&quot; +
<span class="nocode"><a name="623">623: </a></span>    &quot;STABILITY,&quot; + 
<span class="nocode"><a name="624">624: </a></span>    &quot;STARTING,&quot; + 
<span class="nocode"><a name="625">625: </a></span>    &quot;STARTS,&quot; +    /* Alias of STARTING */
<span class="nocode"><a name="626">626: </a></span>    &quot;STATISTICS,&quot; +
<span class="nocode"><a name="627">627: </a></span>    //&quot;SUBSTRING,&quot; +
<span class="nocode"><a name="628">628: </a></span>    &quot;SUB_TYPE,&quot; +
<span class="nocode"><a name="629">629: </a></span>    //&quot;SUM,&quot; +
<span class="nocode"><a name="630">630: </a></span>    &quot;SUSPEND,&quot; +
<span class="nocode"><a name="631">631: </a></span>    //&quot;TABLE,&quot; +
<span class="nocode"><a name="632">632: </a></span>    //&quot;THEN,&quot; +
<span class="nocode"><a name="633">633: </a></span>    //&quot;TIME,&quot; +
<span class="nocode"><a name="634">634: </a></span>    //&quot;TIMESTAMP,&quot; +
<span class="nocode"><a name="635">635: </a></span>    //&quot;TO,&quot; +
<span class="nocode"><a name="636">636: </a></span>    //&quot;TRANSACTION,&quot; +
<span class="nocode"><a name="637">637: </a></span>    &quot;TRANSACTION_ID,&quot; +
<span class="nocode"><a name="638">638: </a></span>    &quot;TRIGGER,&quot; +
<span class="nocode"><a name="639">639: </a></span>    //&quot;TYPE,&quot; +
<span class="nocode"><a name="640">640: </a></span>    //&quot;UNCOMMITTED,&quot; +
<span class="nocode"><a name="641">641: </a></span>    //&quot;UNION,&quot; +
<span class="nocode"><a name="642">642: </a></span>    //&quot;UNIQUE,&quot; +
<span class="nocode"><a name="643">643: </a></span>    //&quot;UPDATE,&quot; +
<span class="nocode"><a name="644">644: </a></span>    //&quot;UPPER,&quot; +
<span class="nocode"><a name="645">645: </a></span>    //&quot;USER,&quot; +
<span class="nocode"><a name="646">646: </a></span>    //&quot;USING,&quot; +
<span class="nocode"><a name="647">647: </a></span>    //&quot;VALUE,&quot; +
<span class="nocode"><a name="648">648: </a></span>    //&quot;VALUES,&quot; +
<span class="nocode"><a name="649">649: </a></span>    //&quot;VARCHAR,&quot; +
<span class="nocode"><a name="650">650: </a></span>    &quot;VARIABLE,&quot; +
<span class="nocode"><a name="651">651: </a></span>    //&quot;VARYING,&quot; +
<span class="nocode"><a name="652">652: </a></span>    //&quot;VIEW,&quot; +
<span class="nocode"><a name="653">653: </a></span>    &quot;WAIT,&quot; +
<span class="nocode"><a name="654">654: </a></span>    &quot;WEEKDAY,&quot; +
<span class="nocode"><a name="655">655: </a></span>    //&quot;WHEN,&quot; +
<span class="nocode"><a name="656">656: </a></span>    //&quot;WHERE,&quot; +
<span class="nocode"><a name="657">657: </a></span>    &quot;WHILE,&quot; +
<span class="nocode"><a name="658">658: </a></span>    //&quot;WITH,&quot; +
<span class="nocode"><a name="659">659: </a></span>    //&quot;WORK,&quot; +
<span class="nocode"><a name="660">660: </a></span>    //&quot;WRITE,&quot; + 
<span class="nocode"><a name="661">661: </a></span>    //&quot;YEAR,&quot; + 
<span class="nocode"><a name="662">662: </a></span>    &quot;YEARDAY&quot;; 
<span class="nocode"><a name="663">663: </a></span>
<span class="nocode"><a name="664">664: </a></span>
<span class="nocode"><a name="665">665: </a></span>    /**
<span class="nocode"><a name="666">666: </a></span>     * Gets a comma-separated list of all a database's SQL keywords
<span class="nocode"><a name="667">667: </a></span>     * that are NOT also SQL92 keywords.
<span class="nocode"><a name="668">668: </a></span>     *
<span class="nocode"><a name="669">669: </a></span>     * @return the list
<span class="nocode"><a name="670">670: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="671">671: </a></span>     */
<span class="nocode"><a name="672">672: </a></span>    public  String getSQLKeywords() throws SQLException {
<span class="nocode"><a name="673">673: </a></span>        return fbSQLKeywords;
<span class="nocode"><a name="674">674: </a></span>    }
<span class="nocode"><a name="675">675: </a></span>
<span class="nocode"><a name="676">676: </a></span>
<span class="nocode"><a name="677">677: </a></span>    /**
<span class="nocode"><a name="678">678: </a></span>     * Gets a comma-separated list of math functions.  These are the
<span class="nocode"><a name="679">679: </a></span>     * X/Open CLI math function names used in the JDBC function escape
<span class="nocode"><a name="680">680: </a></span>     * clause.
<span class="nocode"><a name="681">681: </a></span>     *
<span class="nocode"><a name="682">682: </a></span>     * @return the list
<span class="nocode"><a name="683">683: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="684">684: </a></span>     */
<span class="nocode"><a name="685">685: </a></span>    public  String getNumericFunctions() throws SQLException {
<span class="nocode"><a name="686">686: </a></span>        return &quot;&quot;;//udf's
<span class="nocode"><a name="687">687: </a></span>    }
<span class="nocode"><a name="688">688: </a></span>
<span class="nocode"><a name="689">689: </a></span>
<span class="nocode"><a name="690">690: </a></span>    /**
<span class="nocode"><a name="691">691: </a></span>     * Gets a comma-separated list of string functions.  These are the
<span class="nocode"><a name="692">692: </a></span>     * X/Open CLI string function names used in the JDBC function escape
<span class="nocode"><a name="693">693: </a></span>     * clause.
<span class="nocode"><a name="694">694: </a></span>     *
<span class="nocode"><a name="695">695: </a></span>     * @return the list
<span class="nocode"><a name="696">696: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="697">697: </a></span>     */
<span class="nocode"><a name="698">698: </a></span>    public  String getStringFunctions() throws SQLException {
<span class="nocode"><a name="699">699: </a></span>        return &quot;SUBSTRING,UCASE,CONCAT&quot;;
<span class="nocode"><a name="700">700: </a></span>    }
<span class="nocode"><a name="701">701: </a></span>
<span class="nocode"><a name="702">702: </a></span>
<span class="nocode"><a name="703">703: </a></span>    /**
<span class="nocode"><a name="704">704: </a></span>     * Gets a comma-separated list of system functions.  These are the
<span class="nocode"><a name="705">705: </a></span>     * X/Open CLI system function names used in the JDBC function escape
<span class="nocode"><a name="706">706: </a></span>     * clause.
<span class="nocode"><a name="707">707: </a></span>     *
<span class="nocode"><a name="708">708: </a></span>     * @return the list
<span class="nocode"><a name="709">709: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="710">710: </a></span>     */
<span class="nocode"><a name="711">711: </a></span>    public  String getSystemFunctions() throws SQLException {
<span class="nocode"><a name="712">712: </a></span>        return &quot;&quot;;
<span class="nocode"><a name="713">713: </a></span>    }
<span class="nocode"><a name="714">714: </a></span>
<span class="nocode"><a name="715">715: </a></span>
<span class="nocode"><a name="716">716: </a></span>    /**
<span class="nocode"><a name="717">717: </a></span>     * Gets a comma-separated list of time and date functions.
<span class="nocode"><a name="718">718: </a></span>     *
<span class="nocode"><a name="719">719: </a></span>     * @return the list
<span class="nocode"><a name="720">720: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="721">721: </a></span>     */
<span class="nocode"><a name="722">722: </a></span>    public  String getTimeDateFunctions() throws SQLException {
<span class="nocode"><a name="723">723: </a></span>        return &quot;CURDATE,CURTIME,DAYOFYEAR,HOUR,MINUTE,MONTH,NOW,SECOND,YEAR&quot;;
<span class="nocode"><a name="724">724: </a></span>    }
<span class="nocode"><a name="725">725: </a></span>
<span class="nocode"><a name="726">726: </a></span>
<span class="nocode"><a name="727">727: </a></span>    /**
<span class="nocode"><a name="728">728: </a></span>     * Gets the string that can be used to escape wildcard characters.
<span class="nocode"><a name="729">729: </a></span>     * This is the string that can be used to escape '_' or '%' in
<span class="nocode"><a name="730">730: </a></span>     * the string pattern style catalog search parameters.
<span class="nocode"><a name="731">731: </a></span>     *
<span class="nocode"><a name="732">732: </a></span>     * &lt;P&gt;The '_' character represents any single character.
<span class="nocode"><a name="733">733: </a></span>     * &lt;P&gt;The '%' character represents any sequence of zero or
<span class="nocode"><a name="734">734: </a></span>     * more characters.
<span class="nocode"><a name="735">735: </a></span>     *
<span class="nocode"><a name="736">736: </a></span>     * @return the string used to escape wildcard characters
<span class="nocode"><a name="737">737: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="738">738: </a></span>     */
<span class="nocode"><a name="739">739: </a></span>    public  String getSearchStringEscape() throws SQLException {
<span class="nocode"><a name="740">740: </a></span>        return &quot;\\&quot;;
<span class="nocode"><a name="741">741: </a></span>    }
<span class="nocode"><a name="742">742: </a></span>
<span class="nocode"><a name="743">743: </a></span>
<span class="nocode"><a name="744">744: </a></span>    /**
<span class="nocode"><a name="745">745: </a></span>     * Gets all the &quot;extra&quot; characters that can be used in unquoted
<span class="nocode"><a name="746">746: </a></span>     * identifier names (those beyond a-z, A-Z, 0-9 and _).
<span class="nocode"><a name="747">747: </a></span>     *
<span class="nocode"><a name="748">748: </a></span>     * @return the string containing the extra characters
<span class="nocode"><a name="749">749: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="750">750: </a></span>     */
<span class="nocode"><a name="751">751: </a></span>    public  String getExtraNameCharacters() throws SQLException {
<span class="nocode"><a name="752">752: </a></span>        return &quot;$&quot;;
<span class="nocode"><a name="753">753: </a></span>    }
<span class="nocode"><a name="754">754: </a></span>
<span class="nocode"><a name="755">755: </a></span>
<span class="nocode"><a name="756">756: </a></span>    //--------------------------------------------------------------------
<span class="nocode"><a name="757">757: </a></span>    // Functions describing which features are supported.
<span class="nocode"><a name="758">758: </a></span>
<span class="nocode"><a name="759">759: </a></span>    /**
<span class="nocode"><a name="760">760: </a></span>     * Is &quot;ALTER TABLE&quot; with add column supported?
<span class="nocode"><a name="761">761: </a></span>     *
<span class="nocode"><a name="762">762: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="763">763: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="764">764: </a></span>     */
<span class="nocode"><a name="765">765: </a></span>    public  boolean supportsAlterTableWithAddColumn() throws SQLException {
<span class="nocode"><a name="766">766: </a></span>        return true;
<span class="nocode"><a name="767">767: </a></span>    }
<span class="nocode"><a name="768">768: </a></span>
<span class="nocode"><a name="769">769: </a></span>
<span class="nocode"><a name="770">770: </a></span>    /**
<span class="nocode"><a name="771">771: </a></span>     * Is &quot;ALTER TABLE&quot; with drop column supported?
<span class="nocode"><a name="772">772: </a></span>     *
<span class="nocode"><a name="773">773: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="774">774: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="775">775: </a></span>     */
<span class="nocode"><a name="776">776: </a></span>    public  boolean supportsAlterTableWithDropColumn() throws SQLException {
<span class="nocode"><a name="777">777: </a></span>        return true;
<span class="nocode"><a name="778">778: </a></span>    }
<span class="nocode"><a name="779">779: </a></span>
<span class="nocode"><a name="780">780: </a></span>
<span class="nocode"><a name="781">781: </a></span>    /**
<span class="nocode"><a name="782">782: </a></span>     * Is column aliasing supported?
<span class="nocode"><a name="783">783: </a></span>     *
<span class="nocode"><a name="784">784: </a></span>     * &lt;P&gt;If so, the SQL AS clause can be used to provide names for
<span class="nocode"><a name="785">785: </a></span>     * computed columns or to provide alias names for columns as
<span class="nocode"><a name="786">786: </a></span>     * required.
<span class="nocode"><a name="787">787: </a></span>     *
<span class="nocode"><a name="788">788: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="789">789: </a></span>     *
<span class="nocode"><a name="790">790: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="791">791: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="792">792: </a></span>     */
<span class="nocode"><a name="793">793: </a></span>    public  boolean supportsColumnAliasing() throws SQLException {
<span class="nocode"><a name="794">794: </a></span>        return true;
<span class="nocode"><a name="795">795: </a></span>    }
<span class="nocode"><a name="796">796: </a></span>
<span class="nocode"><a name="797">797: </a></span>
<span class="nocode"><a name="798">798: </a></span>    /**
<span class="nocode"><a name="799">799: </a></span>     * Retrieves whether concatenations between NULL and non-NULL values 
<span class="nocode"><a name="800">800: </a></span>     * equal NULL. For SQL-92 compliance, a JDBC technology-enabled driver will
<span class="nocode"><a name="801">801: </a></span>     * return &lt;code&gt;true&lt;/code&gt;.
<span class="nocode"><a name="802">802: </a></span>     *
<span class="nocode"><a name="803">803: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="804">804: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="805">805: </a></span>     */
<span class="nocode"><a name="806">806: </a></span>    public  boolean nullPlusNonNullIsNull() throws SQLException {
<span class="nocode"><a name="807">807: </a></span>        return true;
<span class="nocode"><a name="808">808: </a></span>    }
<span class="nocode"><a name="809">809: </a></span>
<span class="nocode"><a name="810">810: </a></span>
<span class="nocode"><a name="811">811: </a></span>    /**
<span class="nocode"><a name="812">812: </a></span>     * Is the CONVERT function between SQL types supported?
<span class="nocode"><a name="813">813: </a></span>     *
<span class="nocode"><a name="814">814: </a></span>     * What is this??? my sql ref says CONVERT is a string encoding map!
<span class="nocode"><a name="815">815: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="816">816: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="817">817: </a></span>     */
<span class="nocode"><a name="818">818: </a></span>    public  boolean supportsConvert() throws SQLException {
<span class="nocode"><a name="819">819: </a></span>        return false;//don't know
<span class="nocode"><a name="820">820: </a></span>    }
<span class="nocode"><a name="821">821: </a></span>
<span class="nocode"><a name="822">822: </a></span>
<span class="nocode"><a name="823">823: </a></span>    /**
<span class="nocode"><a name="824">824: </a></span>     * Retrieves whether CONVERT between the given SQL types supported.
<span class="nocode"><a name="825">825: </a></span>     *
<span class="nocode"><a name="826">826: </a></span>     * @param fromType the type to convert from
<span class="nocode"><a name="827">827: </a></span>     * @param toType the type to convert to
<span class="nocode"><a name="828">828: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="829">829: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="830">830: </a></span>     * @see Types
<span class="nocode"><a name="831">831: </a></span>     */
<span class="nocode"><a name="832">832: </a></span>    public  boolean supportsConvert(int fromType, int toType) throws SQLException {
<span class="nocode"><a name="833">833: </a></span>        return false;//don't know
<span class="nocode"><a name="834">834: </a></span>    }
<span class="nocode"><a name="835">835: </a></span>
<span class="nocode"><a name="836">836: </a></span>
<span class="nocode"><a name="837">837: </a></span>    /**
<span class="nocode"><a name="838">838: </a></span>     * Are table correlation names supported?
<span class="nocode"><a name="839">839: </a></span>     *
<span class="nocode"><a name="840">840: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="841">841: </a></span>     *
<span class="nocode"><a name="842">842: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="843">843: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="844">844: </a></span>     */
<span class="nocode"><a name="845">845: </a></span>    public  boolean supportsTableCorrelationNames() throws SQLException {
<span class="nocode"><a name="846">846: </a></span>        return true;
<span class="nocode"><a name="847">847: </a></span>    }
<span class="nocode"><a name="848">848: </a></span>
<span class="nocode"><a name="849">849: </a></span>
<span class="nocode"><a name="850">850: </a></span>    /**
<span class="nocode"><a name="851">851: </a></span>     * If table correlation names are supported, are they restricted
<span class="nocode"><a name="852">852: </a></span>     * to be different from the names of the tables?
<span class="nocode"><a name="853">853: </a></span>     *
<span class="nocode"><a name="854">854: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="855">855: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="856">856: </a></span>     */
<span class="nocode"><a name="857">857: </a></span>    public  boolean supportsDifferentTableCorrelationNames() throws SQLException {
<span class="nocode"><a name="858">858: </a></span><span style="background-color: #ffffcc">        return false; //I think</span>
<span class="nocode"><a name="859">859: </a></span>    }
<span class="nocode"><a name="860">860: </a></span>
<span class="nocode"><a name="861">861: </a></span>
<span class="nocode"><a name="862">862: </a></span>    /**
<span class="nocode"><a name="863">863: </a></span>     * Are expressions in &quot;ORDER BY&quot; lists supported?
<span class="nocode"><a name="864">864: </a></span>     *
<span class="nocode"><a name="865">865: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="866">866: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="867">867: </a></span>     */
<span class="nocode"><a name="868">868: </a></span>    public  boolean supportsExpressionsInOrderBy() throws SQLException {
<span class="nocode"><a name="869">869: </a></span>        return false; //coming soon
<span class="nocode"><a name="870">870: </a></span>    }
<span class="nocode"><a name="871">871: </a></span>
<span class="nocode"><a name="872">872: </a></span>
<span class="nocode"><a name="873">873: </a></span>    /**
<span class="nocode"><a name="874">874: </a></span>     * Can an &quot;ORDER BY&quot; clause use columns not in the SELECT statement?
<span class="nocode"><a name="875">875: </a></span>     *
<span class="nocode"><a name="876">876: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="877">877: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="878">878: </a></span>     */
<span class="nocode"><a name="879">879: </a></span>    public  boolean supportsOrderByUnrelated() throws SQLException {
<span class="nocode"><a name="880">880: </a></span>        return true;
<span class="nocode"><a name="881">881: </a></span>    }
<span class="nocode"><a name="882">882: </a></span>
<span class="nocode"><a name="883">883: </a></span>
<span class="nocode"><a name="884">884: </a></span>    /**
<span class="nocode"><a name="885">885: </a></span>     * Is some form of &quot;GROUP BY&quot; clause supported?
<span class="nocode"><a name="886">886: </a></span>     *
<span class="nocode"><a name="887">887: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="888">888: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="889">889: </a></span>     */
<span class="nocode"><a name="890">890: </a></span>    public  boolean supportsGroupBy() throws SQLException {
<span class="nocode"><a name="891">891: </a></span>        return true;
<span class="nocode"><a name="892">892: </a></span>    }
<span class="nocode"><a name="893">893: </a></span>
<span class="nocode"><a name="894">894: </a></span>
<span class="nocode"><a name="895">895: </a></span>    /**
<span class="nocode"><a name="896">896: </a></span>     * Can a &quot;GROUP BY&quot; clause use columns not in the SELECT?
<span class="nocode"><a name="897">897: </a></span>     *
<span class="nocode"><a name="898">898: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="899">899: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="900">900: </a></span>     */
<span class="nocode"><a name="901">901: </a></span>    public  boolean supportsGroupByUnrelated() throws SQLException {
<span class="nocode"><a name="902">902: </a></span>        return false;
<span class="nocode"><a name="903">903: </a></span>    }
<span class="nocode"><a name="904">904: </a></span>
<span class="nocode"><a name="905">905: </a></span>
<span class="nocode"><a name="906">906: </a></span>    /**
<span class="nocode"><a name="907">907: </a></span>     * Can a &quot;GROUP BY&quot; clause add columns not in the SELECT
<span class="nocode"><a name="908">908: </a></span>     * provided it specifies all the columns in the SELECT?
<span class="nocode"><a name="909">909: </a></span>     *
<span class="nocode"><a name="910">910: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="911">911: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="912">912: </a></span>     */
<span class="nocode"><a name="913">913: </a></span>    public  boolean supportsGroupByBeyondSelect() throws SQLException {
<span class="nocode"><a name="914">914: </a></span>        return false;
<span class="nocode"><a name="915">915: </a></span>    }
<span class="nocode"><a name="916">916: </a></span>
<span class="nocode"><a name="917">917: </a></span>
<span class="nocode"><a name="918">918: </a></span>    /**
<span class="nocode"><a name="919">919: </a></span>     * Is the escape character in &quot;LIKE&quot; clauses supported?
<span class="nocode"><a name="920">920: </a></span>     *
<span class="nocode"><a name="921">921: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="922">922: </a></span>     *
<span class="nocode"><a name="923">923: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="924">924: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="925">925: </a></span>     */
<span class="nocode"><a name="926">926: </a></span>    public  boolean supportsLikeEscapeClause() throws SQLException {
<span class="nocode"><a name="927">927: </a></span>        return true;
<span class="nocode"><a name="928">928: </a></span>    }
<span class="nocode"><a name="929">929: </a></span>
<span class="nocode"><a name="930">930: </a></span>
<span class="nocode"><a name="931">931: </a></span>    /**
<span class="nocode"><a name="932">932: </a></span>     * Are multiple &lt;code&gt;ResultSet&lt;/code&gt; from a single execute supported?
<span class="nocode"><a name="933">933: </a></span>     *
<span class="nocode"><a name="934">934: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="935">935: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="936">936: </a></span>     */
<span class="nocode"><a name="937">937: </a></span>    public  boolean supportsMultipleResultSets() throws SQLException {
<span class="nocode"><a name="938">938: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="939">939: </a></span>    }
<span class="nocode"><a name="940">940: </a></span>
<span class="nocode"><a name="941">941: </a></span>
<span class="nocode"><a name="942">942: </a></span>    /**
<span class="nocode"><a name="943">943: </a></span>     * Can we have multiple transactions open at once (on different
<span class="nocode"><a name="944">944: </a></span>     * connections)?
<span class="nocode"><a name="945">945: </a></span>     *
<span class="nocode"><a name="946">946: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="947">947: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="948">948: </a></span>     */
<span class="nocode"><a name="949">949: </a></span>    public  boolean supportsMultipleTransactions() throws SQLException {
<span class="nocode"><a name="950">950: </a></span><span style="background-color: #ffffcc">        return true;</span>
<span class="nocode"><a name="951">951: </a></span>    }
<span class="nocode"><a name="952">952: </a></span>
<span class="nocode"><a name="953">953: </a></span>
<span class="nocode"><a name="954">954: </a></span>    /**
<span class="nocode"><a name="955">955: </a></span>     * Can columns be defined as non-nullable?
<span class="nocode"><a name="956">956: </a></span>     *
<span class="nocode"><a name="957">957: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="958">958: </a></span>     *
<span class="nocode"><a name="959">959: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="960">960: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="961">961: </a></span>     */
<span class="nocode"><a name="962">962: </a></span>    public  boolean supportsNonNullableColumns() throws SQLException {
<span class="nocode"><a name="963">963: </a></span>        return true;
<span class="nocode"><a name="964">964: </a></span>    }
<span class="nocode"><a name="965">965: </a></span>
<span class="nocode"><a name="966">966: </a></span>
<span class="nocode"><a name="967">967: </a></span>    /**
<span class="nocode"><a name="968">968: </a></span>     * Is the ODBC Minimum SQL grammar supported?
<span class="nocode"><a name="969">969: </a></span>     *
<span class="nocode"><a name="970">970: </a></span>     * All JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; drivers must return true.
<span class="nocode"><a name="971">971: </a></span>     *
<span class="nocode"><a name="972">972: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="973">973: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="974">974: </a></span>     */
<span class="nocode"><a name="975">975: </a></span>    public  boolean supportsMinimumSQLGrammar() throws SQLException {
<span class="nocode"><a name="976">976: </a></span>        return true; //lets see what the tests say
<span class="nocode"><a name="977">977: </a></span>    }
<span class="nocode"><a name="978">978: </a></span>
<span class="nocode"><a name="979">979: </a></span>
<span class="nocode"><a name="980">980: </a></span>    /**
<span class="nocode"><a name="981">981: </a></span>     * Is the ODBC Core SQL grammar supported?
<span class="nocode"><a name="982">982: </a></span>     *
<span class="nocode"><a name="983">983: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="984">984: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="985">985: </a></span>     */
<span class="nocode"><a name="986">986: </a></span>    public  boolean supportsCoreSQLGrammar() throws SQLException {
<span class="nocode"><a name="987">987: </a></span>        return true; //lets see what the tests say
<span class="nocode"><a name="988">988: </a></span>    }
<span class="nocode"><a name="989">989: </a></span>
<span class="nocode"><a name="990">990: </a></span>
<span class="nocode"><a name="991">991: </a></span>    /**
<span class="nocode"><a name="992">992: </a></span>     * Is the ODBC Extended SQL grammar supported?
<span class="nocode"><a name="993">993: </a></span>     *
<span class="nocode"><a name="994">994: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="995">995: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="996">996: </a></span>     */
<span class="nocode"><a name="997">997: </a></span>    public  boolean supportsExtendedSQLGrammar() throws SQLException {
<span class="nocode"><a name="998">998: </a></span>        return true; //lets see what the tests say
<span class="nocode"><a name="999">999: </a></span>    }
<span class="nocode"><a name="1000">1000: </a></span>
<span class="nocode"><a name="1001">1001: </a></span>
<span class="nocode"><a name="1002">1002: </a></span>    /**
<span class="nocode"><a name="1003">1003: </a></span>     * Is the ANSI92 entry level SQL grammar supported?
<span class="nocode"><a name="1004">1004: </a></span>     *
<span class="nocode"><a name="1005">1005: </a></span>     * All JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; drivers must return true.
<span class="nocode"><a name="1006">1006: </a></span>     *
<span class="nocode"><a name="1007">1007: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1008">1008: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1009">1009: </a></span>     */
<span class="nocode"><a name="1010">1010: </a></span>    public  boolean supportsANSI92EntryLevelSQL() throws SQLException {
<span class="nocode"><a name="1011">1011: </a></span>        return true; //lets see what the tests say
<span class="nocode"><a name="1012">1012: </a></span>    }
<span class="nocode"><a name="1013">1013: </a></span>
<span class="nocode"><a name="1014">1014: </a></span>
<span class="nocode"><a name="1015">1015: </a></span>    /**
<span class="nocode"><a name="1016">1016: </a></span>     * Is the ANSI92 intermediate SQL grammar supported?
<span class="nocode"><a name="1017">1017: </a></span>     *
<span class="nocode"><a name="1018">1018: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1019">1019: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1020">1020: </a></span>     */
<span class="nocode"><a name="1021">1021: </a></span>    public  boolean supportsANSI92IntermediateSQL() throws SQLException {
<span class="nocode"><a name="1022">1022: </a></span>        return false; //lets see what the tests say
<span class="nocode"><a name="1023">1023: </a></span>    }
<span class="nocode"><a name="1024">1024: </a></span>
<span class="nocode"><a name="1025">1025: </a></span>
<span class="nocode"><a name="1026">1026: </a></span>    /**
<span class="nocode"><a name="1027">1027: </a></span>     * Is the ANSI92 full SQL grammar supported?
<span class="nocode"><a name="1028">1028: </a></span>     *
<span class="nocode"><a name="1029">1029: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1030">1030: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1031">1031: </a></span>     */
<span class="nocode"><a name="1032">1032: </a></span>    public  boolean supportsANSI92FullSQL() throws SQLException {
<span class="nocode"><a name="1033">1033: </a></span>        return false; //Nah, but lets see what the tests say
<span class="nocode"><a name="1034">1034: </a></span>    }
<span class="nocode"><a name="1035">1035: </a></span>
<span class="nocode"><a name="1036">1036: </a></span>
<span class="nocode"><a name="1037">1037: </a></span>    /**
<span class="nocode"><a name="1038">1038: </a></span>     * Is the SQL Integrity Enhancement Facility supported?
<span class="nocode"><a name="1039">1039: </a></span>     *
<span class="nocode"><a name="1040">1040: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1041">1041: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1042">1042: </a></span>     */
<span class="nocode"><a name="1043">1043: </a></span>    public  boolean supportsIntegrityEnhancementFacility() throws SQLException {
<span class="nocode"><a name="1044">1044: </a></span>        return true; // rrokytskyy: yep, they call so foreign keys + cascade deletes
<span class="nocode"><a name="1045">1045: </a></span>    }
<span class="nocode"><a name="1046">1046: </a></span>
<span class="nocode"><a name="1047">1047: </a></span>    /**
<span class="nocode"><a name="1048">1048: </a></span>     * Is some form of outer join supported?
<span class="nocode"><a name="1049">1049: </a></span>     *
<span class="nocode"><a name="1050">1050: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1051">1051: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1052">1052: </a></span>     */
<span class="nocode"><a name="1053">1053: </a></span>    public  boolean supportsOuterJoins() throws SQLException {
<span class="nocode"><a name="1054">1054: </a></span>        return true;
<span class="nocode"><a name="1055">1055: </a></span>    }
<span class="nocode"><a name="1056">1056: </a></span>
<span class="nocode"><a name="1057">1057: </a></span>    /**
<span class="nocode"><a name="1058">1058: </a></span>     * Are full nested outer joins supported?
<span class="nocode"><a name="1059">1059: </a></span>     *
<span class="nocode"><a name="1060">1060: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1061">1061: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1062">1062: </a></span>     */
<span class="nocode"><a name="1063">1063: </a></span>    public  boolean supportsFullOuterJoins() throws SQLException {
<span class="nocode"><a name="1064">1064: </a></span>        return true;
<span class="nocode"><a name="1065">1065: </a></span>    }
<span class="nocode"><a name="1066">1066: </a></span>
<span class="nocode"><a name="1067">1067: </a></span>    /**
<span class="nocode"><a name="1068">1068: </a></span>     * Is there limited support for outer joins?  (This will be true
<span class="nocode"><a name="1069">1069: </a></span>     * if supportFullOuterJoins is true.)
<span class="nocode"><a name="1070">1070: </a></span>     *
<span class="nocode"><a name="1071">1071: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1072">1072: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1073">1073: </a></span>     */
<span class="nocode"><a name="1074">1074: </a></span>    public  boolean supportsLimitedOuterJoins() throws SQLException {
<span class="nocode"><a name="1075">1075: </a></span>        return true;
<span class="nocode"><a name="1076">1076: </a></span>    }
<span class="nocode"><a name="1077">1077: </a></span>
<span class="nocode"><a name="1078">1078: </a></span>    /**
<span class="nocode"><a name="1079">1079: </a></span>     * What's the database vendor's preferred term for &quot;schema&quot;?
<span class="nocode"><a name="1080">1080: </a></span>     *
<span class="nocode"><a name="1081">1081: </a></span>     * @return the vendor term, always &lt;code&gt;null&lt;/code&gt; because
<span class="nocode"><a name="1082">1082: </a></span>     * schemas are not supported by database server (see JDBC CTS
<span class="nocode"><a name="1083">1083: </a></span>     * for details).
<span class="nocode"><a name="1084">1084: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1085">1085: </a></span>     */
<span class="nocode"><a name="1086">1086: </a></span>    public  String getSchemaTerm() throws  SQLException {
<span class="nocode"><a name="1087">1087: </a></span>        return null;
<span class="nocode"><a name="1088">1088: </a></span>    }
<span class="nocode"><a name="1089">1089: </a></span>
<span class="nocode"><a name="1090">1090: </a></span>
<span class="nocode"><a name="1091">1091: </a></span>    /**
<span class="nocode"><a name="1092">1092: </a></span>     * What's the database vendor's preferred term for &quot;procedure&quot;?
<span class="nocode"><a name="1093">1093: </a></span>     *
<span class="nocode"><a name="1094">1094: </a></span>     * @return the vendor term
<span class="nocode"><a name="1095">1095: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1096">1096: </a></span>     */
<span class="nocode"><a name="1097">1097: </a></span>    public  String getProcedureTerm() throws SQLException {
<span class="nocode"><a name="1098">1098: </a></span>        return &quot;PROCEDURE&quot;;
<span class="nocode"><a name="1099">1099: </a></span>    }
<span class="nocode"><a name="1100">1100: </a></span>
<span class="nocode"><a name="1101">1101: </a></span>
<span class="nocode"><a name="1102">1102: </a></span>    /**
<span class="nocode"><a name="1103">1103: </a></span>     * What's the database vendor's preferred term for &quot;catalog&quot;?
<span class="nocode"><a name="1104">1104: </a></span>     *
<span class="nocode"><a name="1105">1105: </a></span>     * @return the vendor term, always &lt;code&gt;null&lt;/code&gt; because
<span class="nocode"><a name="1106">1106: </a></span>     * catalogs are not supported by database server (see JDBC CTS
<span class="nocode"><a name="1107">1107: </a></span>     * for details).
<span class="nocode"><a name="1108">1108: </a></span>     *
<span class="nocode"><a name="1109">1109: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1110">1110: </a></span>     */
<span class="nocode"><a name="1111">1111: </a></span>    public  String getCatalogTerm() throws  SQLException {
<span class="nocode"><a name="1112">1112: </a></span>        return null;
<span class="nocode"><a name="1113">1113: </a></span>    }
<span class="nocode"><a name="1114">1114: </a></span>
<span class="nocode"><a name="1115">1115: </a></span>
<span class="nocode"><a name="1116">1116: </a></span>    /**
<span class="nocode"><a name="1117">1117: </a></span>     * Does a catalog appear at the start of a qualified table name?
<span class="nocode"><a name="1118">1118: </a></span>     * (Otherwise it appears at the end)
<span class="nocode"><a name="1119">1119: </a></span>     *
<span class="nocode"><a name="1120">1120: </a></span>     * @return true if it appears at the start
<span class="nocode"><a name="1121">1121: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1122">1122: </a></span>     */
<span class="nocode"><a name="1123">1123: </a></span>    public  boolean isCatalogAtStart() throws SQLException {
<span class="nocode"><a name="1124">1124: </a></span>        return false;
<span class="nocode"><a name="1125">1125: </a></span>    }
<span class="nocode"><a name="1126">1126: </a></span>
<span class="nocode"><a name="1127">1127: </a></span>
<span class="nocode"><a name="1128">1128: </a></span>    /**
<span class="nocode"><a name="1129">1129: </a></span>     * What's the separator between catalog and table name?
<span class="nocode"><a name="1130">1130: </a></span>     *
<span class="nocode"><a name="1131">1131: </a></span>     * @return the separator string, always &lt;code&gt;null&lt;/code&gt; because
<span class="nocode"><a name="1132">1132: </a></span>     * catalogs are not supported by database server (see JDBC CTS
<span class="nocode"><a name="1133">1133: </a></span>     * for details).
<span class="nocode"><a name="1134">1134: </a></span>
<span class="nocode"><a name="1135">1135: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1136">1136: </a></span>     */
<span class="nocode"><a name="1137">1137: </a></span>    public  String getCatalogSeparator() throws SQLException {
<span class="nocode"><a name="1138">1138: </a></span>        return null;
<span class="nocode"><a name="1139">1139: </a></span>    }
<span class="nocode"><a name="1140">1140: </a></span>
<span class="nocode"><a name="1141">1141: </a></span>
<span class="nocode"><a name="1142">1142: </a></span>    /**
<span class="nocode"><a name="1143">1143: </a></span>     * Can a schema name be used in a data manipulation statement?
<span class="nocode"><a name="1144">1144: </a></span>     *
<span class="nocode"><a name="1145">1145: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1146">1146: </a></span>     *
<span class="nocode"><a name="1147">1147: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1148">1148: </a></span>     */
<span class="nocode"><a name="1149">1149: </a></span>    public  boolean supportsSchemasInDataManipulation() throws SQLException {
<span class="nocode"><a name="1150">1150: </a></span>        return false;
<span class="nocode"><a name="1151">1151: </a></span>    }
<span class="nocode"><a name="1152">1152: </a></span>
<span class="nocode"><a name="1153">1153: </a></span>
<span class="nocode"><a name="1154">1154: </a></span>    /**
<span class="nocode"><a name="1155">1155: </a></span>     * Can a schema name be used in a procedure call statement?
<span class="nocode"><a name="1156">1156: </a></span>     *
<span class="nocode"><a name="1157">1157: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1158">1158: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1159">1159: </a></span>     */
<span class="nocode"><a name="1160">1160: </a></span>    public  boolean supportsSchemasInProcedureCalls() throws SQLException {
<span class="nocode"><a name="1161">1161: </a></span>        return false;
<span class="nocode"><a name="1162">1162: </a></span>    }
<span class="nocode"><a name="1163">1163: </a></span>
<span class="nocode"><a name="1164">1164: </a></span>
<span class="nocode"><a name="1165">1165: </a></span>    /**
<span class="nocode"><a name="1166">1166: </a></span>     * Can a schema name be used in a table definition statement?
<span class="nocode"><a name="1167">1167: </a></span>     *
<span class="nocode"><a name="1168">1168: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1169">1169: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1170">1170: </a></span>     */
<span class="nocode"><a name="1171">1171: </a></span>    public  boolean supportsSchemasInTableDefinitions() throws SQLException {
<span class="nocode"><a name="1172">1172: </a></span>        return false;
<span class="nocode"><a name="1173">1173: </a></span>    }
<span class="nocode"><a name="1174">1174: </a></span>
<span class="nocode"><a name="1175">1175: </a></span>
<span class="nocode"><a name="1176">1176: </a></span>    /**
<span class="nocode"><a name="1177">1177: </a></span>     * Can a schema name be used in an index definition statement?
<span class="nocode"><a name="1178">1178: </a></span>     *
<span class="nocode"><a name="1179">1179: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1180">1180: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1181">1181: </a></span>     */
<span class="nocode"><a name="1182">1182: </a></span>    public  boolean supportsSchemasInIndexDefinitions() throws SQLException {
<span class="nocode"><a name="1183">1183: </a></span>        return false;
<span class="nocode"><a name="1184">1184: </a></span>    }
<span class="nocode"><a name="1185">1185: </a></span>
<span class="nocode"><a name="1186">1186: </a></span>
<span class="nocode"><a name="1187">1187: </a></span>    /**
<span class="nocode"><a name="1188">1188: </a></span>     * Can a schema name be used in a privilege definition statement?
<span class="nocode"><a name="1189">1189: </a></span>     *
<span class="nocode"><a name="1190">1190: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1191">1191: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1192">1192: </a></span>     */
<span class="nocode"><a name="1193">1193: </a></span>    public  boolean supportsSchemasInPrivilegeDefinitions() throws SQLException {
<span class="nocode"><a name="1194">1194: </a></span>        return false;
<span class="nocode"><a name="1195">1195: </a></span>    }
<span class="nocode"><a name="1196">1196: </a></span>
<span class="nocode"><a name="1197">1197: </a></span>
<span class="nocode"><a name="1198">1198: </a></span>    /**
<span class="nocode"><a name="1199">1199: </a></span>     * Can a catalog name be used in a data manipulation statement?
<span class="nocode"><a name="1200">1200: </a></span>     *
<span class="nocode"><a name="1201">1201: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1202">1202: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1203">1203: </a></span>     */
<span class="nocode"><a name="1204">1204: </a></span>    public  boolean supportsCatalogsInDataManipulation() throws SQLException {
<span class="nocode"><a name="1205">1205: </a></span>        return false;
<span class="nocode"><a name="1206">1206: </a></span>    }
<span class="nocode"><a name="1207">1207: </a></span>
<span class="nocode"><a name="1208">1208: </a></span>
<span class="nocode"><a name="1209">1209: </a></span>    /**
<span class="nocode"><a name="1210">1210: </a></span>     * Can a catalog name be used in a procedure call statement?
<span class="nocode"><a name="1211">1211: </a></span>     *
<span class="nocode"><a name="1212">1212: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1213">1213: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1214">1214: </a></span>     */
<span class="nocode"><a name="1215">1215: </a></span>    public  boolean supportsCatalogsInProcedureCalls() throws SQLException {
<span class="nocode"><a name="1216">1216: </a></span>        return false;
<span class="nocode"><a name="1217">1217: </a></span>    }
<span class="nocode"><a name="1218">1218: </a></span>
<span class="nocode"><a name="1219">1219: </a></span>
<span class="nocode"><a name="1220">1220: </a></span>    /**
<span class="nocode"><a name="1221">1221: </a></span>     * Can a catalog name be used in a table definition statement?
<span class="nocode"><a name="1222">1222: </a></span>     *
<span class="nocode"><a name="1223">1223: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1224">1224: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1225">1225: </a></span>     */
<span class="nocode"><a name="1226">1226: </a></span>    public  boolean supportsCatalogsInTableDefinitions() throws SQLException {
<span class="nocode"><a name="1227">1227: </a></span>        return false;
<span class="nocode"><a name="1228">1228: </a></span>    }
<span class="nocode"><a name="1229">1229: </a></span>
<span class="nocode"><a name="1230">1230: </a></span>
<span class="nocode"><a name="1231">1231: </a></span>    /**
<span class="nocode"><a name="1232">1232: </a></span>     * Can a catalog name be used in an index definition statement?
<span class="nocode"><a name="1233">1233: </a></span>     *
<span class="nocode"><a name="1234">1234: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1235">1235: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1236">1236: </a></span>     */
<span class="nocode"><a name="1237">1237: </a></span>    public  boolean supportsCatalogsInIndexDefinitions() throws SQLException {
<span class="nocode"><a name="1238">1238: </a></span>        return false;
<span class="nocode"><a name="1239">1239: </a></span>    }
<span class="nocode"><a name="1240">1240: </a></span>
<span class="nocode"><a name="1241">1241: </a></span>
<span class="nocode"><a name="1242">1242: </a></span>    /**
<span class="nocode"><a name="1243">1243: </a></span>     * Can a catalog name be used in a privilege definition statement?
<span class="nocode"><a name="1244">1244: </a></span>     *
<span class="nocode"><a name="1245">1245: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1246">1246: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1247">1247: </a></span>     */
<span class="nocode"><a name="1248">1248: </a></span>    public  boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException {
<span class="nocode"><a name="1249">1249: </a></span>        return false;
<span class="nocode"><a name="1250">1250: </a></span>    }
<span class="nocode"><a name="1251">1251: </a></span>
<span class="nocode"><a name="1252">1252: </a></span>
<span class="nocode"><a name="1253">1253: </a></span>
<span class="nocode"><a name="1254">1254: </a></span>    /**
<span class="nocode"><a name="1255">1255: </a></span>     * Is positioned DELETE supported?
<span class="nocode"><a name="1256">1256: </a></span>     *
<span class="nocode"><a name="1257">1257: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1258">1258: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1259">1259: </a></span>     */
<span class="nocode"><a name="1260">1260: </a></span>    public  boolean supportsPositionedDelete() throws SQLException {
<span class="nocode"><a name="1261">1261: </a></span>        return true;
<span class="nocode"><a name="1262">1262: </a></span>    }
<span class="nocode"><a name="1263">1263: </a></span>
<span class="nocode"><a name="1264">1264: </a></span>
<span class="nocode"><a name="1265">1265: </a></span>    /**
<span class="nocode"><a name="1266">1266: </a></span>     * Is positioned UPDATE supported?
<span class="nocode"><a name="1267">1267: </a></span>     *
<span class="nocode"><a name="1268">1268: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1269">1269: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1270">1270: </a></span>     */
<span class="nocode"><a name="1271">1271: </a></span>    public  boolean supportsPositionedUpdate() throws SQLException {
<span class="nocode"><a name="1272">1272: </a></span>        return true;
<span class="nocode"><a name="1273">1273: </a></span>    }
<span class="nocode"><a name="1274">1274: </a></span>
<span class="nocode"><a name="1275">1275: </a></span>
<span class="nocode"><a name="1276">1276: </a></span>    /**
<span class="nocode"><a name="1277">1277: </a></span>     * Is SELECT for UPDATE supported?
<span class="nocode"><a name="1278">1278: </a></span>     *
<span class="nocode"><a name="1279">1279: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1280">1280: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1281">1281: </a></span>     */
<span class="nocode"><a name="1282">1282: </a></span>    public  boolean supportsSelectForUpdate() throws SQLException {
<span class="nocode"><a name="1283">1283: </a></span>        return true;
<span class="nocode"><a name="1284">1284: </a></span>    }
<span class="nocode"><a name="1285">1285: </a></span>
<span class="nocode"><a name="1286">1286: </a></span>
<span class="nocode"><a name="1287">1287: </a></span>    /**
<span class="nocode"><a name="1288">1288: </a></span>     * Are stored procedure calls using the stored procedure escape
<span class="nocode"><a name="1289">1289: </a></span>     * syntax supported?
<span class="nocode"><a name="1290">1290: </a></span>     *
<span class="nocode"><a name="1291">1291: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1292">1292: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1293">1293: </a></span>     */
<span class="nocode"><a name="1294">1294: </a></span>    public  boolean supportsStoredProcedures() throws SQLException {
<span class="nocode"><a name="1295">1295: </a></span>        return true;
<span class="nocode"><a name="1296">1296: </a></span>    }
<span class="nocode"><a name="1297">1297: </a></span>
<span class="nocode"><a name="1298">1298: </a></span>    /**
<span class="nocode"><a name="1299">1299: </a></span>     * Are subqueries in comparison expressions supported?
<span class="nocode"><a name="1300">1300: </a></span>     *
<span class="nocode"><a name="1301">1301: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="1302">1302: </a></span>     *
<span class="nocode"><a name="1303">1303: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1304">1304: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1305">1305: </a></span>     */
<span class="nocode"><a name="1306">1306: </a></span>    public  boolean supportsSubqueriesInComparisons() throws SQLException {
<span class="nocode"><a name="1307">1307: </a></span>        return true;
<span class="nocode"><a name="1308">1308: </a></span>    }
<span class="nocode"><a name="1309">1309: </a></span>
<span class="nocode"><a name="1310">1310: </a></span>
<span class="nocode"><a name="1311">1311: </a></span>    /**
<span class="nocode"><a name="1312">1312: </a></span>     * Are subqueries in 'exists' expressions supported?
<span class="nocode"><a name="1313">1313: </a></span>     *
<span class="nocode"><a name="1314">1314: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="1315">1315: </a></span>     *
<span class="nocode"><a name="1316">1316: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1317">1317: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1318">1318: </a></span>     */
<span class="nocode"><a name="1319">1319: </a></span>    public  boolean supportsSubqueriesInExists() throws SQLException {
<span class="nocode"><a name="1320">1320: </a></span>        return true;
<span class="nocode"><a name="1321">1321: </a></span>    }
<span class="nocode"><a name="1322">1322: </a></span>
<span class="nocode"><a name="1323">1323: </a></span>
<span class="nocode"><a name="1324">1324: </a></span>    /**
<span class="nocode"><a name="1325">1325: </a></span>     * Are subqueries in 'in' statements supported?
<span class="nocode"><a name="1326">1326: </a></span>     *
<span class="nocode"><a name="1327">1327: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="1328">1328: </a></span>     *
<span class="nocode"><a name="1329">1329: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1330">1330: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1331">1331: </a></span>     */
<span class="nocode"><a name="1332">1332: </a></span>    public  boolean supportsSubqueriesInIns() throws SQLException {
<span class="nocode"><a name="1333">1333: </a></span>        return true;
<span class="nocode"><a name="1334">1334: </a></span>    }
<span class="nocode"><a name="1335">1335: </a></span>
<span class="nocode"><a name="1336">1336: </a></span>
<span class="nocode"><a name="1337">1337: </a></span>    /**
<span class="nocode"><a name="1338">1338: </a></span>     * Are subqueries in quantified expressions supported?
<span class="nocode"><a name="1339">1339: </a></span>     *
<span class="nocode"><a name="1340">1340: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="1341">1341: </a></span>     *
<span class="nocode"><a name="1342">1342: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1343">1343: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1344">1344: </a></span>     */
<span class="nocode"><a name="1345">1345: </a></span>    public  boolean supportsSubqueriesInQuantifieds() throws SQLException {
<span class="nocode"><a name="1346">1346: </a></span><span style="background-color: #ffffcc">        return true;</span>
<span class="nocode"><a name="1347">1347: </a></span>    }
<span class="nocode"><a name="1348">1348: </a></span>
<span class="nocode"><a name="1349">1349: </a></span>
<span class="nocode"><a name="1350">1350: </a></span>    /**
<span class="nocode"><a name="1351">1351: </a></span>     * Are correlated subqueries supported?
<span class="nocode"><a name="1352">1352: </a></span>     *
<span class="nocode"><a name="1353">1353: </a></span>     * A JDBC Compliant&lt;sup&gt;&lt;font size=-2&gt;TM&lt;/font&gt;&lt;/sup&gt; driver always returns true.
<span class="nocode"><a name="1354">1354: </a></span>     *
<span class="nocode"><a name="1355">1355: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1356">1356: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1357">1357: </a></span>     */
<span class="nocode"><a name="1358">1358: </a></span>    public  boolean supportsCorrelatedSubqueries() throws SQLException {
<span class="nocode"><a name="1359">1359: </a></span>        return true;
<span class="nocode"><a name="1360">1360: </a></span>    }
<span class="nocode"><a name="1361">1361: </a></span>
<span class="nocode"><a name="1362">1362: </a></span>
<span class="nocode"><a name="1363">1363: </a></span>    /**
<span class="nocode"><a name="1364">1364: </a></span>     * Is SQL UNION supported?
<span class="nocode"><a name="1365">1365: </a></span>     *
<span class="nocode"><a name="1366">1366: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1367">1367: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1368">1368: </a></span>     */
<span class="nocode"><a name="1369">1369: </a></span>    public  boolean supportsUnion() throws SQLException {
<span class="nocode"><a name="1370">1370: </a></span>        return true;
<span class="nocode"><a name="1371">1371: </a></span>    }
<span class="nocode"><a name="1372">1372: </a></span>
<span class="nocode"><a name="1373">1373: </a></span>
<span class="nocode"><a name="1374">1374: </a></span>    /**
<span class="nocode"><a name="1375">1375: </a></span>     * Is SQL UNION ALL supported?
<span class="nocode"><a name="1376">1376: </a></span>     *
<span class="nocode"><a name="1377">1377: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1378">1378: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1379">1379: </a></span>     */
<span class="nocode"><a name="1380">1380: </a></span>    public  boolean supportsUnionAll() throws SQLException {
<span class="nocode"><a name="1381">1381: </a></span>        return true;
<span class="nocode"><a name="1382">1382: </a></span>    }
<span class="nocode"><a name="1383">1383: </a></span>
<span class="nocode"><a name="1384">1384: </a></span>
<span class="nocode"><a name="1385">1385: </a></span>    /**
<span class="nocode"><a name="1386">1386: </a></span>     * Can cursors remain open across commits?
<span class="nocode"><a name="1387">1387: </a></span>     *
<span class="nocode"><a name="1388">1388: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if cursors always remain open;
<span class="nocode"><a name="1389">1389: </a></span>     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
<span class="nocode"><a name="1390">1390: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1391">1391: </a></span>     */
<span class="nocode"><a name="1392">1392: </a></span>    public  boolean supportsOpenCursorsAcrossCommit() throws SQLException {
<span class="nocode"><a name="1393">1393: </a></span><span style="background-color: #ffffcc">        return false;//only when commit retaining is executed I think</span>
<span class="nocode"><a name="1394">1394: </a></span>    }
<span class="nocode"><a name="1395">1395: </a></span>
<span class="nocode"><a name="1396">1396: </a></span>
<span class="nocode"><a name="1397">1397: </a></span>    /**
<span class="nocode"><a name="1398">1398: </a></span>     * Can cursors remain open across rollbacks?
<span class="nocode"><a name="1399">1399: </a></span>     *
<span class="nocode"><a name="1400">1400: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if cursors always remain open;
<span class="nocode"><a name="1401">1401: </a></span>     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
<span class="nocode"><a name="1402">1402: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1403">1403: </a></span>     */
<span class="nocode"><a name="1404">1404: </a></span>    public  boolean supportsOpenCursorsAcrossRollback() throws SQLException {
<span class="nocode"><a name="1405">1405: </a></span>        return false;//commit retaining only.
<span class="nocode"><a name="1406">1406: </a></span>    }
<span class="nocode"><a name="1407">1407: </a></span>
<span class="nocode"><a name="1408">1408: </a></span>
<span class="nocode"><a name="1409">1409: </a></span>    /**
<span class="nocode"><a name="1410">1410: </a></span>     * Can statements remain open across commits?
<span class="nocode"><a name="1411">1411: </a></span>     *
<span class="nocode"><a name="1412">1412: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if statements always remain open;
<span class="nocode"><a name="1413">1413: </a></span>     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
<span class="nocode"><a name="1414">1414: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1415">1415: </a></span>     */
<span class="nocode"><a name="1416">1416: </a></span>    public  boolean supportsOpenStatementsAcrossCommit() throws SQLException {
<span class="nocode"><a name="1417">1417: </a></span>        return true;//commit retaining only.
<span class="nocode"><a name="1418">1418: </a></span>    }
<span class="nocode"><a name="1419">1419: </a></span>
<span class="nocode"><a name="1420">1420: </a></span>
<span class="nocode"><a name="1421">1421: </a></span>    /**
<span class="nocode"><a name="1422">1422: </a></span>     * Can statements remain open across rollbacks?
<span class="nocode"><a name="1423">1423: </a></span>     *
<span class="nocode"><a name="1424">1424: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if statements always remain open;
<span class="nocode"><a name="1425">1425: </a></span>     *       &lt;code&gt;false&lt;/code&gt; if they might not remain open
<span class="nocode"><a name="1426">1426: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1427">1427: </a></span>     */
<span class="nocode"><a name="1428">1428: </a></span>    public  boolean supportsOpenStatementsAcrossRollback() throws SQLException {
<span class="nocode"><a name="1429">1429: </a></span>        return true;//commit retaining only.
<span class="nocode"><a name="1430">1430: </a></span>    }
<span class="nocode"><a name="1431">1431: </a></span>
<span class="nocode"><a name="1432">1432: </a></span>    //----------------------------------------------------------------------
<span class="nocode"><a name="1433">1433: </a></span>    // The following group of methods exposes various limitations
<span class="nocode"><a name="1434">1434: </a></span>    // based on the target database with the current driver.
<span class="nocode"><a name="1435">1435: </a></span>    // Unless otherwise specified, a result of zero means there is no
<span class="nocode"><a name="1436">1436: </a></span>    // limit, or the limit is not known.
<span class="nocode"><a name="1437">1437: </a></span>
<span class="nocode"><a name="1438">1438: </a></span>    /**
<span class="nocode"><a name="1439">1439: </a></span>     * How many hex characters can you have in an inline binary literal?
<span class="nocode"><a name="1440">1440: </a></span>     *
<span class="nocode"><a name="1441">1441: </a></span>     * @return max binary literal length in hex characters;
<span class="nocode"><a name="1442">1442: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1443">1443: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1444">1444: </a></span>     */
<span class="nocode"><a name="1445">1445: </a></span>    public  int getMaxBinaryLiteralLength() throws SQLException {
<span class="nocode"><a name="1446">1446: </a></span>        return 0;//anyone know for sure?
<span class="nocode"><a name="1447">1447: </a></span>    }
<span class="nocode"><a name="1448">1448: </a></span>
<span class="nocode"><a name="1449">1449: </a></span>    /**
<span class="nocode"><a name="1450">1450: </a></span>     * What's the max length for a character literal?
<span class="nocode"><a name="1451">1451: </a></span>     *
<span class="nocode"><a name="1452">1452: </a></span>     * @return max literal length;
<span class="nocode"><a name="1453">1453: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1454">1454: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1455">1455: </a></span>     */
<span class="nocode"><a name="1456">1456: </a></span>    public  int getMaxCharLiteralLength() throws SQLException {
<span class="nocode"><a name="1457">1457: </a></span>        return 32767;
<span class="nocode"><a name="1458">1458: </a></span>    }
<span class="nocode"><a name="1459">1459: </a></span>
<span class="nocode"><a name="1460">1460: </a></span>
<span class="nocode"><a name="1461">1461: </a></span>
<span class="nocode"><a name="1462">1462: </a></span>    /**
<span class="nocode"><a name="1463">1463: </a></span>     * What's the limit on column name length?
<span class="nocode"><a name="1464">1464: </a></span>     *
<span class="nocode"><a name="1465">1465: </a></span>     * @return max column name length;
<span class="nocode"><a name="1466">1466: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1467">1467: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1468">1468: </a></span>     */
<span class="nocode"><a name="1469">1469: </a></span>    public  int getMaxColumnNameLength() throws SQLException {
<span class="nocode"><a name="1470">1470: </a></span>        return 31;
<span class="nocode"><a name="1471">1471: </a></span>    }
<span class="nocode"><a name="1472">1472: </a></span>
<span class="nocode"><a name="1473">1473: </a></span>    /**
<span class="nocode"><a name="1474">1474: </a></span>     * What's the maximum number of columns in a &quot;GROUP BY&quot; clause?
<span class="nocode"><a name="1475">1475: </a></span>     *
<span class="nocode"><a name="1476">1476: </a></span>     * @return max number of columns;
<span class="nocode"><a name="1477">1477: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1478">1478: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1479">1479: </a></span>     */
<span class="nocode"><a name="1480">1480: </a></span>    public  int getMaxColumnsInGroupBy() throws SQLException {
<span class="nocode"><a name="1481">1481: </a></span>        return 0; //I don't know
<span class="nocode"><a name="1482">1482: </a></span>    }
<span class="nocode"><a name="1483">1483: </a></span>
<span class="nocode"><a name="1484">1484: </a></span>    /**
<span class="nocode"><a name="1485">1485: </a></span>     * What's the maximum number of columns allowed in an index?
<span class="nocode"><a name="1486">1486: </a></span>     *
<span class="nocode"><a name="1487">1487: </a></span>     * @return max number of columns;
<span class="nocode"><a name="1488">1488: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1489">1489: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1490">1490: </a></span>     */
<span class="nocode"><a name="1491">1491: </a></span>    public  int getMaxColumnsInIndex() throws SQLException {
<span class="nocode"><a name="1492">1492: </a></span>        return 0; //I don't know
<span class="nocode"><a name="1493">1493: </a></span>    }
<span class="nocode"><a name="1494">1494: </a></span>
<span class="nocode"><a name="1495">1495: </a></span>    /**
<span class="nocode"><a name="1496">1496: </a></span>     * What's the maximum number of columns in an &quot;ORDER BY&quot; clause?
<span class="nocode"><a name="1497">1497: </a></span>     *
<span class="nocode"><a name="1498">1498: </a></span>     * @return max number of columns;
<span class="nocode"><a name="1499">1499: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1500">1500: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1501">1501: </a></span>     */
<span class="nocode"><a name="1502">1502: </a></span>    public  int getMaxColumnsInOrderBy() throws SQLException {
<span class="nocode"><a name="1503">1503: </a></span>        return 0; //I don't know
<span class="nocode"><a name="1504">1504: </a></span>    }
<span class="nocode"><a name="1505">1505: </a></span>
<span class="nocode"><a name="1506">1506: </a></span>    /**
<span class="nocode"><a name="1507">1507: </a></span>     * What's the maximum number of columns in a &quot;SELECT&quot; list?
<span class="nocode"><a name="1508">1508: </a></span>     *
<span class="nocode"><a name="1509">1509: </a></span>     * @return max number of columns;
<span class="nocode"><a name="1510">1510: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1511">1511: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1512">1512: </a></span>     */
<span class="nocode"><a name="1513">1513: </a></span>    public  int getMaxColumnsInSelect() throws SQLException {
<span class="nocode"><a name="1514">1514: </a></span>        return 0; //I don't know
<span class="nocode"><a name="1515">1515: </a></span>    }
<span class="nocode"><a name="1516">1516: </a></span>
<span class="nocode"><a name="1517">1517: </a></span>    /**
<span class="nocode"><a name="1518">1518: </a></span>     * What's the maximum number of columns in a table?
<span class="nocode"><a name="1519">1519: </a></span>     *
<span class="nocode"><a name="1520">1520: </a></span>     * @return max number of columns;
<span class="nocode"><a name="1521">1521: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1522">1522: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1523">1523: </a></span>     */
<span class="nocode"><a name="1524">1524: </a></span>    public  int getMaxColumnsInTable() throws SQLException {
<span class="nocode"><a name="1525">1525: </a></span>        return 32767; // Depends on datatypes and sizes, at most 64 kbyte excluding blobs (but including blob ids)
<span class="nocode"><a name="1526">1526: </a></span>    }
<span class="nocode"><a name="1527">1527: </a></span>
<span class="nocode"><a name="1528">1528: </a></span>    /**
<span class="nocode"><a name="1529">1529: </a></span>     * How many active connections can we have at a time to this database?
<span class="nocode"><a name="1530">1530: </a></span>     *
<span class="nocode"><a name="1531">1531: </a></span>     * @return max number of active connections;
<span class="nocode"><a name="1532">1532: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1533">1533: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1534">1534: </a></span>     */
<span class="nocode"><a name="1535">1535: </a></span>    public  int getMaxConnections() throws SQLException {
<span class="nocode"><a name="1536">1536: </a></span>        return 0; //I don't know
<span class="nocode"><a name="1537">1537: </a></span>    }
<span class="nocode"><a name="1538">1538: </a></span>
<span class="nocode"><a name="1539">1539: </a></span>    /**
<span class="nocode"><a name="1540">1540: </a></span>     * What's the maximum cursor name length?
<span class="nocode"><a name="1541">1541: </a></span>     *
<span class="nocode"><a name="1542">1542: </a></span>     * @return max cursor name length in bytes;
<span class="nocode"><a name="1543">1543: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1544">1544: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1545">1545: </a></span>     */
<span class="nocode"><a name="1546">1546: </a></span>    public  int getMaxCursorNameLength() throws SQLException {
<span class="nocode"><a name="1547">1547: </a></span>        return 31;
<span class="nocode"><a name="1548">1548: </a></span>    }
<span class="nocode"><a name="1549">1549: </a></span>
<span class="nocode"><a name="1550">1550: </a></span>    /**
<span class="nocode"><a name="1551">1551: </a></span>     * Retrieves the maximum number of bytes for an index, including all
<span class="nocode"><a name="1552">1552: </a></span>     * of the parts of the index.
<span class="nocode"><a name="1553">1553: </a></span>     *
<span class="nocode"><a name="1554">1554: </a></span>     * @return max index length in bytes, which includes the composite of all
<span class="nocode"><a name="1555">1555: </a></span>     *      the constituent parts of the index;
<span class="nocode"><a name="1556">1556: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1557">1557: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1558">1558: </a></span>     */
<span class="nocode"><a name="1559">1559: </a></span>    public  int getMaxIndexLength() throws SQLException {
<span class="nocode"><a name="1560">1560: </a></span>        if (gdsHelper.compareToVersion(2, 0) &lt; 0) {
<span class="nocode"><a name="1561">1561: </a></span>            return 252; // See http://www.firebirdsql.org/en/firebird-technical-specifications/
<span class="nocode"><a name="1562">1562: </a></span>        } else {
<span class="nocode"><a name="1563">1563: </a></span>            return 0; // 1/4 of page size, maybe retrieve page size and use that?
<span class="nocode"><a name="1564">1564: </a></span>        }
<span class="nocode"><a name="1565">1565: </a></span>    }
<span class="nocode"><a name="1566">1566: </a></span>
<span class="nocode"><a name="1567">1567: </a></span>    /**
<span class="nocode"><a name="1568">1568: </a></span>     * What's the maximum length allowed for a schema name?
<span class="nocode"><a name="1569">1569: </a></span>     *
<span class="nocode"><a name="1570">1570: </a></span>     * @return max name length in bytes;
<span class="nocode"><a name="1571">1571: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1572">1572: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1573">1573: </a></span>     */
<span class="nocode"><a name="1574">1574: </a></span>    public  int getMaxSchemaNameLength() throws SQLException {
<span class="nocode"><a name="1575">1575: </a></span>        return 0; //No schemas
<span class="nocode"><a name="1576">1576: </a></span>    }
<span class="nocode"><a name="1577">1577: </a></span>
<span class="nocode"><a name="1578">1578: </a></span>    /**
<span class="nocode"><a name="1579">1579: </a></span>     * What's the maximum length of a procedure name?
<span class="nocode"><a name="1580">1580: </a></span>     *
<span class="nocode"><a name="1581">1581: </a></span>     * @return max name length in bytes;
<span class="nocode"><a name="1582">1582: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1583">1583: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1584">1584: </a></span>     */
<span class="nocode"><a name="1585">1585: </a></span>    public  int getMaxProcedureNameLength() throws SQLException {
<span class="nocode"><a name="1586">1586: </a></span>        return 31;
<span class="nocode"><a name="1587">1587: </a></span>    }
<span class="nocode"><a name="1588">1588: </a></span>
<span class="nocode"><a name="1589">1589: </a></span>    /**
<span class="nocode"><a name="1590">1590: </a></span>     * What's the maximum length of a catalog name?
<span class="nocode"><a name="1591">1591: </a></span>     *
<span class="nocode"><a name="1592">1592: </a></span>     * @return max name length in bytes;
<span class="nocode"><a name="1593">1593: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1594">1594: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1595">1595: </a></span>     */
<span class="nocode"><a name="1596">1596: </a></span>    public  int getMaxCatalogNameLength() throws SQLException {
<span class="nocode"><a name="1597">1597: </a></span>        return 0; //No catalogs
<span class="nocode"><a name="1598">1598: </a></span>    }
<span class="nocode"><a name="1599">1599: </a></span>
<span class="nocode"><a name="1600">1600: </a></span>    /**
<span class="nocode"><a name="1601">1601: </a></span>     * What's the maximum length of a single row?
<span class="nocode"><a name="1602">1602: </a></span>     *
<span class="nocode"><a name="1603">1603: </a></span>     * @return max row size in bytes;
<span class="nocode"><a name="1604">1604: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1605">1605: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1606">1606: </a></span>     */
<span class="nocode"><a name="1607">1607: </a></span>    public  int getMaxRowSize() throws SQLException {
<span class="nocode"><a name="1608">1608: </a></span>        if (gdsHelper.compareToVersion(1, 5) &gt;= 0)
<span class="nocode"><a name="1609">1609: </a></span>            return 65531;
<span class="nocode"><a name="1610">1610: </a></span>        else 
<span class="nocode"><a name="1611">1611: </a></span>            return 0;
<span class="nocode"><a name="1612">1612: </a></span>    }
<span class="nocode"><a name="1613">1613: </a></span>
<span class="nocode"><a name="1614">1614: </a></span>    /**
<span class="nocode"><a name="1615">1615: </a></span>     * Did getMaxRowSize() include LONGVARCHAR and LONGVARBINARY
<span class="nocode"><a name="1616">1616: </a></span>     * blobs?
<span class="nocode"><a name="1617">1617: </a></span>     *
<span class="nocode"><a name="1618">1618: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1619">1619: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1620">1620: </a></span>     */
<span class="nocode"><a name="1621">1621: </a></span>    public  boolean doesMaxRowSizeIncludeBlobs() throws SQLException {
<span class="nocode"><a name="1622">1622: </a></span>        return false; // Blob sizes are not included in rowsize 
<span class="nocode"><a name="1623">1623: </a></span>    }
<span class="nocode"><a name="1624">1624: </a></span>
<span class="nocode"><a name="1625">1625: </a></span>    /**
<span class="nocode"><a name="1626">1626: </a></span>     * What's the maximum length of an SQL statement?
<span class="nocode"><a name="1627">1627: </a></span>     *
<span class="nocode"><a name="1628">1628: </a></span>     * @return max length in bytes;
<span class="nocode"><a name="1629">1629: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1630">1630: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1631">1631: </a></span>     */
<span class="nocode"><a name="1632">1632: </a></span>    public  int getMaxStatementLength() throws SQLException {
<span class="nocode"><a name="1633">1633: </a></span>        return 65536;
<span class="nocode"><a name="1634">1634: </a></span>    }
<span class="nocode"><a name="1635">1635: </a></span>
<span class="nocode"><a name="1636">1636: </a></span>    /**
<span class="nocode"><a name="1637">1637: </a></span>     * How many active statements can we have open at one time to this
<span class="nocode"><a name="1638">1638: </a></span>     * database?
<span class="nocode"><a name="1639">1639: </a></span>     *
<span class="nocode"><a name="1640">1640: </a></span>     * @return the maximum number of statements that can be open at one time;
<span class="nocode"><a name="1641">1641: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1642">1642: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1643">1643: </a></span>     */
<span class="nocode"><a name="1644">1644: </a></span>    public  int getMaxStatements() throws SQLException {
<span class="nocode"><a name="1645">1645: </a></span>        return 0;
<span class="nocode"><a name="1646">1646: </a></span>    }
<span class="nocode"><a name="1647">1647: </a></span>
<span class="nocode"><a name="1648">1648: </a></span>    /**
<span class="nocode"><a name="1649">1649: </a></span>     * What's the maximum length of a table name?
<span class="nocode"><a name="1650">1650: </a></span>     *
<span class="nocode"><a name="1651">1651: </a></span>     * @return max name length in bytes;
<span class="nocode"><a name="1652">1652: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1653">1653: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1654">1654: </a></span>     */
<span class="nocode"><a name="1655">1655: </a></span>    public  int getMaxTableNameLength() throws SQLException {
<span class="nocode"><a name="1656">1656: </a></span>        return 31;
<span class="nocode"><a name="1657">1657: </a></span>    }
<span class="nocode"><a name="1658">1658: </a></span>
<span class="nocode"><a name="1659">1659: </a></span>    /**
<span class="nocode"><a name="1660">1660: </a></span>     * What's the maximum number of tables in a SELECT statement?
<span class="nocode"><a name="1661">1661: </a></span>     *
<span class="nocode"><a name="1662">1662: </a></span>     * @return the maximum number of tables allowed in a SELECT statement;
<span class="nocode"><a name="1663">1663: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1664">1664: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1665">1665: </a></span>     */
<span class="nocode"><a name="1666">1666: </a></span>    public  int getMaxTablesInSelect() throws SQLException {
<span class="nocode"><a name="1667">1667: </a></span>        return 0;
<span class="nocode"><a name="1668">1668: </a></span>    }
<span class="nocode"><a name="1669">1669: </a></span>
<span class="nocode"><a name="1670">1670: </a></span>    /**
<span class="nocode"><a name="1671">1671: </a></span>     * What's the maximum length of a user name?
<span class="nocode"><a name="1672">1672: </a></span>     *
<span class="nocode"><a name="1673">1673: </a></span>     * @return max user name length  in bytes;
<span class="nocode"><a name="1674">1674: </a></span>     *      a result of zero means that there is no limit or the limit is not known
<span class="nocode"><a name="1675">1675: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1676">1676: </a></span>     */
<span class="nocode"><a name="1677">1677: </a></span>    public  int getMaxUserNameLength() throws SQLException {
<span class="nocode"><a name="1678">1678: </a></span>        return 31;//I don't know??
<span class="nocode"><a name="1679">1679: </a></span>    }
<span class="nocode"><a name="1680">1680: </a></span>
<span class="nocode"><a name="1681">1681: </a></span>    //----------------------------------------------------------------------
<span class="nocode"><a name="1682">1682: </a></span>
<span class="nocode"><a name="1683">1683: </a></span>    /**
<span class="nocode"><a name="1684">1684: </a></span>     * What's the database's default transaction isolation level?  The
<span class="nocode"><a name="1685">1685: </a></span>     * values are defined in &lt;code&gt;java.sql.Connection&lt;/code&gt;.
<span class="nocode"><a name="1686">1686: </a></span>     *
<span class="nocode"><a name="1687">1687: </a></span>     * @return the default isolation level
<span class="nocode"><a name="1688">1688: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1689">1689: </a></span>     * @see Connection
<span class="nocode"><a name="1690">1690: </a></span>     */
<span class="nocode"><a name="1691">1691: </a></span>    public  int getDefaultTransactionIsolation() throws SQLException {
<span class="nocode"><a name="1692">1692: </a></span>        return Connection.TRANSACTION_READ_COMMITTED;//close enough to snapshot.
<span class="nocode"><a name="1693">1693: </a></span>    }
<span class="nocode"><a name="1694">1694: </a></span>
<span class="nocode"><a name="1695">1695: </a></span>    /**
<span class="nocode"><a name="1696">1696: </a></span>     * Are transactions supported? If not, invoking the method
<span class="nocode"><a name="1697">1697: </a></span>     * &lt;code&gt;commit&lt;/code&gt; is a noop and the
<span class="nocode"><a name="1698">1698: </a></span>     * isolation level is TRANSACTION_NONE.
<span class="nocode"><a name="1699">1699: </a></span>     *
<span class="nocode"><a name="1700">1700: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if transactions are supported; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1701">1701: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1702">1702: </a></span>     */
<span class="nocode"><a name="1703">1703: </a></span>    public  boolean supportsTransactions() throws SQLException {
<span class="nocode"><a name="1704">1704: </a></span>        return true;
<span class="nocode"><a name="1705">1705: </a></span>    }
<span class="nocode"><a name="1706">1706: </a></span>
<span class="nocode"><a name="1707">1707: </a></span>    /**
<span class="nocode"><a name="1708">1708: </a></span>     * Does this database support the given transaction isolation level?
<span class="nocode"><a name="1709">1709: </a></span>     *
<span class="nocode"><a name="1710">1710: </a></span>     * @param level the values are defined in &lt;code&gt;java.sql.Connection&lt;/code&gt;
<span class="nocode"><a name="1711">1711: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1712">1712: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1713">1713: </a></span>     * @see Connection
<span class="nocode"><a name="1714">1714: </a></span>     */
<span class="nocode"><a name="1715">1715: </a></span>    public boolean supportsTransactionIsolationLevel(int level) throws SQLException {
<span class="nocode"><a name="1716">1716: </a></span><span style="background-color: #ffffcc">        switch (level) {</span>
<span class="nocode"><a name="1717">1717: </a></span>            case Connection.TRANSACTION_NONE: return false;
<span class="nocode"><a name="1718">1718: </a></span>            case Connection.TRANSACTION_READ_COMMITTED: return true;//true soon
<span class="nocode"><a name="1719">1719: </a></span>            case Connection.TRANSACTION_READ_UNCOMMITTED: return false;
<span class="nocode"><a name="1720">1720: </a></span>            case Connection.TRANSACTION_REPEATABLE_READ: return true;//??
<span class="nocode"><a name="1721">1721: </a></span>            case Connection.TRANSACTION_SERIALIZABLE: return true;//????
<span class="nocode"><a name="1722">1722: </a></span><span style="background-color: #ffffcc">            default: return false;</span>
<span class="nocode"><a name="1723">1723: </a></span>        }
<span class="nocode"><a name="1724">1724: </a></span>    }
<span class="nocode"><a name="1725">1725: </a></span>
<span class="nocode"><a name="1726">1726: </a></span>    /**
<span class="nocode"><a name="1727">1727: </a></span>     * Are both data definition and data manipulation statements
<span class="nocode"><a name="1728">1728: </a></span>     * within a transaction supported?
<span class="nocode"><a name="1729">1729: </a></span>     *
<span class="nocode"><a name="1730">1730: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1731">1731: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1732">1732: </a></span>     */
<span class="nocode"><a name="1733">1733: </a></span>    public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException {
<span class="nocode"><a name="1734">1734: </a></span>        return true;//but not on the tables you defined in the transaction!
<span class="nocode"><a name="1735">1735: </a></span>    }
<span class="nocode"><a name="1736">1736: </a></span>
<span class="nocode"><a name="1737">1737: </a></span>    /**
<span class="nocode"><a name="1738">1738: </a></span>     * Are only data manipulation statements within a transaction
<span class="nocode"><a name="1739">1739: </a></span>     * supported?
<span class="nocode"><a name="1740">1740: </a></span>     *
<span class="nocode"><a name="1741">1741: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1742">1742: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1743">1743: </a></span>     */
<span class="nocode"><a name="1744">1744: </a></span>    public boolean supportsDataManipulationTransactionsOnly() throws SQLException {
<span class="nocode"><a name="1745">1745: </a></span>        return false;
<span class="nocode"><a name="1746">1746: </a></span>    }
<span class="nocode"><a name="1747">1747: </a></span>
<span class="nocode"><a name="1748">1748: </a></span>    /**
<span class="nocode"><a name="1749">1749: </a></span>     * Does a data definition statement within a transaction force the
<span class="nocode"><a name="1750">1750: </a></span>     * transaction to commit?
<span class="nocode"><a name="1751">1751: </a></span>     *
<span class="nocode"><a name="1752">1752: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1753">1753: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1754">1754: </a></span>     */
<span class="nocode"><a name="1755">1755: </a></span>    public boolean dataDefinitionCausesTransactionCommit() throws SQLException {
<span class="nocode"><a name="1756">1756: </a></span>        return false;//but you can't use the table till the transaction is committed.
<span class="nocode"><a name="1757">1757: </a></span>    }
<span class="nocode"><a name="1758">1758: </a></span>
<span class="nocode"><a name="1759">1759: </a></span>    /**
<span class="nocode"><a name="1760">1760: </a></span>     * Is a data definition statement within a transaction ignored?
<span class="nocode"><a name="1761">1761: </a></span>     *
<span class="nocode"><a name="1762">1762: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="1763">1763: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1764">1764: </a></span>     */
<span class="nocode"><a name="1765">1765: </a></span>    public boolean dataDefinitionIgnoredInTransactions() throws SQLException {
<span class="nocode"><a name="1766">1766: </a></span>        return false;
<span class="nocode"><a name="1767">1767: </a></span>    }
<span class="nocode"><a name="1768">1768: </a></span>
<span class="nocode"><a name="1769">1769: </a></span>    private static final String GET_PROCEDURES_START = &quot;select &quot;
<span class="nocode"><a name="1770">1770: </a></span>        + &quot; RDB$PROCEDURE_NAME as PROCEDURE_NAME,&quot;
<span class="nocode"><a name="1771">1771: </a></span>        + &quot; RDB$DESCRIPTION as REMARKS,&quot;
<span class="nocode"><a name="1772">1772: </a></span>        + &quot; RDB$PROCEDURE_OUTPUTS as PROCEDURE_TYPE &quot;
<span class="nocode"><a name="1773">1773: </a></span>        + &quot;from&quot;
<span class="nocode"><a name="1774">1774: </a></span>        + &quot; RDB$PROCEDURES &quot;
<span class="nocode"><a name="1775">1775: </a></span>        + &quot;where &quot;;
<span class="nocode"><a name="1776">1776: </a></span>    private static final String GET_PROCEDURES_END = &quot;1 = 1 order by 1&quot;;
<span class="nocode"><a name="1777">1777: </a></span>
<span class="nocode"><a name="1778">1778: </a></span>    /**
<span class="nocode"><a name="1779">1779: </a></span>     * Gets a description of the stored procedures available in a
<span class="nocode"><a name="1780">1780: </a></span>     * catalog.
<span class="nocode"><a name="1781">1781: </a></span>     *
<span class="nocode"><a name="1782">1782: </a></span>     * &lt;P&gt;Only procedure descriptions matching the schema and
<span class="nocode"><a name="1783">1783: </a></span>     * procedure name criteria are returned.  They are ordered by
<span class="nocode"><a name="1784">1784: </a></span>     * PROCEDURE_SCHEM, and PROCEDURE_NAME.
<span class="nocode"><a name="1785">1785: </a></span>     *
<span class="nocode"><a name="1786">1786: </a></span>     * &lt;P&gt;Each procedure description has the the following columns:
<span class="nocode"><a name="1787">1787: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="1788">1788: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String =&gt; procedure catalog (may be null)
<span class="nocode"><a name="1789">1789: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String =&gt; procedure schema (may be null)
<span class="nocode"><a name="1790">1790: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String =&gt; procedure name
<span class="nocode"><a name="1791">1791: </a></span>     *  &lt;LI&gt; reserved for future use
<span class="nocode"><a name="1792">1792: </a></span>     *  &lt;LI&gt; reserved for future use
<span class="nocode"><a name="1793">1793: </a></span>     *  &lt;LI&gt; reserved for future use
<span class="nocode"><a name="1794">1794: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; explanatory comment on the procedure
<span class="nocode"><a name="1795">1795: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_TYPE&lt;/B&gt; short =&gt; kind of procedure:
<span class="nocode"><a name="1796">1796: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="1797">1797: </a></span>     *      &lt;LI&gt; procedureResultUnknown - May return a result
<span class="nocode"><a name="1798">1798: </a></span>     *      &lt;LI&gt; procedureNoResult - Does not return a result
<span class="nocode"><a name="1799">1799: </a></span>     *      &lt;LI&gt; procedureReturnsResult - Returns a result
<span class="nocode"><a name="1800">1800: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="1801">1801: </a></span>     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String =&gt; The name which uniquely identifies this procedure within its schema.
<span class="nocode"><a name="1802">1802: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="1803">1803: </a></span>     *
<span class="nocode"><a name="1804">1804: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="1805">1805: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="1806">1806: </a></span>     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those
<span class="nocode"><a name="1807">1807: </a></span>     * without a schema
<span class="nocode"><a name="1808">1808: </a></span>     * @param procedureNamePattern a procedure name pattern
<span class="nocode"><a name="1809">1809: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a procedure description
<span class="nocode"><a name="1810">1810: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="1811">1811: </a></span>     * @see #getSearchStringEscape
<span class="nocode"><a name="1812">1812: </a></span>     */
<span class="nocode"><a name="1813">1813: </a></span>    public ResultSet getProcedures(String catalog, String schemaPattern,
<span class="nocode"><a name="1814">1814: </a></span>            String procedureNamePattern) throws SQLException {
<span class="nocode"><a name="1815">1815: </a></span>        checkCatalogAndSchema(catalog, schemaPattern);
<span class="nocode"><a name="1816">1816: </a></span>        
<span class="nocode"><a name="1817">1817: </a></span>        if (procedureNamePattern == null || procedureNamePattern.equals(&quot;&quot;)) {
<span class="nocode"><a name="1818">1818: </a></span>            procedureNamePattern = &quot;%&quot;;
<span class="nocode"><a name="1819">1819: </a></span>        }
<span class="nocode"><a name="1820">1820: </a></span>
<span class="nocode"><a name="1821">1821: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[9];
<span class="nocode"><a name="1822">1822: </a></span>
<span class="nocode"><a name="1823">1823: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="1824">1824: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1825">1825: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="1826">1826: </a></span>        xsqlvars[0].sqlname = &quot;PROCEDURE_CAT&quot;;
<span class="nocode"><a name="1827">1827: </a></span>        xsqlvars[0].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1828">1828: </a></span>
<span class="nocode"><a name="1829">1829: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="1830">1830: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1831">1831: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="1832">1832: </a></span>        xsqlvars[1].sqlname = &quot;PROCEDURE_SCHEM&quot;;
<span class="nocode"><a name="1833">1833: </a></span>        xsqlvars[1].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1834">1834: </a></span>
<span class="nocode"><a name="1835">1835: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="1836">1836: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1837">1837: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="1838">1838: </a></span>        xsqlvars[2].sqlname = &quot;PROCEDURE_NAME&quot;;
<span class="nocode"><a name="1839">1839: </a></span>        xsqlvars[2].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1840">1840: </a></span>
<span class="nocode"><a name="1841">1841: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="1842">1842: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1843">1843: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="1844">1844: </a></span>        xsqlvars[3].sqlname = &quot;FUTURE1&quot;;
<span class="nocode"><a name="1845">1845: </a></span>        xsqlvars[3].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1846">1846: </a></span>
<span class="nocode"><a name="1847">1847: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="1848">1848: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1849">1849: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="1850">1850: </a></span>        xsqlvars[4].sqlname = &quot;FUTURE2&quot;;
<span class="nocode"><a name="1851">1851: </a></span>        xsqlvars[4].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1852">1852: </a></span>
<span class="nocode"><a name="1853">1853: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="1854">1854: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1855">1855: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="1856">1856: </a></span>        xsqlvars[5].sqlname = &quot;FUTURE3&quot;;
<span class="nocode"><a name="1857">1857: </a></span>        xsqlvars[5].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1858">1858: </a></span>
<span class="nocode"><a name="1859">1859: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="1860">1860: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1861">1861: </a></span>        xsqlvars[6].sqllen = 80; // gets updated if there are longer remarks.
<span class="nocode"><a name="1862">1862: </a></span>        xsqlvars[6].sqlname = &quot;REMARKS&quot;;
<span class="nocode"><a name="1863">1863: </a></span>        xsqlvars[6].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1864">1864: </a></span>
<span class="nocode"><a name="1865">1865: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="1866">1866: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="1867">1867: </a></span>        xsqlvars[7].sqlname = &quot;PROCEDURE_TYPE&quot;;
<span class="nocode"><a name="1868">1868: </a></span>        xsqlvars[7].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1869">1869: </a></span>        
<span class="nocode"><a name="1870">1870: </a></span>        xsqlvars[8] = new XSQLVAR();
<span class="nocode"><a name="1871">1871: </a></span>        xsqlvars[8].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="1872">1872: </a></span>        xsqlvars[8].sqllen = 31;
<span class="nocode"><a name="1873">1873: </a></span>        xsqlvars[8].sqlname = &quot;SPECIFIC_NAME&quot;;
<span class="nocode"><a name="1874">1874: </a></span>        xsqlvars[8].relname = &quot;RDB$PROCEDURES&quot;;
<span class="nocode"><a name="1875">1875: </a></span>
<span class="nocode"><a name="1876">1876: </a></span>        Clause procedureClause = new Clause(&quot;RDB$PROCEDURE_NAME&quot;, procedureNamePattern);
<span class="nocode"><a name="1877">1877: </a></span>        
<span class="nocode"><a name="1878">1878: </a></span>        String sql = GET_PROCEDURES_START;
<span class="nocode"><a name="1879">1879: </a></span>        sql += procedureClause.getCondition();
<span class="nocode"><a name="1880">1880: </a></span>        sql += GET_PROCEDURES_END;
<span class="nocode"><a name="1881">1881: </a></span>        
<span class="nocode"><a name="1882">1882: </a></span>        // check the original case identifiers first
<span class="nocode"><a name="1883">1883: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="1884">1884: </a></span>        if (!procedureClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="1885">1885: </a></span>            params.add(procedureClause.getOriginalCaseValue());
<span class="nocode"><a name="1886">1886: </a></span>        }
<span class="nocode"><a name="1887">1887: </a></span>
<span class="nocode"><a name="1888">1888: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="1889">1889: </a></span>        ArrayList&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="1890">1890: </a></span>        
<span class="nocode"><a name="1891">1891: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="1892">1892: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="1893">1893: </a></span>            params.clear();
<span class="nocode"><a name="1894">1894: </a></span>            if (!procedureClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="1895">1895: </a></span>                params.add(procedureClause.getValue());
<span class="nocode"><a name="1896">1896: </a></span>            }
<span class="nocode"><a name="1897">1897: </a></span>            
<span class="nocode"><a name="1898">1898: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="1899">1899: </a></span>            
<span class="nocode"><a name="1900">1900: </a></span>            // if nothing found, return an empty result set
<span class="nocode"><a name="1901">1901: </a></span>            if (!rs.next())
<span class="nocode"><a name="1902">1902: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="1903">1903: </a></span>        }
<span class="nocode"><a name="1904">1904: </a></span>        
<span class="nocode"><a name="1905">1905: </a></span>        do {
<span class="nocode"><a name="1906">1906: </a></span>            byte[][] row = new byte[9][];
<span class="nocode"><a name="1907">1907: </a></span>            row[0] = null;
<span class="nocode"><a name="1908">1908: </a></span>            row[1] = null;
<span class="nocode"><a name="1909">1909: </a></span>            row[2] = getBytes(rs.getString(&quot;PROCEDURE_NAME&quot;));
<span class="nocode"><a name="1910">1910: </a></span>            row[3] = null;
<span class="nocode"><a name="1911">1911: </a></span>            row[4] = null;
<span class="nocode"><a name="1912">1912: </a></span>            row[5] = null;
<span class="nocode"><a name="1913">1913: </a></span>            String remarks = rs.getString(&quot;REMARKS&quot;);
<span class="nocode"><a name="1914">1914: </a></span>            row[6] = getBytes(remarks);
<span class="nocode"><a name="1915">1915: </a></span>            if (remarks != null &amp;&amp; remarks.length() &gt; xsqlvars[6].sqllen)
<span class="nocode"><a name="1916">1916: </a></span>                xsqlvars[6].sqllen = remarks.length();
<span class="nocode"><a name="1917">1917: </a></span>            short procedureType = rs.getShort(&quot;PROCEDURE_TYPE&quot;);
<span class="nocode"><a name="1918">1918: </a></span>            row[7] = (procedureType == 0) ? xsqlvars[0].encodeShort((short)procedureNoResult) : xsqlvars[0].encodeShort((short)procedureReturnsResult);
<span class="nocode"><a name="1919">1919: </a></span>            row[8] = row[2];
<span class="nocode"><a name="1920">1920: </a></span>            rows.add(row);
<span class="nocode"><a name="1921">1921: </a></span>        } while (rs.next());
<span class="nocode"><a name="1922">1922: </a></span>        
<span class="nocode"><a name="1923">1923: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="1924">1924: </a></span>    }
<span class="nocode"><a name="1925">1925: </a></span>
<span class="nocode"><a name="1926">1926: </a></span>
<span class="nocode"><a name="1927">1927: </a></span>    private static final String GET_PROCEDURE_COLUMNS_START = &quot;select&quot;
<span class="nocode"><a name="1928">1928: </a></span>        + &quot; PP.RDB$PROCEDURE_NAME as PROCEDURE_NAME,&quot;
<span class="nocode"><a name="1929">1929: </a></span>        + &quot; PP.RDB$PARAMETER_NAME as COLUMN_NAME,&quot;
<span class="nocode"><a name="1930">1930: </a></span>        + &quot; PP.RDB$PARAMETER_TYPE as COLUMN_TYPE,&quot;
<span class="nocode"><a name="1931">1931: </a></span>        + &quot; F.RDB$FIELD_TYPE as FIELD_TYPE,&quot;
<span class="nocode"><a name="1932">1932: </a></span>        + &quot; F.RDB$FIELD_SUB_TYPE as FIELD_SUB_TYPE,&quot;
<span class="nocode"><a name="1933">1933: </a></span>        + &quot; F.RDB$FIELD_PRECISION as FIELD_PRECISION,&quot;
<span class="nocode"><a name="1934">1934: </a></span>        + &quot; F.RDB$FIELD_SCALE as FIELD_SCALE,&quot;
<span class="nocode"><a name="1935">1935: </a></span>        + &quot; F.RDB$FIELD_LENGTH as FIELD_LENGTH,&quot;
<span class="nocode"><a name="1936">1936: </a></span>        + &quot; F.RDB$NULL_FLAG as NULL_FLAG,&quot;
<span class="nocode"><a name="1937">1937: </a></span>        + &quot; PP.RDB$DESCRIPTION as REMARKS,&quot;
<span class="nocode"><a name="1938">1938: </a></span>        + &quot; F.RDB$CHARACTER_LENGTH AS CHAR_LEN,&quot;
<span class="nocode"><a name="1939">1939: </a></span>        + &quot; PP.RDB$PARAMETER_NUMBER + 1 AS PARAMETER_NUMBER &quot; 
<span class="nocode"><a name="1940">1940: </a></span>        + &quot;from&quot;
<span class="nocode"><a name="1941">1941: </a></span>        + &quot; RDB$PROCEDURE_PARAMETERS PP,&quot;
<span class="nocode"><a name="1942">1942: </a></span>        + &quot; RDB$FIELDS F &quot;
<span class="nocode"><a name="1943">1943: </a></span>        + &quot;where &quot;;
<span class="nocode"><a name="1944">1944: </a></span>    private static final String GET_PROCEDURE_COLUMNS_END = &quot; PP.RDB$FIELD_SOURCE = F.RDB$FIELD_NAME &quot;
<span class="nocode"><a name="1945">1945: </a></span>        + &quot;order by&quot;
<span class="nocode"><a name="1946">1946: </a></span>        + &quot; PP.RDB$PROCEDURE_NAME,&quot;
<span class="nocode"><a name="1947">1947: </a></span>        + &quot; PP.RDB$PARAMETER_TYPE desc,&quot;
<span class="nocode"><a name="1948">1948: </a></span>        + &quot; PP.RDB$PARAMETER_NUMBER &quot;;
<span class="nocode"><a name="1949">1949: </a></span>
<span class="nocode"><a name="1950">1950: </a></span>    /**
<span class="nocode"><a name="1951">1951: </a></span>     * Retrieves a description of the given catalog's stored procedure parameter
<span class="nocode"><a name="1952">1952: </a></span>     * and result columns.
<span class="nocode"><a name="1953">1953: </a></span>     *
<span class="nocode"><a name="1954">1954: </a></span>     * &lt;P&gt;Only descriptions matching the schema, procedure and
<span class="nocode"><a name="1955">1955: </a></span>     * parameter name criteria are returned.  They are ordered by
<span class="nocode"><a name="1956">1956: </a></span>     * PROCEDURE_CAT, PROCEDURE_SCHEM, PROCEDURE_NAME and SPECIFIC_NAME. Within this, the return value,
<span class="nocode"><a name="1957">1957: </a></span>     * if any, is first. Next are the parameter descriptions in call
<span class="nocode"><a name="1958">1958: </a></span>     * order. The column descriptions follow in column number order.
<span class="nocode"><a name="1959">1959: </a></span>     *
<span class="nocode"><a name="1960">1960: </a></span>     * &lt;P&gt;Each row in the &lt;code&gt;ResultSet&lt;/code&gt; is a parameter description or
<span class="nocode"><a name="1961">1961: </a></span>     * column description with the following fields:
<span class="nocode"><a name="1962">1962: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="1963">1963: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_CAT&lt;/B&gt; String =&gt; procedure catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="1964">1964: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_SCHEM&lt;/B&gt; String =&gt; procedure schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="1965">1965: </a></span>     *  &lt;LI&gt;&lt;B&gt;PROCEDURE_NAME&lt;/B&gt; String =&gt; procedure name
<span class="nocode"><a name="1966">1966: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column/parameter name 
<span class="nocode"><a name="1967">1967: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_TYPE&lt;/B&gt; Short =&gt; kind of column/parameter:
<span class="nocode"><a name="1968">1968: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="1969">1969: </a></span>     *      &lt;LI&gt; procedureColumnUnknown - nobody knows
<span class="nocode"><a name="1970">1970: </a></span>     *      &lt;LI&gt; procedureColumnIn - IN parameter
<span class="nocode"><a name="1971">1971: </a></span>     *      &lt;LI&gt; procedureColumnInOut - INOUT parameter
<span class="nocode"><a name="1972">1972: </a></span>     *      &lt;LI&gt; procedureColumnOut - OUT parameter
<span class="nocode"><a name="1973">1973: </a></span>     *      &lt;LI&gt; procedureColumnReturn - procedure return value
<span class="nocode"><a name="1974">1974: </a></span>     *      &lt;LI&gt; procedureColumnResult - result column in &lt;code&gt;ResultSet&lt;/code&gt;
<span class="nocode"><a name="1975">1975: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="1976">1976: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&gt; SQL type from java.sql.Types
<span class="nocode"><a name="1977">1977: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; SQL type name, for a UDT type the
<span class="nocode"><a name="1978">1978: </a></span>     *  type name is fully qualified
<span class="nocode"><a name="1979">1979: </a></span>     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int =&gt; precision
<span class="nocode"><a name="1980">1980: </a></span>     *  &lt;LI&gt;&lt;B&gt;LENGTH&lt;/B&gt; int =&gt; length in bytes of data
<span class="nocode"><a name="1981">1981: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCALE&lt;/B&gt; short =&gt; scale -  null is returned for data types where  
<span class="nocode"><a name="1982">1982: </a></span>     * SCALE is not applicable.
<span class="nocode"><a name="1983">1983: </a></span>     *  &lt;LI&gt;&lt;B&gt;RADIX&lt;/B&gt; short =&gt; radix
<span class="nocode"><a name="1984">1984: </a></span>     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short =&gt; can it contain NULL.
<span class="nocode"><a name="1985">1985: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="1986">1986: </a></span>     *      &lt;LI&gt; procedureNoNulls - does not allow NULL values
<span class="nocode"><a name="1987">1987: </a></span>     *      &lt;LI&gt; procedureNullable - allows NULL values
<span class="nocode"><a name="1988">1988: </a></span>     *      &lt;LI&gt; procedureNullableUnknown - nullability unknown
<span class="nocode"><a name="1989">1989: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="1990">1990: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; comment describing parameter/column
<span class="nocode"><a name="1991">1991: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String =&gt; default value for the column, which should be interpreted as a string when the value is enclosed in single quotes (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="1992">1992: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="1993">1993: </a></span>     *      &lt;LI&gt; The string NULL (not enclosed in quotes) - if NULL was specified as the default value
<span class="nocode"><a name="1994">1994: </a></span>     *      &lt;LI&gt; TRUNCATE (not enclosed in quotes)        - if the specified default value cannot be represented without truncation
<span class="nocode"><a name="1995">1995: </a></span>     *      &lt;LI&gt; NULL                                     - if a default value was not specified
<span class="nocode"><a name="1996">1996: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="1997">1997: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int  =&gt; reserved for future use
<span class="nocode"><a name="1998">1998: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int  =&gt; reserved for future use
<span class="nocode"><a name="1999">1999: </a></span>     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int  =&gt; the maximum length of binary and character based columns.  For any other datatype the returned value is a 
<span class="nocode"><a name="2000">2000: </a></span>     * NULL
<span class="nocode"><a name="2001">2001: </a></span>     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int  =&gt; the ordinal position, starting from 1, for the input and output parameters for a procedure. A value of 0
<span class="nocode"><a name="2002">2002: </a></span>     *is returned if this row describes the procedure's return value.  For result set columns, it is the
<span class="nocode"><a name="2003">2003: </a></span>     *ordinal position of the column in the result set starting from 1.  If there are
<span class="nocode"><a name="2004">2004: </a></span>     *multiple result sets, the column ordinal positions are implementation
<span class="nocode"><a name="2005">2005: </a></span>     * defined.
<span class="nocode"><a name="2006">2006: </a></span>     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  =&gt; ISO rules are used to determine the nullability for a column.
<span class="nocode"><a name="2007">2007: </a></span>     *       &lt;UL&gt;
<span class="nocode"><a name="2008">2008: </a></span>     *       &lt;LI&gt; YES           --- if the parameter can include NULLs
<span class="nocode"><a name="2009">2009: </a></span>     *       &lt;LI&gt; NO            --- if the parameter cannot include NULLs
<span class="nocode"><a name="2010">2010: </a></span>     *       &lt;LI&gt; empty string  --- if the nullability for the 
<span class="nocode"><a name="2011">2011: </a></span>     * parameter is unknown
<span class="nocode"><a name="2012">2012: </a></span>     *       &lt;/UL&gt;
<span class="nocode"><a name="2013">2013: </a></span>     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  =&gt; the name which uniquely identifies this procedure within its schema.
<span class="nocode"><a name="2014">2014: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2015">2015: </a></span>     *
<span class="nocode"><a name="2016">2016: </a></span>     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return the column
<span class="nocode"><a name="2017">2017: </a></span>     * descriptions for a procedure. 
<span class="nocode"><a name="2018">2018: </a></span>     * 
<span class="nocode"><a name="2019">2019: </a></span>     * &lt;p&gt;The PRECISION column represents the specified column size for the given column. 
<span class="nocode"><a name="2020">2020: </a></span>     * For numeric data, this is the maximum precision.  For character data, this is the length in characters. 
<span class="nocode"><a name="2021">2021: </a></span>     * For datetime datatypes, this is the length in characters of the String representation (assuming the 
<span class="nocode"><a name="2022">2022: </a></span>     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype, 
<span class="nocode"><a name="2023">2023: </a></span>     * this is the length in bytes. Null is returned for data types where the
<span class="nocode"><a name="2024">2024: </a></span>     * column size is not applicable.
<span class="nocode"><a name="2025">2025: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="2026">2026: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="2027">2027: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="2028">2028: </a></span>     *        the search
<span class="nocode"><a name="2029">2029: </a></span>     * @param schemaPattern a schema name pattern; must match the schema name
<span class="nocode"><a name="2030">2030: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="2031">2031: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="2032">2032: </a></span>     *        the search
<span class="nocode"><a name="2033">2033: </a></span>     * @param procedureNamePattern a procedure name pattern; must match the
<span class="nocode"><a name="2034">2034: </a></span>     *        procedure name as it is stored in the database 
<span class="nocode"><a name="2035">2035: </a></span>     * @param columnNamePattern a column name pattern; must match the column name
<span class="nocode"><a name="2036">2036: </a></span>     *        as it is stored in the database 
<span class="nocode"><a name="2037">2037: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row describes a stored procedure parameter or 
<span class="nocode"><a name="2038">2038: </a></span>     *      column
<span class="nocode"><a name="2039">2039: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2040">2040: </a></span>     * @see #getSearchStringEscape 
<span class="nocode"><a name="2041">2041: </a></span>     */
<span class="nocode"><a name="2042">2042: </a></span>    public ResultSet getProcedureColumns(String catalog,
<span class="nocode"><a name="2043">2043: </a></span>            String schemaPattern,
<span class="nocode"><a name="2044">2044: </a></span>            String procedureNamePattern,
<span class="nocode"><a name="2045">2045: </a></span>            String columnNamePattern) throws SQLException {
<span class="nocode"><a name="2046">2046: </a></span><span style="background-color: #ffffcc">        checkCatalogAndSchema(catalog, schemaPattern);</span>
<span class="nocode"><a name="2047">2047: </a></span>
<span class="nocode"><a name="2048">2048: </a></span><span style="background-color: #ffffcc">        XSQLVAR[] xsqlvars = new XSQLVAR[20];</span>
<span class="nocode"><a name="2049">2049: </a></span>
<span class="nocode"><a name="2050">2050: </a></span><span style="background-color: #ffffcc">        xsqlvars[0] = new XSQLVAR();</span>
<span class="nocode"><a name="2051">2051: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2052">2052: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqllen = 31;</span>
<span class="nocode"><a name="2053">2053: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqlname = &quot;PROCEDURE_CAT&quot;;</span>
<span class="nocode"><a name="2054">2054: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2055">2055: </a></span>
<span class="nocode"><a name="2056">2056: </a></span><span style="background-color: #ffffcc">        xsqlvars[1] = new XSQLVAR();</span>
<span class="nocode"><a name="2057">2057: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2058">2058: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqllen = 31;</span>
<span class="nocode"><a name="2059">2059: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqlname = &quot;PROCEDURE_SCHEM&quot;;</span>
<span class="nocode"><a name="2060">2060: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2061">2061: </a></span>
<span class="nocode"><a name="2062">2062: </a></span><span style="background-color: #ffffcc">        xsqlvars[2] = new XSQLVAR();</span>
<span class="nocode"><a name="2063">2063: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2064">2064: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqllen = 31;</span>
<span class="nocode"><a name="2065">2065: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqlname = &quot;PROCEDURE_NAME&quot;;</span>
<span class="nocode"><a name="2066">2066: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2067">2067: </a></span>
<span class="nocode"><a name="2068">2068: </a></span><span style="background-color: #ffffcc">        xsqlvars[3] = new XSQLVAR();</span>
<span class="nocode"><a name="2069">2069: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2070">2070: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqllen = 31;</span>
<span class="nocode"><a name="2071">2071: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqlname = &quot;COLUMN_NAME&quot;;</span>
<span class="nocode"><a name="2072">2072: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2073">2073: </a></span>
<span class="nocode"><a name="2074">2074: </a></span><span style="background-color: #ffffcc">        xsqlvars[4] = new XSQLVAR();</span>
<span class="nocode"><a name="2075">2075: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="2076">2076: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqlname = &quot;COLUMN_TYPE&quot;;</span>
<span class="nocode"><a name="2077">2077: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2078">2078: </a></span>
<span class="nocode"><a name="2079">2079: </a></span><span style="background-color: #ffffcc">        xsqlvars[5] = new XSQLVAR();</span>
<span class="nocode"><a name="2080">2080: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2081">2081: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqlname = &quot;DATA_TYPE&quot;;</span>
<span class="nocode"><a name="2082">2082: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2083">2083: </a></span>
<span class="nocode"><a name="2084">2084: </a></span><span style="background-color: #ffffcc">        xsqlvars[6] = new XSQLVAR();</span>
<span class="nocode"><a name="2085">2085: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2086">2086: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqllen = 31;</span>
<span class="nocode"><a name="2087">2087: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqlname = &quot;TYPE_NAME&quot;;</span>
<span class="nocode"><a name="2088">2088: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2089">2089: </a></span>
<span class="nocode"><a name="2090">2090: </a></span><span style="background-color: #ffffcc">        xsqlvars[7] = new XSQLVAR();</span>
<span class="nocode"><a name="2091">2091: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2092">2092: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqlname = &quot;PRECISION&quot;;</span>
<span class="nocode"><a name="2093">2093: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2094">2094: </a></span>
<span class="nocode"><a name="2095">2095: </a></span><span style="background-color: #ffffcc">        xsqlvars[8] = new XSQLVAR();</span>
<span class="nocode"><a name="2096">2096: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2097">2097: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqlname = &quot;LENGTH&quot;;</span>
<span class="nocode"><a name="2098">2098: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2099">2099: </a></span>
<span class="nocode"><a name="2100">2100: </a></span><span style="background-color: #ffffcc">        xsqlvars[9] = new XSQLVAR();</span>
<span class="nocode"><a name="2101">2101: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="2102">2102: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqlname = &quot;SCALE&quot;;</span>
<span class="nocode"><a name="2103">2103: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2104">2104: </a></span>
<span class="nocode"><a name="2105">2105: </a></span><span style="background-color: #ffffcc">        xsqlvars[10] = new XSQLVAR();</span>
<span class="nocode"><a name="2106">2106: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="2107">2107: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqlname = &quot;RADIX&quot;;</span>
<span class="nocode"><a name="2108">2108: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2109">2109: </a></span>
<span class="nocode"><a name="2110">2110: </a></span><span style="background-color: #ffffcc">        xsqlvars[11] = new XSQLVAR();</span>
<span class="nocode"><a name="2111">2111: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="2112">2112: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqlname = &quot;NULLABLE&quot;;</span>
<span class="nocode"><a name="2113">2113: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2114">2114: </a></span>
<span class="nocode"><a name="2115">2115: </a></span><span style="background-color: #ffffcc">        xsqlvars[12] = new XSQLVAR();</span>
<span class="nocode"><a name="2116">2116: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2117">2117: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqllen = 80; // gets updated if we get a longer description</span>
<span class="nocode"><a name="2118">2118: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqlname = &quot;REMARKS&quot;;</span>
<span class="nocode"><a name="2119">2119: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2120">2120: </a></span>        
<span class="nocode"><a name="2121">2121: </a></span><span style="background-color: #ffffcc">        xsqlvars[13] = new XSQLVAR();</span>
<span class="nocode"><a name="2122">2122: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2123">2123: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqllen = 31;</span>
<span class="nocode"><a name="2124">2124: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqlname = &quot;COLUMN_DEF&quot;;</span>
<span class="nocode"><a name="2125">2125: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2126">2126: </a></span>        
<span class="nocode"><a name="2127">2127: </a></span><span style="background-color: #ffffcc">        xsqlvars[14] = new XSQLVAR();</span>
<span class="nocode"><a name="2128">2128: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2129">2129: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].sqlname = &quot;SQL_DATA_TYPE&quot;;</span>
<span class="nocode"><a name="2130">2130: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2131">2131: </a></span>        
<span class="nocode"><a name="2132">2132: </a></span><span style="background-color: #ffffcc">        xsqlvars[15] = new XSQLVAR();</span>
<span class="nocode"><a name="2133">2133: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2134">2134: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].sqlname = &quot;SQL_DATETIME_SUB&quot;;</span>
<span class="nocode"><a name="2135">2135: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2136">2136: </a></span>        
<span class="nocode"><a name="2137">2137: </a></span><span style="background-color: #ffffcc">        xsqlvars[16] = new XSQLVAR();</span>
<span class="nocode"><a name="2138">2138: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2139">2139: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].sqlname = &quot;CHAR_OCTET_LENGTH&quot;;</span>
<span class="nocode"><a name="2140">2140: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2141">2141: </a></span>        
<span class="nocode"><a name="2142">2142: </a></span><span style="background-color: #ffffcc">        xsqlvars[17] = new XSQLVAR();</span>
<span class="nocode"><a name="2143">2143: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="2144">2144: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].sqlname = &quot;ORDINAL_POSITION&quot;;</span>
<span class="nocode"><a name="2145">2145: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2146">2146: </a></span>        
<span class="nocode"><a name="2147">2147: </a></span><span style="background-color: #ffffcc">        xsqlvars[18] = new XSQLVAR();</span>
<span class="nocode"><a name="2148">2148: </a></span><span style="background-color: #ffffcc">        xsqlvars[18].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2149">2149: </a></span><span style="background-color: #ffffcc">        xsqlvars[18].sqllen = 3;</span>
<span class="nocode"><a name="2150">2150: </a></span><span style="background-color: #ffffcc">        xsqlvars[18].sqlname = &quot;IS_NULLABLE&quot;;</span>
<span class="nocode"><a name="2151">2151: </a></span><span style="background-color: #ffffcc">        xsqlvars[18].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2152">2152: </a></span>        
<span class="nocode"><a name="2153">2153: </a></span><span style="background-color: #ffffcc">        xsqlvars[19] = new XSQLVAR();</span>
<span class="nocode"><a name="2154">2154: </a></span><span style="background-color: #ffffcc">        xsqlvars[19].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="2155">2155: </a></span><span style="background-color: #ffffcc">        xsqlvars[19].sqllen = 31;</span>
<span class="nocode"><a name="2156">2156: </a></span><span style="background-color: #ffffcc">        xsqlvars[19].sqlname = &quot;SPECIFIC_NAME&quot;;</span>
<span class="nocode"><a name="2157">2157: </a></span><span style="background-color: #ffffcc">        xsqlvars[19].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="2158">2158: </a></span>
<span class="nocode"><a name="2159">2159: </a></span><span style="background-color: #ffffcc">        Clause procedureClause = new Clause(&quot;PP.RDB$PROCEDURE_NAME&quot;, procedureNamePattern);</span>
<span class="nocode"><a name="2160">2160: </a></span><span style="background-color: #ffffcc">        Clause columnClause = new Clause(&quot;PP.RDB$PARAMETER_NAME&quot;, columnNamePattern);</span>
<span class="nocode"><a name="2161">2161: </a></span>        
<span class="nocode"><a name="2162">2162: </a></span><span style="background-color: #ffffcc">        String sql = GET_PROCEDURE_COLUMNS_START;</span>
<span class="nocode"><a name="2163">2163: </a></span><span style="background-color: #ffffcc">        sql += procedureClause.getCondition();</span>
<span class="nocode"><a name="2164">2164: </a></span><span style="background-color: #ffffcc">        sql += columnClause.getCondition();</span>
<span class="nocode"><a name="2165">2165: </a></span><span style="background-color: #ffffcc">        sql += GET_PROCEDURE_COLUMNS_END;</span>
<span class="nocode"><a name="2166">2166: </a></span>        
<span class="nocode"><a name="2167">2167: </a></span>        // check the original case identifiers first
<span class="nocode"><a name="2168">2168: </a></span><span style="background-color: #ffffcc">        List&lt;String&gt; params = new ArrayList&lt;String&gt;();</span>
<span class="nocode"><a name="2169">2169: </a></span><span style="background-color: #ffffcc">        if (!procedureClause.getCondition().equals(&quot;&quot;)) {</span>
<span class="nocode"><a name="2170">2170: </a></span><span style="background-color: #ffffcc">            params.add(procedureClause.getOriginalCaseValue());</span>
<span class="nocode"><a name="2171">2171: </a></span>        }
<span class="nocode"><a name="2172">2172: </a></span><span style="background-color: #ffffcc">        if (!columnClause.getCondition().equals(&quot;&quot;)) {</span>
<span class="nocode"><a name="2173">2173: </a></span><span style="background-color: #ffffcc">            params.add(columnClause.getOriginalCaseValue());</span>
<span class="nocode"><a name="2174">2174: </a></span>        }
<span class="nocode"><a name="2175">2175: </a></span>
<span class="nocode"><a name="2176">2176: </a></span><span style="background-color: #ffffcc">        ResultSet rs = doQuery(sql, params);</span>
<span class="nocode"><a name="2177">2177: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="2178">2178: </a></span>        
<span class="nocode"><a name="2179">2179: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="2180">2180: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="2181">2181: </a></span>            params.clear();
<span class="nocode"><a name="2182">2182: </a></span>            if (!procedureClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2183">2183: </a></span>                params.add(procedureClause.getValue());
<span class="nocode"><a name="2184">2184: </a></span>            }
<span class="nocode"><a name="2185">2185: </a></span>            if (!columnClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2186">2186: </a></span>                params.add(columnClause.getValue());
<span class="nocode"><a name="2187">2187: </a></span>            }
<span class="nocode"><a name="2188">2188: </a></span>            
<span class="nocode"><a name="2189">2189: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="2190">2190: </a></span>            
<span class="nocode"><a name="2191">2191: </a></span>            // if nothing found, return an empty result set
<span class="nocode"><a name="2192">2192: </a></span>            if (!rs.next())
<span class="nocode"><a name="2193">2193: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2194">2194: </a></span>        }
<span class="nocode"><a name="2195">2195: </a></span>
<span class="nocode"><a name="2196">2196: </a></span>        do {
<span class="nocode"><a name="2197">2197: </a></span>            byte[][] row = new byte[20][];
<span class="nocode"><a name="2198">2198: </a></span>            row[0] = null;
<span class="nocode"><a name="2199">2199: </a></span>            row[1] = null;
<span class="nocode"><a name="2200">2200: </a></span>            row[2] = getBytes(rs.getString(&quot;PROCEDURE_NAME&quot;));
<span class="nocode"><a name="2201">2201: </a></span>            row[3] = getBytes(rs.getString(&quot;COLUMN_NAME&quot;));
<span class="nocode"><a name="2202">2202: </a></span>
<span class="nocode"><a name="2203">2203: </a></span>            short columnType = rs.getShort(&quot;COLUMN_TYPE&quot;);
<span class="nocode"><a name="2204">2204: </a></span>            // TODO: Unsure if procedureColumnOut is correct, maybe procedureColumnResult, or need ODS dependent use of RDB$PROCEDURE_TYPE to decide on selectable or executable?
<span class="nocode"><a name="2205">2205: </a></span>            // TODO: ResultSet columns should not be first according to JDBC 4.1 description
<span class="nocode"><a name="2206">2206: </a></span>            row[4] = (columnType == 0) ? xsqlvars[0].encodeShort((short)procedureColumnIn) : xsqlvars[0].encodeShort((short)procedureColumnOut);
<span class="nocode"><a name="2207">2207: </a></span>
<span class="nocode"><a name="2208">2208: </a></span>            short fieldType = rs.getShort(&quot;FIELD_TYPE&quot;);
<span class="nocode"><a name="2209">2209: </a></span>            short fieldSubType = rs.getShort(&quot;FIELD_SUB_TYPE&quot;);
<span class="nocode"><a name="2210">2210: </a></span>            short fieldScale = rs.getShort(&quot;FIELD_SCALE&quot;);
<span class="nocode"><a name="2211">2211: </a></span>            int dataType = getDataType(fieldType, fieldSubType, fieldScale);
<span class="nocode"><a name="2212">2212: </a></span>
<span class="nocode"><a name="2213">2213: </a></span>            row[5] = xsqlvars[0].encodeInt(dataType);
<span class="nocode"><a name="2214">2214: </a></span>            row[6] = getBytes(getDataTypeName(fieldType, fieldSubType, fieldScale));
<span class="nocode"><a name="2215">2215: </a></span>            
<span class="nocode"><a name="2216">2216: </a></span>            row[8] = xsqlvars[0].encodeInt(rs.getShort(&quot;FIELD_LENGTH&quot;));
<span class="nocode"><a name="2217">2217: </a></span>            
<span class="nocode"><a name="2218">2218: </a></span>            // Defaults: some are overridden in the switch
<span class="nocode"><a name="2219">2219: </a></span>            row[7] = null;
<span class="nocode"><a name="2220">2220: </a></span>            row[9] = null;
<span class="nocode"><a name="2221">2221: </a></span>            row[10] = null;
<span class="nocode"><a name="2222">2222: </a></span>            row[16] = null;
<span class="nocode"><a name="2223">2223: </a></span>            switch (dataType){
<span class="nocode"><a name="2224">2224: </a></span>                case Types.DECIMAL:
<span class="nocode"><a name="2225">2225: </a></span>                case Types.NUMERIC:
<span class="nocode"><a name="2226">2226: </a></span>                   row[7] = xsqlvars[0].encodeInt(rs.getShort(&quot;FIELD_PRECISION&quot;));
<span class="nocode"><a name="2227">2227: </a></span>                   row[9] = xsqlvars[0].encodeShort((short)(fieldScale * (-1)));
<span class="nocode"><a name="2228">2228: </a></span>                   row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2229">2229: </a></span>                   break;
<span class="nocode"><a name="2230">2230: </a></span>                case Types.CHAR:
<span class="nocode"><a name="2231">2231: </a></span>                case Types.VARCHAR:
<span class="nocode"><a name="2232">2232: </a></span>                   short charLen = rs.getShort(&quot;CHAR_LEN&quot;);
<span class="nocode"><a name="2233">2233: </a></span>                   if (!rs.wasNull()) {
<span class="nocode"><a name="2234">2234: </a></span>                       row[7] = xsqlvars[0].encodeInt(charLen);
<span class="nocode"><a name="2235">2235: </a></span>                   } else {
<span class="nocode"><a name="2236">2236: </a></span>                       row[7] = row[8];
<span class="nocode"><a name="2237">2237: </a></span>                   }
<span class="nocode"><a name="2238">2238: </a></span>                   row[16] = row[8];
<span class="nocode"><a name="2239">2239: </a></span>                   break;
<span class="nocode"><a name="2240">2240: </a></span>                case Types.FLOAT:
<span class="nocode"><a name="2241">2241: </a></span>                   row[7] = xsqlvars[0].encodeInt(7);
<span class="nocode"><a name="2242">2242: </a></span>                   row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2243">2243: </a></span>                   break;
<span class="nocode"><a name="2244">2244: </a></span>                case Types.DOUBLE:
<span class="nocode"><a name="2245">2245: </a></span>                   row[7] = xsqlvars[0].encodeInt(15);
<span class="nocode"><a name="2246">2246: </a></span>                   row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2247">2247: </a></span>                   break;
<span class="nocode"><a name="2248">2248: </a></span>                case Types.BIGINT:
<span class="nocode"><a name="2249">2249: </a></span>                    row[7] = xsqlvars[0].encodeInt(19);
<span class="nocode"><a name="2250">2250: </a></span>                    row[9] = xsqlvars[0].encodeShort((short)0);
<span class="nocode"><a name="2251">2251: </a></span>                    row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2252">2252: </a></span>                    break;
<span class="nocode"><a name="2253">2253: </a></span>                case Types.INTEGER:
<span class="nocode"><a name="2254">2254: </a></span>                   row[7] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2255">2255: </a></span>                   row[9] = xsqlvars[0].encodeShort((short)0);
<span class="nocode"><a name="2256">2256: </a></span>                   row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2257">2257: </a></span>                   break;
<span class="nocode"><a name="2258">2258: </a></span>                case Types.SMALLINT:
<span class="nocode"><a name="2259">2259: </a></span>                   row[7] = xsqlvars[0].encodeInt(5);
<span class="nocode"><a name="2260">2260: </a></span>                   row[9] = xsqlvars[0].encodeShort((short)0);
<span class="nocode"><a name="2261">2261: </a></span>                   row[10] = xsqlvars[0].encodeShort((short)10);
<span class="nocode"><a name="2262">2262: </a></span>                   break;
<span class="nocode"><a name="2263">2263: </a></span>                case Types.DATE:
<span class="nocode"><a name="2264">2264: </a></span>                   row[7] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2265">2265: </a></span>                   break;
<span class="nocode"><a name="2266">2266: </a></span>                case Types.TIME:
<span class="nocode"><a name="2267">2267: </a></span>                   row[7] = xsqlvars[0].encodeInt(8);
<span class="nocode"><a name="2268">2268: </a></span>                   break;
<span class="nocode"><a name="2269">2269: </a></span>                case Types.TIMESTAMP:
<span class="nocode"><a name="2270">2270: </a></span>                   row[7] = xsqlvars[0].encodeInt(19);
<span class="nocode"><a name="2271">2271: </a></span>                   break;
<span class="nocode"><a name="2272">2272: </a></span>                default:
<span class="nocode"><a name="2273">2273: </a></span>                   row[7] = null;
<span class="nocode"><a name="2274">2274: </a></span>            }
<span class="nocode"><a name="2275">2275: </a></span>            
<span class="nocode"><a name="2276">2276: </a></span>            // TODO: Find out what the difference is with NULL_FLAG in RDB$PROCEDURE_PARAMETERS (might be ODS dependent) 
<span class="nocode"><a name="2277">2277: </a></span>            short nullFlag = rs.getShort(&quot;NULL_FLAG&quot;);
<span class="nocode"><a name="2278">2278: </a></span>            row[11] = (nullFlag == 1) ? xsqlvars[0].encodeShort((short)procedureNoNulls) :
<span class="nocode"><a name="2279">2279: </a></span>                                        xsqlvars[0].encodeShort((short)procedureNullable);
<span class="nocode"><a name="2280">2280: </a></span>
<span class="nocode"><a name="2281">2281: </a></span>            String remarks = rs.getString(&quot;REMARKS&quot;);
<span class="nocode"><a name="2282">2282: </a></span>            row[12] = getBytes(remarks);
<span class="nocode"><a name="2283">2283: </a></span>            if (remarks != null &amp;&amp; remarks.length() &gt; xsqlvars[12].sqllen)
<span class="nocode"><a name="2284">2284: </a></span>                xsqlvars[12].sqllen = remarks.length();
<span class="nocode"><a name="2285">2285: </a></span>            // TODO: Need to write ODS version dependent method to retrieve some of the info
<span class="nocode"><a name="2286">2286: </a></span>            row[13] = null; // TODO From 2.0 defaults for procedure parameters
<span class="nocode"><a name="2287">2287: </a></span>            row[14] = null;
<span class="nocode"><a name="2288">2288: </a></span>            row[15] = null;
<span class="nocode"><a name="2289">2289: </a></span>            // TODO: Find correct value for ORDINAL_POSITION (+ order of columns and intent, see JDBC-229)
<span class="nocode"><a name="2290">2290: </a></span>            row[17] = xsqlvars[0].encodeInt(rs.getInt(&quot;PARAMETER_NUMBER&quot;));
<span class="nocode"><a name="2291">2291: </a></span>            // TODO: Find out if there is a conceptual difference with NULLABLE (idx 11)
<span class="nocode"><a name="2292">2292: </a></span>            row[18] = (nullFlag == 1) ? getBytes(&quot;NO&quot;) : getBytes(&quot;YES&quot;);
<span class="nocode"><a name="2293">2293: </a></span>            row[19] = row[2];
<span class="nocode"><a name="2294">2294: </a></span>
<span class="nocode"><a name="2295">2295: </a></span>            rows.add(row);
<span class="nocode"><a name="2296">2296: </a></span>        } while (rs.next());
<span class="nocode"><a name="2297">2297: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2298">2298: </a></span>    }
<span class="nocode"><a name="2299">2299: </a></span>
<span class="nocode"><a name="2300">2300: </a></span>    // TODO: Include GLOBAL TEMPORARY
<span class="nocode"><a name="2301">2301: </a></span>    public static final String TABLE = &quot;TABLE&quot;;
<span class="nocode"><a name="2302">2302: </a></span>    public static final String SYSTEM_TABLE = &quot;SYSTEM TABLE&quot;;
<span class="nocode"><a name="2303">2303: </a></span>    public static final String VIEW = &quot;VIEW&quot;;
<span class="nocode"><a name="2304">2304: </a></span>    public static final String[] ALL_TYPES = {TABLE, SYSTEM_TABLE, VIEW};
<span class="nocode"><a name="2305">2305: </a></span>    
<span class="nocode"><a name="2306">2306: </a></span>    private static final String TABLE_COLUMNS_FORMAT =
<span class="nocode"><a name="2307">2307: </a></span>              &quot; select cast(null as varchar(31)) as TABLE_CAT,&quot;
<span class="nocode"><a name="2308">2308: </a></span>            + &quot; cast(null as varchar(31)) as TABLE_SCHEM,&quot;
<span class="nocode"><a name="2309">2309: </a></span>            + &quot; RDB$RELATION_NAME as TABLE_NAME,&quot;
<span class="nocode"><a name="2310">2310: </a></span>            + &quot; cast('%s' as varchar(31)) as TABLE_TYPE,&quot;
<span class="nocode"><a name="2311">2311: </a></span>            + &quot; RDB$DESCRIPTION as REMARKS,&quot;
<span class="nocode"><a name="2312">2312: </a></span>            + &quot; cast(null as varchar(31)) as TYPE_CAT,&quot;
<span class="nocode"><a name="2313">2313: </a></span>            + &quot; cast(null as varchar(31)) as TYPE_SCHEM,&quot;
<span class="nocode"><a name="2314">2314: </a></span>            + &quot; cast(null as varchar(31)) as TYPE_NAME,&quot;
<span class="nocode"><a name="2315">2315: </a></span>            + &quot; cast(null as varchar(31)) as SELF_REFERENCING_COL_NAME,&quot;
<span class="nocode"><a name="2316">2316: </a></span>            + &quot; cast(null as varchar(31)) as REF_GENERATION,&quot;
<span class="nocode"><a name="2317">2317: </a></span>            + &quot; RDB$OWNER_NAME as OWNER_NAME&quot;
<span class="nocode"><a name="2318">2318: </a></span>            + &quot; from RDB$RELATIONS&quot;;
<span class="nocode"><a name="2319">2319: </a></span>    
<span class="nocode"><a name="2320">2320: </a></span>    private static final String TABLE_COLUMNS_SYSTEM =
<span class="nocode"><a name="2321">2321: </a></span>            String.format(TABLE_COLUMNS_FORMAT, SYSTEM_TABLE);
<span class="nocode"><a name="2322">2322: </a></span>    
<span class="nocode"><a name="2323">2323: </a></span>    private static final String TABLE_COLUMNS_NORMAL =
<span class="nocode"><a name="2324">2324: </a></span>            String.format(TABLE_COLUMNS_FORMAT, TABLE);
<span class="nocode"><a name="2325">2325: </a></span>    
<span class="nocode"><a name="2326">2326: </a></span>    private static final String TABLE_COLUMNS_VIEW =
<span class="nocode"><a name="2327">2327: </a></span>            String.format(TABLE_COLUMNS_FORMAT, VIEW);
<span class="nocode"><a name="2328">2328: </a></span>
<span class="nocode"><a name="2329">2329: </a></span>    private static final String GET_TABLES_ALL = 
<span class="nocode"><a name="2330">2330: </a></span>          TABLE_COLUMNS_SYSTEM
<span class="nocode"><a name="2331">2331: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 1 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2332">2332: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2333">2333: </a></span>        + TABLE_COLUMNS_NORMAL
<span class="nocode"><a name="2334">2334: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 0 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2335">2335: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2336">2336: </a></span>        + TABLE_COLUMNS_VIEW
<span class="nocode"><a name="2337">2337: </a></span>        + &quot; where ? = 'T' and RDB$VIEW_SOURCE is not null &quot;
<span class="nocode"><a name="2338">2338: </a></span>        + &quot; order by 3 &quot;;
<span class="nocode"><a name="2339">2339: </a></span>
<span class="nocode"><a name="2340">2340: </a></span>    private static final String GET_TABLES_EXACT = 
<span class="nocode"><a name="2341">2341: </a></span>          TABLE_COLUMNS_SYSTEM
<span class="nocode"><a name="2342">2342: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 1 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2343">2343: </a></span>        + &quot; and ? = RDB$RELATION_NAME&quot;
<span class="nocode"><a name="2344">2344: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2345">2345: </a></span>        + TABLE_COLUMNS_NORMAL
<span class="nocode"><a name="2346">2346: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 0 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2347">2347: </a></span>        + &quot; and ? = RDB$RELATION_NAME&quot;
<span class="nocode"><a name="2348">2348: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2349">2349: </a></span>        + TABLE_COLUMNS_VIEW
<span class="nocode"><a name="2350">2350: </a></span>        + &quot; where ? = 'T' and RDB$VIEW_SOURCE is not null&quot;
<span class="nocode"><a name="2351">2351: </a></span>        + &quot; and ? = RDB$RELATION_NAME&quot;;
<span class="nocode"><a name="2352">2352: </a></span>
<span class="nocode"><a name="2353">2353: </a></span>    private static final String GET_TABLES_LIKE = 
<span class="nocode"><a name="2354">2354: </a></span>          TABLE_COLUMNS_SYSTEM
<span class="nocode"><a name="2355">2355: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 1 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2356">2356: </a></span>        + &quot; and RDB$RELATION_NAME || '&quot; + SPACES + &quot;' like ? escape '\\'&quot;
<span class="nocode"><a name="2357">2357: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2358">2358: </a></span>        + TABLE_COLUMNS_NORMAL
<span class="nocode"><a name="2359">2359: </a></span>        + &quot; where ? = 'T' and RDB$SYSTEM_FLAG = 0 and RDB$VIEW_SOURCE is null&quot;
<span class="nocode"><a name="2360">2360: </a></span>        + &quot; and RDB$RELATION_NAME || '&quot; + SPACES + &quot;' like ? escape '\\'&quot;
<span class="nocode"><a name="2361">2361: </a></span>        + &quot; union&quot;
<span class="nocode"><a name="2362">2362: </a></span>        + TABLE_COLUMNS_VIEW
<span class="nocode"><a name="2363">2363: </a></span>        + &quot; where ? = 'T' and RDB$VIEW_SOURCE is not null&quot;
<span class="nocode"><a name="2364">2364: </a></span>        + &quot; and RDB$RELATION_NAME || '&quot; + SPACES + &quot;' like ? escape '\\' &quot;
<span class="nocode"><a name="2365">2365: </a></span>        + &quot; order by 3 &quot;;
<span class="nocode"><a name="2366">2366: </a></span>
<span class="nocode"><a name="2367">2367: </a></span>    /**
<span class="nocode"><a name="2368">2368: </a></span>     * Retrieves a description of the tables available in the given catalog.
<span class="nocode"><a name="2369">2369: </a></span>     * Only table descriptions matching the catalog, schema, table
<span class="nocode"><a name="2370">2370: </a></span>     * name and type criteria are returned.  They are ordered by
<span class="nocode"><a name="2371">2371: </a></span>     * &lt;code&gt;TABLE_TYPE&lt;/code&gt;, &lt;code&gt;TABLE_CAT&lt;/code&gt;, 
<span class="nocode"><a name="2372">2372: </a></span>     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt; and &lt;code&gt;TABLE_NAME&lt;/code&gt;.
<span class="nocode"><a name="2373">2373: </a></span>     * &lt;P&gt;
<span class="nocode"><a name="2374">2374: </a></span>     * Each table description has the following columns:
<span class="nocode"><a name="2375">2375: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="2376">2376: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2377">2377: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2378">2378: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="2379">2379: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String =&gt; table type.  Typical types are &quot;TABLE&quot;,
<span class="nocode"><a name="2380">2380: </a></span>     *          &quot;VIEW&quot;, &quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;, 
<span class="nocode"><a name="2381">2381: </a></span>     *          &quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.
<span class="nocode"><a name="2382">2382: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; explanatory comment on the table
<span class="nocode"><a name="2383">2383: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String =&gt; the types catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2384">2384: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String =&gt; the types schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2385">2385: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; type name (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2386">2386: </a></span>     *  &lt;LI&gt;&lt;B&gt;SELF_REFERENCING_COL_NAME&lt;/B&gt; String =&gt; name of the designated 
<span class="nocode"><a name="2387">2387: </a></span>     *                  &quot;identifier&quot; column of a typed table (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2388">2388: </a></span>     *  &lt;LI&gt;&lt;B&gt;REF_GENERATION&lt;/B&gt; String =&gt; specifies how values in 
<span class="nocode"><a name="2389">2389: </a></span>     *                  SELF_REFERENCING_COL_NAME are created. Values are
<span class="nocode"><a name="2390">2390: </a></span>     *                  &quot;SYSTEM&quot;, &quot;USER&quot;, &quot;DERIVED&quot;. (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2391">2391: </a></span>     *  &lt;LI&gt;&lt;B&gt;OWNER_NAME&lt;/B&gt; String =&gt; Username of the owner of the table (Jaybird-specific) 
<span class="nocode"><a name="2392">2392: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2393">2393: </a></span>     *
<span class="nocode"><a name="2394">2394: </a></span>     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; Some databases may not return information for
<span class="nocode"><a name="2395">2395: </a></span>     * all tables.
<span class="nocode"><a name="2396">2396: </a></span>     *
<span class="nocode"><a name="2397">2397: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="2398">2398: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="2399">2399: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="2400">2400: </a></span>     *        the search
<span class="nocode"><a name="2401">2401: </a></span>     * @param schemaPattern a schema name pattern; must match the schema name
<span class="nocode"><a name="2402">2402: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="2403">2403: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="2404">2404: </a></span>     *        the search
<span class="nocode"><a name="2405">2405: </a></span>     * @param tableNamePattern a table name pattern; must match the
<span class="nocode"><a name="2406">2406: </a></span>     *        table name as it is stored in the database 
<span class="nocode"><a name="2407">2407: </a></span>     * @param types a list of table types, which must be from the list of table types 
<span class="nocode"><a name="2408">2408: </a></span>     *         returned from {@link #getTableTypes},to include; &lt;code&gt;null&lt;/code&gt; returns
<span class="nocode"><a name="2409">2409: </a></span>     * all types
<span class="nocode"><a name="2410">2410: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a table description
<span class="nocode"><a name="2411">2411: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2412">2412: </a></span>     * @see #getSearchStringEscape 
<span class="nocode"><a name="2413">2413: </a></span>     */
<span class="nocode"><a name="2414">2414: </a></span>    public ResultSet getTables(String catalog, String schemaPattern,
<span class="nocode"><a name="2415">2415: </a></span>        String tableNamePattern, String types[]) throws SQLException {
<span class="nocode"><a name="2416">2416: </a></span>
<span class="nocode"><a name="2417">2417: </a></span>        if (tableNamePattern == null || &quot;&quot;.equals(tableNamePattern))
<span class="nocode"><a name="2418">2418: </a></span>            tableNamePattern = &quot;%&quot;;
<span class="nocode"><a name="2419">2419: </a></span>
<span class="nocode"><a name="2420">2420: </a></span>        checkCatalogAndSchema(catalog, schemaPattern);
<span class="nocode"><a name="2421">2421: </a></span>        if (types == null) {
<span class="nocode"><a name="2422">2422: </a></span>            types = ALL_TYPES;
<span class="nocode"><a name="2423">2423: </a></span>        }
<span class="nocode"><a name="2424">2424: </a></span>        String sql;
<span class="nocode"><a name="2425">2425: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="2426">2426: </a></span>        if (isAllCondition(tableNamePattern)) {
<span class="nocode"><a name="2427">2427: </a></span>            sql = GET_TABLES_ALL;
<span class="nocode"><a name="2428">2428: </a></span>            params.add(getWantsSystemTables(types));
<span class="nocode"><a name="2429">2429: </a></span>            params.add(getWantsTables(types));
<span class="nocode"><a name="2430">2430: </a></span>            params.add(getWantsViews(types));
<span class="nocode"><a name="2431">2431: </a></span>        }
<span class="nocode"><a name="2432">2432: </a></span>        else if (hasNoWildcards(tableNamePattern)) {
<span class="nocode"><a name="2433">2433: </a></span>            tableNamePattern = stripQuotes(stripEscape(tableNamePattern), true);
<span class="nocode"><a name="2434">2434: </a></span>            sql = GET_TABLES_EXACT;
<span class="nocode"><a name="2435">2435: </a></span>            params.add(getWantsSystemTables(types));
<span class="nocode"><a name="2436">2436: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2437">2437: </a></span>            params.add(getWantsTables(types));
<span class="nocode"><a name="2438">2438: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2439">2439: </a></span>            params.add(getWantsViews(types));
<span class="nocode"><a name="2440">2440: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2441">2441: </a></span>        }
<span class="nocode"><a name="2442">2442: </a></span>        else {
<span class="nocode"><a name="2443">2443: </a></span>            // TODO Usages of 1) uppercase and 2) SPACES + % might be wrong
<span class="nocode"><a name="2444">2444: </a></span>            tableNamePattern = stripQuotes(tableNamePattern, true) + SPACES + &quot;%&quot;;
<span class="nocode"><a name="2445">2445: </a></span>            sql = GET_TABLES_LIKE;
<span class="nocode"><a name="2446">2446: </a></span>            params.add(getWantsSystemTables(types));
<span class="nocode"><a name="2447">2447: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2448">2448: </a></span>            params.add(getWantsTables(types));
<span class="nocode"><a name="2449">2449: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2450">2450: </a></span>            params.add(getWantsViews(types));
<span class="nocode"><a name="2451">2451: </a></span>            params.add(tableNamePattern);
<span class="nocode"><a name="2452">2452: </a></span>        }
<span class="nocode"><a name="2453">2453: </a></span>        return doQuery(sql, params);
<span class="nocode"><a name="2454">2454: </a></span>    }
<span class="nocode"><a name="2455">2455: </a></span>
<span class="nocode"><a name="2456">2456: </a></span>    /**
<span class="nocode"><a name="2457">2457: </a></span>     * Gets the schema names available in this database.  The results
<span class="nocode"><a name="2458">2458: </a></span>     * are ordered by schema name.
<span class="nocode"><a name="2459">2459: </a></span>     *
<span class="nocode"><a name="2460">2460: </a></span>     * &lt;P&gt;The schema columns are:
<span class="nocode"><a name="2461">2461: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="2462">2462: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; schema name
<span class="nocode"><a name="2463">2463: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CATALOG&lt;/B&gt; String =&gt; catalog name (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2464">2464: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2465">2465: </a></span>     *
<span class="nocode"><a name="2466">2466: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row has a single String column that is a
<span class="nocode"><a name="2467">2467: </a></span>     * schema name
<span class="nocode"><a name="2468">2468: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2469">2469: </a></span>     */
<span class="nocode"><a name="2470">2470: </a></span>    public  ResultSet getSchemas() throws SQLException {
<span class="nocode"><a name="2471">2471: </a></span>        return getSchemas(null, null);
<span class="nocode"><a name="2472">2472: </a></span>    }
<span class="nocode"><a name="2473">2473: </a></span>
<span class="nocode"><a name="2474">2474: </a></span>    /**
<span class="nocode"><a name="2475">2475: </a></span>     * Gets the catalog names available in this database.  The results
<span class="nocode"><a name="2476">2476: </a></span>     * are ordered by catalog name.
<span class="nocode"><a name="2477">2477: </a></span>     *
<span class="nocode"><a name="2478">2478: </a></span>     * &lt;P&gt;The catalog column is:
<span class="nocode"><a name="2479">2479: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="2480">2480: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; catalog name
<span class="nocode"><a name="2481">2481: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2482">2482: </a></span>     *
<span class="nocode"><a name="2483">2483: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row has a single String column that is a
<span class="nocode"><a name="2484">2484: </a></span>     * catalog name
<span class="nocode"><a name="2485">2485: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2486">2486: </a></span>     */
<span class="nocode"><a name="2487">2487: </a></span>    public  ResultSet getCatalogs() throws SQLException {
<span class="nocode"><a name="2488">2488: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[1];
<span class="nocode"><a name="2489">2489: </a></span>
<span class="nocode"><a name="2490">2490: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="2491">2491: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2492">2492: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="2493">2493: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="2494">2494: </a></span>        xsqlvars[0].relname = &quot;TABLECATALOGS&quot;;
<span class="nocode"><a name="2495">2495: </a></span>
<span class="nocode"><a name="2496">2496: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="2497">2497: </a></span>
<span class="nocode"><a name="2498">2498: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2499">2499: </a></span>    }
<span class="nocode"><a name="2500">2500: </a></span>
<span class="nocode"><a name="2501">2501: </a></span>    /**
<span class="nocode"><a name="2502">2502: </a></span>     * Gets the table types available in this database.  The results
<span class="nocode"><a name="2503">2503: </a></span>     * are ordered by table type.
<span class="nocode"><a name="2504">2504: </a></span>     *
<span class="nocode"><a name="2505">2505: </a></span>     * &lt;P&gt;The table type is:
<span class="nocode"><a name="2506">2506: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="2507">2507: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_TYPE&lt;/B&gt; String =&gt; table type.  Typical types are &quot;TABLE&quot;,
<span class="nocode"><a name="2508">2508: </a></span>     *          &quot;VIEW&quot;, &quot;SYSTEM TABLE&quot;, &quot;GLOBAL TEMPORARY&quot;,
<span class="nocode"><a name="2509">2509: </a></span>     *          &quot;LOCAL TEMPORARY&quot;, &quot;ALIAS&quot;, &quot;SYNONYM&quot;.
<span class="nocode"><a name="2510">2510: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2511">2511: </a></span>     *
<span class="nocode"><a name="2512">2512: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row has a single String column that is a
<span class="nocode"><a name="2513">2513: </a></span>     * table type
<span class="nocode"><a name="2514">2514: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2515">2515: </a></span>     */
<span class="nocode"><a name="2516">2516: </a></span>    public  ResultSet getTableTypes() throws SQLException {
<span class="nocode"><a name="2517">2517: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[1];
<span class="nocode"><a name="2518">2518: </a></span>
<span class="nocode"><a name="2519">2519: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="2520">2520: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2521">2521: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="2522">2522: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_TYPE&quot;;
<span class="nocode"><a name="2523">2523: </a></span>        xsqlvars[0].relname = &quot;TABLETYPES&quot;;
<span class="nocode"><a name="2524">2524: </a></span>
<span class="nocode"><a name="2525">2525: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;(ALL_TYPES.length);
<span class="nocode"><a name="2526">2526: </a></span>        for(int i = 0; i &lt; ALL_TYPES.length; i++)
<span class="nocode"><a name="2527">2527: </a></span>          rows.add(new byte[][] {getBytes(ALL_TYPES[i])});
<span class="nocode"><a name="2528">2528: </a></span>
<span class="nocode"><a name="2529">2529: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2530">2530: </a></span>    }
<span class="nocode"><a name="2531">2531: </a></span>
<span class="nocode"><a name="2532">2532: </a></span>    private static final String GET_COLUMNS_START = 
<span class="nocode"><a name="2533">2533: </a></span>            &quot;SELECT   RF.RDB$RELATION_NAME  AS RELATION_NAME   ,&quot; + 
<span class="nocode"><a name="2534">2534: </a></span>    		&quot;         RF.RDB$FIELD_NAME     AS FIELD_NAME      ,&quot; + 
<span class="nocode"><a name="2535">2535: </a></span>    		&quot;         F.RDB$FIELD_TYPE      AS FIELD_TYPE      ,&quot; + 
<span class="nocode"><a name="2536">2536: </a></span>    		&quot;         F.RDB$FIELD_SUB_TYPE  AS FIELD_SUB_TYPE  ,&quot; + 
<span class="nocode"><a name="2537">2537: </a></span>    		&quot;         F.RDB$FIELD_PRECISION AS FIELD_PRECISION ,&quot; + 
<span class="nocode"><a name="2538">2538: </a></span>    		&quot;         F.RDB$FIELD_SCALE     AS FIELD_SCALE     ,&quot; + 
<span class="nocode"><a name="2539">2539: </a></span>    		&quot;         F.RDB$FIELD_LENGTH    AS FIELD_LENGTH    ,&quot; + 
<span class="nocode"><a name="2540">2540: </a></span>    		&quot;         F.RDB$CHARACTER_LENGTH AS CHAR_LEN       ,&quot; + 
<span class="nocode"><a name="2541">2541: </a></span>    		&quot;         RF.RDB$DESCRIPTION    AS REMARKS         ,&quot; + 
<span class="nocode"><a name="2542">2542: </a></span>    		&quot;         RF.RDB$DEFAULT_SOURCE AS DEFAULT_SOURCE  ,&quot; + 
<span class="nocode"><a name="2543">2543: </a></span>    		&quot;         RF.RDB$FIELD_POSITION + 1 AS FIELD_POSITION  ,&quot; + 
<span class="nocode"><a name="2544">2544: </a></span>    		&quot;         RF.RDB$NULL_FLAG      AS NULL_FLAG       ,&quot; + 
<span class="nocode"><a name="2545">2545: </a></span>    		&quot;         F.RDB$NULL_FLAG       AS SOURCE_NULL_FLAG,&quot; +
<span class="nocode"><a name="2546">2546: </a></span>    		&quot;         F.RDB$COMPUTED_BLR    AS COMPUTED_BLR &quot; +
<span class="nocode"><a name="2547">2547: </a></span>    		&quot;FROM     RDB$RELATION_FIELDS RF,&quot; + 
<span class="nocode"><a name="2548">2548: </a></span>    		&quot;         RDB$FIELDS F &quot; + 
<span class="nocode"><a name="2549">2549: </a></span>    		&quot;WHERE &quot;;
<span class="nocode"><a name="2550">2550: </a></span>
<span class="nocode"><a name="2551">2551: </a></span>    public static final String GET_COLUMNS_END = &quot; RF.RDB$FIELD_SOURCE = F.RDB$FIELD_NAME &quot; +
<span class="nocode"><a name="2552">2552: </a></span>        &quot;order by 1, 11&quot;;
<span class="nocode"><a name="2553">2553: </a></span>
<span class="nocode"><a name="2554">2554: </a></span>    /**
<span class="nocode"><a name="2555">2555: </a></span>     * Retrieves a description of table columns available in
<span class="nocode"><a name="2556">2556: </a></span>     * the specified catalog.
<span class="nocode"><a name="2557">2557: </a></span>     *
<span class="nocode"><a name="2558">2558: </a></span>     * &lt;P&gt;Only column descriptions matching the catalog, schema, table
<span class="nocode"><a name="2559">2559: </a></span>     * and column name criteria are returned.  They are ordered by
<span class="nocode"><a name="2560">2560: </a></span>     * &lt;code&gt;TABLE_CAT&lt;/code&gt;,&lt;code&gt;TABLE_SCHEM&lt;/code&gt;,
<span class="nocode"><a name="2561">2561: </a></span>     * &lt;code&gt;TABLE_NAME&lt;/code&gt;, and &lt;code&gt;ORDINAL_POSITION&lt;/code&gt;.
<span class="nocode"><a name="2562">2562: </a></span>     *
<span class="nocode"><a name="2563">2563: </a></span>     * &lt;P&gt;Each column description has the following columns:
<span class="nocode"><a name="2564">2564: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="2565">2565: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2566">2566: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2567">2567: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="2568">2568: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name
<span class="nocode"><a name="2569">2569: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&gt; SQL type from java.sql.Types
<span class="nocode"><a name="2570">2570: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; Data source dependent type name,
<span class="nocode"><a name="2571">2571: </a></span>     *  for a UDT the type name is fully qualified
<span class="nocode"><a name="2572">2572: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&gt; column size.
<span class="nocode"><a name="2573">2573: </a></span>     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; is not used.
<span class="nocode"><a name="2574">2574: </a></span>     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; int =&gt; the number of fractional digits. Null is returned for data types where
<span class="nocode"><a name="2575">2575: </a></span>     * DECIMAL_DIGITS is not applicable.
<span class="nocode"><a name="2576">2576: </a></span>     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int =&gt; Radix (typically either 10 or 2)
<span class="nocode"><a name="2577">2577: </a></span>     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; int =&gt; is NULL allowed.
<span class="nocode"><a name="2578">2578: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="2579">2579: </a></span>     *      &lt;LI&gt; columnNoNulls - might not allow &lt;code&gt;NULL&lt;/code&gt; values
<span class="nocode"><a name="2580">2580: </a></span>     *      &lt;LI&gt; columnNullable - definitely allows &lt;code&gt;NULL&lt;/code&gt; values
<span class="nocode"><a name="2581">2581: </a></span>     *      &lt;LI&gt; columnNullableUnknown - nullability unknown
<span class="nocode"><a name="2582">2582: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="2583">2583: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; comment describing column (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2584">2584: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_DEF&lt;/B&gt; String =&gt; default value for the column, which should be interpreted as a string when the value is enclosed in single quotes (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="2585">2585: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int =&gt; unused
<span class="nocode"><a name="2586">2586: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int =&gt; unused
<span class="nocode"><a name="2587">2587: </a></span>     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int =&gt; for char types the
<span class="nocode"><a name="2588">2588: </a></span>     *       maximum number of bytes in the column
<span class="nocode"><a name="2589">2589: </a></span>     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int =&gt; index of column in table
<span class="nocode"><a name="2590">2590: </a></span>     *      (starting at 1)
<span class="nocode"><a name="2591">2591: </a></span>     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  =&gt; ISO rules are used to determine the nullability for a column.
<span class="nocode"><a name="2592">2592: </a></span>     *       &lt;UL&gt;
<span class="nocode"><a name="2593">2593: </a></span>     *       &lt;LI&gt; YES           --- if the column can include NULLs
<span class="nocode"><a name="2594">2594: </a></span>     *       &lt;LI&gt; NO            --- if the column cannot include NULLs
<span class="nocode"><a name="2595">2595: </a></span>     *       &lt;LI&gt; empty string  --- if the nullability for the
<span class="nocode"><a name="2596">2596: </a></span>     * column is unknown
<span class="nocode"><a name="2597">2597: </a></span>     *       &lt;/UL&gt;
<span class="nocode"><a name="2598">2598: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCOPE_CATALOG&lt;/B&gt; String =&gt; catalog of table that is the scope
<span class="nocode"><a name="2599">2599: </a></span>     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE isn't REF)
<span class="nocode"><a name="2600">2600: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCOPE_SCHEMA&lt;/B&gt; String =&gt; schema of table that is the scope
<span class="nocode"><a name="2601">2601: </a></span>     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF)
<span class="nocode"><a name="2602">2602: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCOPE_TABLE&lt;/B&gt; String =&gt; table name that this the scope
<span class="nocode"><a name="2603">2603: </a></span>     *      of a reference attribute (&lt;code&gt;null&lt;/code&gt; if the DATA_TYPE isn't REF)
<span class="nocode"><a name="2604">2604: </a></span>     *  &lt;LI&gt;&lt;B&gt;SOURCE_DATA_TYPE&lt;/B&gt; short =&gt; source type of a distinct type or user-generated
<span class="nocode"><a name="2605">2605: </a></span>     *      Ref type, SQL type from java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE
<span class="nocode"><a name="2606">2606: </a></span>     *      isn't DISTINCT or user-generated REF)
<span class="nocode"><a name="2607">2607: </a></span>     *   &lt;LI&gt;&lt;B&gt;IS_AUTOINCREMENT&lt;/B&gt; String  =&gt; Indicates whether this column is auto incremented
<span class="nocode"><a name="2608">2608: </a></span>     *       &lt;UL&gt;
<span class="nocode"><a name="2609">2609: </a></span>     *       &lt;LI&gt; YES           --- if the column is auto incremented
<span class="nocode"><a name="2610">2610: </a></span>     *       &lt;LI&gt; NO            --- if the column is not auto incremented
<span class="nocode"><a name="2611">2611: </a></span>     *       &lt;LI&gt; empty string  --- if it cannot be determined whether the column is auto incremented
<span class="nocode"><a name="2612">2612: </a></span>     *       &lt;/UL&gt;
<span class="nocode"><a name="2613">2613: </a></span>     *   &lt;LI&gt;&lt;B&gt;IS_GENERATEDCOLUMN&lt;/B&gt; String  =&gt; Indicates whether this is a generated column
<span class="nocode"><a name="2614">2614: </a></span>     *       &lt;UL&gt;
<span class="nocode"><a name="2615">2615: </a></span>     *       &lt;LI&gt; YES           --- if this a generated column
<span class="nocode"><a name="2616">2616: </a></span>     *       &lt;LI&gt; NO            --- if this not a generated column
<span class="nocode"><a name="2617">2617: </a></span>     *       &lt;LI&gt; empty string  --- if it cannot be determined whether this is a generated column
<span class="nocode"><a name="2618">2618: </a></span>     *       &lt;/UL&gt;
<span class="nocode"><a name="2619">2619: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="2620">2620: </a></span>     *
<span class="nocode"><a name="2621">2621: </a></span>     * &lt;p&gt;The COLUMN_SIZE column specifies the column size for the given column.
<span class="nocode"><a name="2622">2622: </a></span>     * For numeric data, this is the maximum precision.  For character data, this is the length in characters.
<span class="nocode"><a name="2623">2623: </a></span>     * For datetime datatypes, this is the length in characters of the String representation (assuming the
<span class="nocode"><a name="2624">2624: </a></span>     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype,
<span class="nocode"><a name="2625">2625: </a></span>     * this is the length in bytes. Null is returned for data types where the
<span class="nocode"><a name="2626">2626: </a></span>     * column size is not applicable.
<span class="nocode"><a name="2627">2627: </a></span>     *
<span class="nocode"><a name="2628">2628: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="2629">2629: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="2630">2630: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="2631">2631: </a></span>     *        the search
<span class="nocode"><a name="2632">2632: </a></span>     * @param schemaPattern a schema name pattern; must match the schema name
<span class="nocode"><a name="2633">2633: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="2634">2634: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="2635">2635: </a></span>     *        the search
<span class="nocode"><a name="2636">2636: </a></span>     * @param tableNamePattern a table name pattern; must match the
<span class="nocode"><a name="2637">2637: </a></span>     *        table name as it is stored in the database
<span class="nocode"><a name="2638">2638: </a></span>     * @param columnNamePattern a column name pattern; must match the column
<span class="nocode"><a name="2639">2639: </a></span>     *        name as it is stored in the database
<span class="nocode"><a name="2640">2640: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
<span class="nocode"><a name="2641">2641: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="2642">2642: </a></span>     * @see #getSearchStringEscape
<span class="nocode"><a name="2643">2643: </a></span>     */
<span class="nocode"><a name="2644">2644: </a></span>    public ResultSet getColumns(String catalog, String schemaPattern,
<span class="nocode"><a name="2645">2645: </a></span>        String tableNamePattern, String columnNamePattern) throws SQLException {
<span class="nocode"><a name="2646">2646: </a></span>        checkCatalogAndSchema(catalog, schemaPattern);
<span class="nocode"><a name="2647">2647: </a></span>
<span class="nocode"><a name="2648">2648: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[24];
<span class="nocode"><a name="2649">2649: </a></span>
<span class="nocode"><a name="2650">2650: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="2651">2651: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2652">2652: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="2653">2653: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="2654">2654: </a></span>        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2655">2655: </a></span>
<span class="nocode"><a name="2656">2656: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="2657">2657: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2658">2658: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="2659">2659: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="2660">2660: </a></span>        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2661">2661: </a></span>
<span class="nocode"><a name="2662">2662: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="2663">2663: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2664">2664: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="2665">2665: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="2666">2666: </a></span>        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2667">2667: </a></span>
<span class="nocode"><a name="2668">2668: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="2669">2669: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2670">2670: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="2671">2671: </a></span>        xsqlvars[3].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="2672">2672: </a></span>        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2673">2673: </a></span>
<span class="nocode"><a name="2674">2674: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="2675">2675: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2676">2676: </a></span>        xsqlvars[4].sqlname = &quot;DATA_TYPE&quot;;
<span class="nocode"><a name="2677">2677: </a></span>        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2678">2678: </a></span>
<span class="nocode"><a name="2679">2679: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="2680">2680: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING | 1;
<span class="nocode"><a name="2681">2681: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="2682">2682: </a></span>        xsqlvars[5].sqlname = &quot;TYPE_NAME&quot;;
<span class="nocode"><a name="2683">2683: </a></span>        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2684">2684: </a></span>
<span class="nocode"><a name="2685">2685: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="2686">2686: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2687">2687: </a></span>        xsqlvars[6].sqlname = &quot;COLUMN_SIZE&quot;;
<span class="nocode"><a name="2688">2688: </a></span>        xsqlvars[6].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2689">2689: </a></span>
<span class="nocode"><a name="2690">2690: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="2691">2691: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2692">2692: </a></span>        xsqlvars[7].sqlname = &quot;BUFFER_LENGTH&quot;;
<span class="nocode"><a name="2693">2693: </a></span>        xsqlvars[7].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2694">2694: </a></span>
<span class="nocode"><a name="2695">2695: </a></span>        xsqlvars[8] = new XSQLVAR();
<span class="nocode"><a name="2696">2696: </a></span>        xsqlvars[8].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2697">2697: </a></span>        xsqlvars[8].sqlname = &quot;DECIMAL_DIGITS&quot;;
<span class="nocode"><a name="2698">2698: </a></span>        xsqlvars[8].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2699">2699: </a></span>
<span class="nocode"><a name="2700">2700: </a></span>        xsqlvars[9] = new XSQLVAR();
<span class="nocode"><a name="2701">2701: </a></span>        xsqlvars[9].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2702">2702: </a></span>        xsqlvars[9].sqlname = &quot;NUM_PREC_RADIX&quot;;
<span class="nocode"><a name="2703">2703: </a></span>        xsqlvars[9].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2704">2704: </a></span>
<span class="nocode"><a name="2705">2705: </a></span>        xsqlvars[10] = new XSQLVAR();
<span class="nocode"><a name="2706">2706: </a></span>        xsqlvars[10].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2707">2707: </a></span>        xsqlvars[10].sqlname = &quot;NULLABLE&quot;;
<span class="nocode"><a name="2708">2708: </a></span>        xsqlvars[10].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2709">2709: </a></span>
<span class="nocode"><a name="2710">2710: </a></span>        xsqlvars[11] = new XSQLVAR();
<span class="nocode"><a name="2711">2711: </a></span>        xsqlvars[11].sqltype = ISCConstants.SQL_VARYING | 1;
<span class="nocode"><a name="2712">2712: </a></span>        xsqlvars[11].sqllen = 80;
<span class="nocode"><a name="2713">2713: </a></span>        xsqlvars[11].sqlname = &quot;REMARKS&quot;;
<span class="nocode"><a name="2714">2714: </a></span>        xsqlvars[11].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2715">2715: </a></span>
<span class="nocode"><a name="2716">2716: </a></span>        xsqlvars[12] = new XSQLVAR();
<span class="nocode"><a name="2717">2717: </a></span>        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING | 1;
<span class="nocode"><a name="2718">2718: </a></span>        xsqlvars[12].sqllen = 31;
<span class="nocode"><a name="2719">2719: </a></span>        xsqlvars[12].sqlname = &quot;COLUMN_DEF&quot;;
<span class="nocode"><a name="2720">2720: </a></span>        xsqlvars[12].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2721">2721: </a></span>
<span class="nocode"><a name="2722">2722: </a></span>        xsqlvars[13] = new XSQLVAR();
<span class="nocode"><a name="2723">2723: </a></span>        xsqlvars[13].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2724">2724: </a></span>        xsqlvars[13].sqlname = &quot;SQL_DATA_TYPE&quot;;
<span class="nocode"><a name="2725">2725: </a></span>        xsqlvars[13].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2726">2726: </a></span>
<span class="nocode"><a name="2727">2727: </a></span>        xsqlvars[14] = new XSQLVAR();
<span class="nocode"><a name="2728">2728: </a></span>        xsqlvars[14].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2729">2729: </a></span>        xsqlvars[14].sqlname = &quot;SQL_DATETIME_SUB&quot;;
<span class="nocode"><a name="2730">2730: </a></span>        xsqlvars[14].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2731">2731: </a></span>
<span class="nocode"><a name="2732">2732: </a></span>        xsqlvars[15] = new XSQLVAR();
<span class="nocode"><a name="2733">2733: </a></span>        xsqlvars[15].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2734">2734: </a></span>        xsqlvars[15].sqlname = &quot;CHAR_OCTET_LENGTH&quot;;
<span class="nocode"><a name="2735">2735: </a></span>        xsqlvars[15].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2736">2736: </a></span>
<span class="nocode"><a name="2737">2737: </a></span>        xsqlvars[16] = new XSQLVAR();
<span class="nocode"><a name="2738">2738: </a></span>        xsqlvars[16].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="2739">2739: </a></span>        xsqlvars[16].sqlname = &quot;ORDINAL_POSITION&quot;;
<span class="nocode"><a name="2740">2740: </a></span>        xsqlvars[16].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2741">2741: </a></span>
<span class="nocode"><a name="2742">2742: </a></span>        xsqlvars[17] = new XSQLVAR();
<span class="nocode"><a name="2743">2743: </a></span>        xsqlvars[17].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2744">2744: </a></span>        xsqlvars[17].sqllen = 3;
<span class="nocode"><a name="2745">2745: </a></span>        xsqlvars[17].sqlname = &quot;IS_NULLABLE&quot;;
<span class="nocode"><a name="2746">2746: </a></span>        xsqlvars[17].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2747">2747: </a></span>        
<span class="nocode"><a name="2748">2748: </a></span>        xsqlvars[18] = new XSQLVAR();
<span class="nocode"><a name="2749">2749: </a></span>        xsqlvars[18].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2750">2750: </a></span>        xsqlvars[18].sqllen = 31;
<span class="nocode"><a name="2751">2751: </a></span>        if (getJDBCMajorVersion() &gt; 4 || getJDBCMajorVersion() == 4 &amp;&amp; getJDBCMinorVersion() &gt;= 1) {
<span class="nocode"><a name="2752">2752: </a></span>            xsqlvars[18].sqlname = &quot;SCOPE_CATALOG&quot;;
<span class="nocode"><a name="2753">2753: </a></span>        } else {
<span class="nocode"><a name="2754">2754: </a></span>            xsqlvars[18].sqlname = &quot;SCOPE_CATLOG&quot;;
<span class="nocode"><a name="2755">2755: </a></span>        }
<span class="nocode"><a name="2756">2756: </a></span>        xsqlvars[18].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2757">2757: </a></span>        
<span class="nocode"><a name="2758">2758: </a></span>        xsqlvars[19] = new XSQLVAR();
<span class="nocode"><a name="2759">2759: </a></span>        xsqlvars[19].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2760">2760: </a></span>        xsqlvars[19].sqllen = 31;
<span class="nocode"><a name="2761">2761: </a></span>        xsqlvars[19].sqlname = &quot;SCOPE_SCHEMA&quot;;
<span class="nocode"><a name="2762">2762: </a></span>        xsqlvars[19].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2763">2763: </a></span>        
<span class="nocode"><a name="2764">2764: </a></span>        xsqlvars[20] = new XSQLVAR();
<span class="nocode"><a name="2765">2765: </a></span>        xsqlvars[20].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2766">2766: </a></span>        xsqlvars[20].sqllen = 31;
<span class="nocode"><a name="2767">2767: </a></span>        xsqlvars[20].sqlname = &quot;SCOPE_TABLE&quot;;
<span class="nocode"><a name="2768">2768: </a></span>        xsqlvars[20].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2769">2769: </a></span>        
<span class="nocode"><a name="2770">2770: </a></span>        xsqlvars[21] = new XSQLVAR();
<span class="nocode"><a name="2771">2771: </a></span>        xsqlvars[21].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="2772">2772: </a></span>        xsqlvars[21].sqlname = &quot;SOURCE_DATA_TYPE&quot;;
<span class="nocode"><a name="2773">2773: </a></span>        xsqlvars[21].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2774">2774: </a></span>        
<span class="nocode"><a name="2775">2775: </a></span>        xsqlvars[22] = new XSQLVAR();
<span class="nocode"><a name="2776">2776: </a></span>        xsqlvars[22].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2777">2777: </a></span>        xsqlvars[22].sqllen = 3;
<span class="nocode"><a name="2778">2778: </a></span>        xsqlvars[22].sqlname = &quot;IS_AUTOINCREMENT&quot;;
<span class="nocode"><a name="2779">2779: </a></span>        xsqlvars[22].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2780">2780: </a></span>        
<span class="nocode"><a name="2781">2781: </a></span>        xsqlvars[23] = new XSQLVAR();
<span class="nocode"><a name="2782">2782: </a></span>        xsqlvars[23].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="2783">2783: </a></span>        xsqlvars[23].sqllen = 3;
<span class="nocode"><a name="2784">2784: </a></span>        xsqlvars[23].sqlname = &quot;IS_GENERATEDCOLUMN&quot;;
<span class="nocode"><a name="2785">2785: </a></span>        xsqlvars[23].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="2786">2786: </a></span>
<span class="nocode"><a name="2787">2787: </a></span>        Clause tableClause = new Clause(&quot;RF.RDB$RELATION_NAME&quot;, tableNamePattern);
<span class="nocode"><a name="2788">2788: </a></span>        Clause columnClause = new Clause(&quot;RF.RDB$FIELD_NAME&quot;, columnNamePattern);
<span class="nocode"><a name="2789">2789: </a></span>        
<span class="nocode"><a name="2790">2790: </a></span>        String sql = GET_COLUMNS_START;
<span class="nocode"><a name="2791">2791: </a></span>        sql += tableClause.getCondition();
<span class="nocode"><a name="2792">2792: </a></span>        sql += columnClause.getCondition();
<span class="nocode"><a name="2793">2793: </a></span>        sql += GET_COLUMNS_END;
<span class="nocode"><a name="2794">2794: </a></span>        
<span class="nocode"><a name="2795">2795: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="2796">2796: </a></span>        
<span class="nocode"><a name="2797">2797: </a></span>        // check first original case values
<span class="nocode"><a name="2798">2798: </a></span>        if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2799">2799: </a></span>            params.add(tableClause.getOriginalCaseValue());
<span class="nocode"><a name="2800">2800: </a></span>        }
<span class="nocode"><a name="2801">2801: </a></span>        if (!columnClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2802">2802: </a></span>            params.add(columnClause.getOriginalCaseValue());
<span class="nocode"><a name="2803">2803: </a></span>        }
<span class="nocode"><a name="2804">2804: </a></span>        
<span class="nocode"><a name="2805">2805: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="2806">2806: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="2807">2807: </a></span>
<span class="nocode"><a name="2808">2808: </a></span>        // if no direct match happened, check the uppercased match
<span class="nocode"><a name="2809">2809: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="2810">2810: </a></span>            params.clear();
<span class="nocode"><a name="2811">2811: </a></span>            if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2812">2812: </a></span>                params.add(tableClause.getValue());
<span class="nocode"><a name="2813">2813: </a></span>            }
<span class="nocode"><a name="2814">2814: </a></span>            if (!columnClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="2815">2815: </a></span>                params.add(columnClause.getValue());
<span class="nocode"><a name="2816">2816: </a></span>            }
<span class="nocode"><a name="2817">2817: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="2818">2818: </a></span>            
<span class="nocode"><a name="2819">2819: </a></span>            // open the second result set and check whether we have rows
<span class="nocode"><a name="2820">2820: </a></span>            // if no rows are available, we have to exit now, otherwise the 
<span class="nocode"><a name="2821">2821: </a></span>            // following do/while loop will throw SQLException that the
<span class="nocode"><a name="2822">2822: </a></span>            // result set is not positioned on a row
<span class="nocode"><a name="2823">2823: </a></span>            if (!rs.next())
<span class="nocode"><a name="2824">2824: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2825">2825: </a></span>        }
<span class="nocode"><a name="2826">2826: </a></span>
<span class="nocode"><a name="2827">2827: </a></span>        do {
<span class="nocode"><a name="2828">2828: </a></span>            byte[][] row = new byte[24][];
<span class="nocode"><a name="2829">2829: </a></span>            row[0] = null;
<span class="nocode"><a name="2830">2830: </a></span>            row[1] = null;
<span class="nocode"><a name="2831">2831: </a></span>            row[2] = getBytes(rs.getString(&quot;RELATION_NAME&quot;));
<span class="nocode"><a name="2832">2832: </a></span>            row[3] = getBytes(rs.getString(&quot;FIELD_NAME&quot;));
<span class="nocode"><a name="2833">2833: </a></span>
<span class="nocode"><a name="2834">2834: </a></span>            short fieldType = rs.getShort(&quot;FIELD_TYPE&quot;);
<span class="nocode"><a name="2835">2835: </a></span>            short fieldSubType = rs.getShort(&quot;FIELD_SUB_TYPE&quot;);
<span class="nocode"><a name="2836">2836: </a></span>            short fieldScale = rs.getShort(&quot;FIELD_SCALE&quot;);
<span class="nocode"><a name="2837">2837: </a></span>            int dataType = getDataType(fieldType, fieldSubType, fieldScale);
<span class="nocode"><a name="2838">2838: </a></span>
<span class="nocode"><a name="2839">2839: </a></span>            row[4] = xsqlvars[0].encodeInt(dataType);
<span class="nocode"><a name="2840">2840: </a></span>            row[5] = getBytes(getDataTypeName(fieldType, fieldSubType, fieldScale));
<span class="nocode"><a name="2841">2841: </a></span>            
<span class="nocode"><a name="2842">2842: </a></span>            row[7] = null;
<span class="nocode"><a name="2843">2843: </a></span>            
<span class="nocode"><a name="2844">2844: </a></span>            // Defaults: some are overridden in the switch
<span class="nocode"><a name="2845">2845: </a></span>            row[8] = null;
<span class="nocode"><a name="2846">2846: </a></span>            row[9] = null;
<span class="nocode"><a name="2847">2847: </a></span>            row[15] = null;
<span class="nocode"><a name="2848">2848: </a></span>            switch (dataType){
<span class="nocode"><a name="2849">2849: </a></span>                case Types.DECIMAL:
<span class="nocode"><a name="2850">2850: </a></span>                case Types.NUMERIC:
<span class="nocode"><a name="2851">2851: </a></span>                   row[6] = xsqlvars[0].encodeInt(rs.getShort(&quot;FIELD_PRECISION&quot;));
<span class="nocode"><a name="2852">2852: </a></span>                   row[8] = xsqlvars[0].encodeInt(fieldScale * (-1));
<span class="nocode"><a name="2853">2853: </a></span>                   row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2854">2854: </a></span>                   break;
<span class="nocode"><a name="2855">2855: </a></span>                case Types.CHAR:
<span class="nocode"><a name="2856">2856: </a></span>                case Types.VARCHAR:
<span class="nocode"><a name="2857">2857: </a></span>                    row[15] = xsqlvars[0].encodeInt(rs.getShort(&quot;FIELD_LENGTH&quot;));
<span class="nocode"><a name="2858">2858: </a></span>                   short charLen = rs.getShort(&quot;CHAR_LEN&quot;);
<span class="nocode"><a name="2859">2859: </a></span>                   if (!rs.wasNull()) {
<span class="nocode"><a name="2860">2860: </a></span>                       row[6] = xsqlvars[0].encodeInt(charLen);
<span class="nocode"><a name="2861">2861: </a></span>                   } else {
<span class="nocode"><a name="2862">2862: </a></span>                       row[6] = row[15];
<span class="nocode"><a name="2863">2863: </a></span>                   }
<span class="nocode"><a name="2864">2864: </a></span>                   break;
<span class="nocode"><a name="2865">2865: </a></span>                case Types.FLOAT:
<span class="nocode"><a name="2866">2866: </a></span>                   row[6] = xsqlvars[0].encodeInt(7);
<span class="nocode"><a name="2867">2867: </a></span>                   row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2868">2868: </a></span>                   break;
<span class="nocode"><a name="2869">2869: </a></span>                case Types.DOUBLE:
<span class="nocode"><a name="2870">2870: </a></span>                   row[6] = xsqlvars[0].encodeInt(15);
<span class="nocode"><a name="2871">2871: </a></span>                   row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2872">2872: </a></span>                   break;
<span class="nocode"><a name="2873">2873: </a></span>                case Types.BIGINT:
<span class="nocode"><a name="2874">2874: </a></span>                    row[6] = xsqlvars[0].encodeInt(19);
<span class="nocode"><a name="2875">2875: </a></span>                    row[8] = xsqlvars[0].encodeInt(0);
<span class="nocode"><a name="2876">2876: </a></span>                    row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2877">2877: </a></span>                    break;
<span class="nocode"><a name="2878">2878: </a></span>                case Types.INTEGER:
<span class="nocode"><a name="2879">2879: </a></span>                   row[6] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2880">2880: </a></span>                   row[8] = xsqlvars[0].encodeInt(0);
<span class="nocode"><a name="2881">2881: </a></span>                   row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2882">2882: </a></span>                   break;
<span class="nocode"><a name="2883">2883: </a></span>                case Types.SMALLINT:
<span class="nocode"><a name="2884">2884: </a></span>                   row[6] = xsqlvars[0].encodeInt(5);
<span class="nocode"><a name="2885">2885: </a></span>                   row[8] = xsqlvars[0].encodeInt(0);
<span class="nocode"><a name="2886">2886: </a></span>                   row[9] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2887">2887: </a></span>                   break;
<span class="nocode"><a name="2888">2888: </a></span>                case Types.DATE:
<span class="nocode"><a name="2889">2889: </a></span>                   row[6] = xsqlvars[0].encodeInt(10);
<span class="nocode"><a name="2890">2890: </a></span>                   break;
<span class="nocode"><a name="2891">2891: </a></span>                case Types.TIME:
<span class="nocode"><a name="2892">2892: </a></span>                   row[6] = xsqlvars[0].encodeInt(8);
<span class="nocode"><a name="2893">2893: </a></span>                   break;
<span class="nocode"><a name="2894">2894: </a></span>                case Types.TIMESTAMP:
<span class="nocode"><a name="2895">2895: </a></span>                   row[6] = xsqlvars[0].encodeInt(19);
<span class="nocode"><a name="2896">2896: </a></span>                   break;
<span class="nocode"><a name="2897">2897: </a></span>                default:
<span class="nocode"><a name="2898">2898: </a></span>                   row[6] = null;
<span class="nocode"><a name="2899">2899: </a></span>            }
<span class="nocode"><a name="2900">2900: </a></span>
<span class="nocode"><a name="2901">2901: </a></span>            short nullFlag = rs.getShort(&quot;NULL_FLAG&quot;);
<span class="nocode"><a name="2902">2902: </a></span>            short sourceNullFlag = rs.getShort(&quot;SOURCE_NULL_FLAG&quot;);
<span class="nocode"><a name="2903">2903: </a></span>            row[10] = (nullFlag == 1 || sourceNullFlag == 1) ? 
<span class="nocode"><a name="2904">2904: </a></span>                    xsqlvars[0].encodeInt(columnNoNulls) :
<span class="nocode"><a name="2905">2905: </a></span>                    xsqlvars[0].encodeInt(columnNullable);
<span class="nocode"><a name="2906">2906: </a></span>
<span class="nocode"><a name="2907">2907: </a></span>            String remarks = rs.getString(&quot;REMARKS&quot;);  
<span class="nocode"><a name="2908">2908: </a></span>            row[11] = getBytes(remarks);             
<span class="nocode"><a name="2909">2909: </a></span>            if (remarks != null &amp;&amp; remarks.length() &gt; xsqlvars[11].sqllen)               
<span class="nocode"><a name="2910">2910: </a></span>                xsqlvars[11].sqllen = remarks.length();
<span class="nocode"><a name="2911">2911: </a></span>            
<span class="nocode"><a name="2912">2912: </a></span>            String column_def = rs.getString(&quot;DEFAULT_SOURCE&quot;);
<span class="nocode"><a name="2913">2913: </a></span>            if (column_def != null) {
<span class="nocode"><a name="2914">2914: </a></span>                int defaultPos = column_def.toUpperCase().indexOf(&quot;DEFAULT&quot;);
<span class="nocode"><a name="2915">2915: </a></span>                if (defaultPos &gt;= 0)
<span class="nocode"><a name="2916">2916: </a></span>                    column_def = column_def.substring(7).trim();
<span class="nocode"><a name="2917">2917: </a></span>                
<span class="nocode"><a name="2918">2918: </a></span>            	row[12] = getBytes(column_def);
<span class="nocode"><a name="2919">2919: </a></span>            } else
<span class="nocode"><a name="2920">2920: </a></span>            	row[12] = null;
<span class="nocode"><a name="2921">2921: </a></span>            
<span class="nocode"><a name="2922">2922: </a></span>            row[13] = null;
<span class="nocode"><a name="2923">2923: </a></span>            row[14] = null;
<span class="nocode"><a name="2924">2924: </a></span>            row[16] = xsqlvars[0].encodeInt(rs.getInt(&quot;FIELD_POSITION&quot;));
<span class="nocode"><a name="2925">2925: </a></span>            row[17] = (nullFlag == 1 || sourceNullFlag == 1) ? 
<span class="nocode"><a name="2926">2926: </a></span>                        getBytes(&quot;NO&quot;) : getBytes(&quot;YES&quot;);
<span class="nocode"><a name="2927">2927: </a></span>            row[18] = null;
<span class="nocode"><a name="2928">2928: </a></span>            row[19] = null;
<span class="nocode"><a name="2929">2929: </a></span>            row[20] = null;
<span class="nocode"><a name="2930">2930: </a></span>            row[21] = null;
<span class="nocode"><a name="2931">2931: </a></span>            switch (dataType) {
<span class="nocode"><a name="2932">2932: </a></span>            case Types.INTEGER:
<span class="nocode"><a name="2933">2933: </a></span>            case Types.TINYINT:
<span class="nocode"><a name="2934">2934: </a></span>            case Types.BIGINT:
<span class="nocode"><a name="2935">2935: </a></span>            case Types.SMALLINT:
<span class="nocode"><a name="2936">2936: </a></span>                // Could be autoincrement, but we simply don't know
<span class="nocode"><a name="2937">2937: </a></span>                row[22] = getBytes(&quot;&quot;);
<span class="nocode"><a name="2938">2938: </a></span>                break;
<span class="nocode"><a name="2939">2939: </a></span>            case Types.NUMERIC:
<span class="nocode"><a name="2940">2940: </a></span>            case Types.DECIMAL:
<span class="nocode"><a name="2941">2941: </a></span>            	if (fieldScale == 0) {
<span class="nocode"><a name="2942">2942: </a></span>            		// Could be autoincrement, but we simply don't know
<span class="nocode"><a name="2943">2943: </a></span>                    row[22] = getBytes(&quot;&quot;);
<span class="nocode"><a name="2944">2944: </a></span>            	} else {
<span class="nocode"><a name="2945">2945: </a></span>            		// Scaled NUMERIC/DECIMAL: definitely not autoincrement
<span class="nocode"><a name="2946">2946: </a></span>            		row[22] = getBytes(&quot;NO&quot;);
<span class="nocode"><a name="2947">2947: </a></span>            	}
<span class="nocode"><a name="2948">2948: </a></span>            	break;
<span class="nocode"><a name="2949">2949: </a></span>            default:
<span class="nocode"><a name="2950">2950: </a></span>                // All other types are never autoincrement
<span class="nocode"><a name="2951">2951: </a></span>                row[22] = getBytes(&quot;NO&quot;);
<span class="nocode"><a name="2952">2952: </a></span>            }
<span class="nocode"><a name="2953">2953: </a></span>            rs.getString(&quot;COMPUTED_BLR&quot;);
<span class="nocode"><a name="2954">2954: </a></span>            row[23] = getBytes(rs.wasNull() ? &quot;NO&quot; : &quot;YES&quot;);
<span class="nocode"><a name="2955">2955: </a></span>
<span class="nocode"><a name="2956">2956: </a></span>            rows.add(row);
<span class="nocode"><a name="2957">2957: </a></span>        } while (rs.next());
<span class="nocode"><a name="2958">2958: </a></span>        
<span class="nocode"><a name="2959">2959: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="2960">2960: </a></span>    }
<span class="nocode"><a name="2961">2961: </a></span>
<span class="nocode"><a name="2962">2962: </a></span>    private static final short smallint_type = 7;
<span class="nocode"><a name="2963">2963: </a></span>    private static final short integer_type = 8;
<span class="nocode"><a name="2964">2964: </a></span>    private static final short quad_type = 9;
<span class="nocode"><a name="2965">2965: </a></span>    private static final short float_type = 10;
<span class="nocode"><a name="2966">2966: </a></span>    private static final short d_float_type = 11;
<span class="nocode"><a name="2967">2967: </a></span>    private static final short date_type = 12;
<span class="nocode"><a name="2968">2968: </a></span>    private static final short time_type = 13;
<span class="nocode"><a name="2969">2969: </a></span>    private static final short char_type = 14;
<span class="nocode"><a name="2970">2970: </a></span>    private static final short int64_type = 16;
<span class="nocode"><a name="2971">2971: </a></span>    private static final short double_type = 27;
<span class="nocode"><a name="2972">2972: </a></span>    private static final short timestamp_type = 35;
<span class="nocode"><a name="2973">2973: </a></span>    private static final short varchar_type = 37;
<span class="nocode"><a name="2974">2974: </a></span>//  private static final short cstring_type = 40;
<span class="nocode"><a name="2975">2975: </a></span>    private static final short blob_type = 261;
<span class="nocode"><a name="2976">2976: </a></span>
<span class="nocode"><a name="2977">2977: </a></span>    private static int getDataType (short fieldType, short fieldSubType, short fieldScale) {
<span class="nocode"><a name="2978">2978: </a></span>        switch (fieldType) {
<span class="nocode"><a name="2979">2979: </a></span>            case smallint_type:
<span class="nocode"><a name="2980">2980: </a></span>                if (fieldSubType == 1 || (fieldSubType == 0 &amp;&amp; fieldScale &lt; 0))
<span class="nocode"><a name="2981">2981: </a></span>                    return Types.NUMERIC;
<span class="nocode"><a name="2982">2982: </a></span>                else if (fieldSubType == 2)
<span class="nocode"><a name="2983">2983: </a></span>                    return Types.DECIMAL;
<span class="nocode"><a name="2984">2984: </a></span>                else
<span class="nocode"><a name="2985">2985: </a></span>                    return Types.SMALLINT;
<span class="nocode"><a name="2986">2986: </a></span>            case integer_type:
<span class="nocode"><a name="2987">2987: </a></span>                if (fieldSubType == 1 || (fieldSubType == 0 &amp;&amp; fieldScale &lt; 0))
<span class="nocode"><a name="2988">2988: </a></span>                    return Types.NUMERIC;
<span class="nocode"><a name="2989">2989: </a></span>                else if (fieldSubType == 2)
<span class="nocode"><a name="2990">2990: </a></span>                    return Types.DECIMAL;
<span class="nocode"><a name="2991">2991: </a></span>                else
<span class="nocode"><a name="2992">2992: </a></span>                    return Types.INTEGER;
<span class="nocode"><a name="2993">2993: </a></span>            case double_type:
<span class="nocode"><a name="2994">2994: </a></span>            case d_float_type:
<span class="nocode"><a name="2995">2995: </a></span>                return Types.DOUBLE;
<span class="nocode"><a name="2996">2996: </a></span>            case float_type:
<span class="nocode"><a name="2997">2997: </a></span>                return Types.FLOAT;
<span class="nocode"><a name="2998">2998: </a></span>            case char_type:
<span class="nocode"><a name="2999">2999: </a></span>                return Types.CHAR;
<span class="nocode"><a name="3000">3000: </a></span>            case varchar_type:
<span class="nocode"><a name="3001">3001: </a></span>                return Types.VARCHAR;
<span class="nocode"><a name="3002">3002: </a></span>            case timestamp_type:
<span class="nocode"><a name="3003">3003: </a></span>                return Types.TIMESTAMP;
<span class="nocode"><a name="3004">3004: </a></span>            case time_type:
<span class="nocode"><a name="3005">3005: </a></span>                return Types.TIME;
<span class="nocode"><a name="3006">3006: </a></span>            case date_type:
<span class="nocode"><a name="3007">3007: </a></span>                return Types.DATE;
<span class="nocode"><a name="3008">3008: </a></span>            case int64_type:
<span class="nocode"><a name="3009">3009: </a></span>                if (fieldSubType == 1 || (fieldSubType == 0 &amp;&amp; fieldScale &lt; 0))
<span class="nocode"><a name="3010">3010: </a></span>                    return Types.NUMERIC;
<span class="nocode"><a name="3011">3011: </a></span>                else if (fieldSubType == 2)
<span class="nocode"><a name="3012">3012: </a></span>                    return Types.DECIMAL;
<span class="nocode"><a name="3013">3013: </a></span>                else
<span class="nocode"><a name="3014">3014: </a></span>                    return Types.BIGINT;
<span class="nocode"><a name="3015">3015: </a></span>            case blob_type:
<span class="nocode"><a name="3016">3016: </a></span>                if (fieldSubType &lt; 0)
<span class="nocode"><a name="3017">3017: </a></span>                    return Types.BLOB;
<span class="nocode"><a name="3018">3018: </a></span>                else if (fieldSubType == 0)
<span class="nocode"><a name="3019">3019: </a></span>                    return Types.LONGVARBINARY;
<span class="nocode"><a name="3020">3020: </a></span>                else if (fieldSubType == 1)
<span class="nocode"><a name="3021">3021: </a></span>                    return Types.LONGVARCHAR;
<span class="nocode"><a name="3022">3022: </a></span>                else
<span class="nocode"><a name="3023">3023: </a></span>                    return Types.OTHER;
<span class="nocode"><a name="3024">3024: </a></span>            case quad_type:
<span class="nocode"><a name="3025">3025: </a></span>                return Types.OTHER;
<span class="nocode"><a name="3026">3026: </a></span>            default:
<span class="nocode"><a name="3027">3027: </a></span>                return Types.NULL;
<span class="nocode"><a name="3028">3028: </a></span>        }
<span class="nocode"><a name="3029">3029: </a></span>    }
<span class="nocode"><a name="3030">3030: </a></span>
<span class="nocode"><a name="3031">3031: </a></span>    private static String getDataTypeName(short sqltype, short sqlsubtype, short sqlscale) {
<span class="nocode"><a name="3032">3032: </a></span>        switch (sqltype) {
<span class="nocode"><a name="3033">3033: </a></span>            case smallint_type:
<span class="nocode"><a name="3034">3034: </a></span>                if (sqlsubtype == 1 || (sqlsubtype == 0 &amp;&amp; sqlscale &lt; 0))
<span class="nocode"><a name="3035">3035: </a></span>                    return &quot;NUMERIC&quot;;
<span class="nocode"><a name="3036">3036: </a></span>                else if (sqlsubtype == 2)
<span class="nocode"><a name="3037">3037: </a></span>                    return &quot;DECIMAL&quot;;
<span class="nocode"><a name="3038">3038: </a></span>                else
<span class="nocode"><a name="3039">3039: </a></span>                    return &quot;SMALLINT&quot;;
<span class="nocode"><a name="3040">3040: </a></span>            case integer_type:
<span class="nocode"><a name="3041">3041: </a></span>                if (sqlsubtype == 1 || (sqlsubtype == 0 &amp;&amp; sqlscale &lt; 0))
<span class="nocode"><a name="3042">3042: </a></span>                    return &quot;NUMERIC&quot;;
<span class="nocode"><a name="3043">3043: </a></span>                else if (sqlsubtype == 2)
<span class="nocode"><a name="3044">3044: </a></span>                    return &quot;DECIMAL&quot;;
<span class="nocode"><a name="3045">3045: </a></span>                else
<span class="nocode"><a name="3046">3046: </a></span>                    return &quot;INTEGER&quot;;
<span class="nocode"><a name="3047">3047: </a></span>            case double_type:
<span class="nocode"><a name="3048">3048: </a></span>            case d_float_type:
<span class="nocode"><a name="3049">3049: </a></span>                return &quot;DOUBLE PRECISION&quot;;
<span class="nocode"><a name="3050">3050: </a></span>            case float_type:
<span class="nocode"><a name="3051">3051: </a></span>                return &quot;FLOAT&quot;;
<span class="nocode"><a name="3052">3052: </a></span>            case char_type:
<span class="nocode"><a name="3053">3053: </a></span>                return &quot;CHAR&quot;;
<span class="nocode"><a name="3054">3054: </a></span>            case varchar_type:
<span class="nocode"><a name="3055">3055: </a></span>                return &quot;VARCHAR&quot;;
<span class="nocode"><a name="3056">3056: </a></span>            case timestamp_type:
<span class="nocode"><a name="3057">3057: </a></span>                return &quot;TIMESTAMP&quot;;
<span class="nocode"><a name="3058">3058: </a></span>            case time_type:
<span class="nocode"><a name="3059">3059: </a></span>                return &quot;TIME&quot;;
<span class="nocode"><a name="3060">3060: </a></span>            case date_type:
<span class="nocode"><a name="3061">3061: </a></span>                return &quot;DATE&quot;;
<span class="nocode"><a name="3062">3062: </a></span>            case int64_type:
<span class="nocode"><a name="3063">3063: </a></span>                if (sqlsubtype == 1 || (sqlsubtype == 0 &amp;&amp; sqlscale &lt; 0))
<span class="nocode"><a name="3064">3064: </a></span>                    return &quot;NUMERIC&quot;;
<span class="nocode"><a name="3065">3065: </a></span>                else if (sqlsubtype == 2)
<span class="nocode"><a name="3066">3066: </a></span>                    return &quot;DECIMAL&quot;;
<span class="nocode"><a name="3067">3067: </a></span>                else
<span class="nocode"><a name="3068">3068: </a></span>                    return &quot;BIGINT&quot;;
<span class="nocode"><a name="3069">3069: </a></span>            case blob_type:
<span class="nocode"><a name="3070">3070: </a></span>                if (sqlsubtype &lt; 0)
<span class="nocode"><a name="3071">3071: </a></span>                    return &quot;BLOB SUB_TYPE &lt;0&quot;;
<span class="nocode"><a name="3072">3072: </a></span>                else if (sqlsubtype == 0)
<span class="nocode"><a name="3073">3073: </a></span>                    return &quot;BLOB SUB_TYPE 0&quot;;
<span class="nocode"><a name="3074">3074: </a></span>                else if (sqlsubtype == 1)
<span class="nocode"><a name="3075">3075: </a></span>                    return &quot;BLOB SUB_TYPE 1&quot;;
<span class="nocode"><a name="3076">3076: </a></span>                else
<span class="nocode"><a name="3077">3077: </a></span>                    return &quot;BLOB SUB_TYPE &quot; + sqlsubtype;
<span class="nocode"><a name="3078">3078: </a></span>            case quad_type:
<span class="nocode"><a name="3079">3079: </a></span>                return &quot;ARRAY&quot;;
<span class="nocode"><a name="3080">3080: </a></span>            default:
<span class="nocode"><a name="3081">3081: </a></span>                return &quot;NULL&quot;;
<span class="nocode"><a name="3082">3082: </a></span>        }
<span class="nocode"><a name="3083">3083: </a></span>    }
<span class="nocode"><a name="3084">3084: </a></span>
<span class="nocode"><a name="3085">3085: </a></span>    private static final String GET_COLUMN_PRIVILEGES_START = &quot;select &quot;
<span class="nocode"><a name="3086">3086: </a></span>        + &quot;null as TABLE_CAT,&quot;
<span class="nocode"><a name="3087">3087: </a></span>        + &quot;null as TABLE_SCHEM,&quot;
<span class="nocode"><a name="3088">3088: </a></span>        + &quot;RF.RDB$RELATION_NAME as TABLE_NAME, &quot;
<span class="nocode"><a name="3089">3089: </a></span>        + &quot;RF.RDB$FIELD_NAME as COLUMN_NAME, &quot;
<span class="nocode"><a name="3090">3090: </a></span>        + &quot;UP.RDB$GRANTOR as GRANTOR, &quot;
<span class="nocode"><a name="3091">3091: </a></span>        + &quot;UP.RDB$USER as GRANTEE, &quot;
<span class="nocode"><a name="3092">3092: </a></span>        + &quot;UP.RDB$PRIVILEGE as PRIVILEGE, &quot;
<span class="nocode"><a name="3093">3093: </a></span>        + &quot;UP.RDB$GRANT_OPTION as IS_GRANTABLE &quot;
<span class="nocode"><a name="3094">3094: </a></span>        + &quot;from &quot;
<span class="nocode"><a name="3095">3095: </a></span>        + &quot;RDB$RELATION_FIELDS RF, &quot;
<span class="nocode"><a name="3096">3096: </a></span>        + &quot;RDB$FIELDS F, &quot;
<span class="nocode"><a name="3097">3097: </a></span>        + &quot;RDB$USER_PRIVILEGES UP &quot;
<span class="nocode"><a name="3098">3098: </a></span>        + &quot;where &quot;
<span class="nocode"><a name="3099">3099: </a></span>        + &quot;RF.RDB$RELATION_NAME = UP.RDB$RELATION_NAME and &quot;
<span class="nocode"><a name="3100">3100: </a></span>        + &quot;RF.RDB$FIELD_SOURCE = F.RDB$FIELD_NAME  and &quot;
<span class="nocode"><a name="3101">3101: </a></span>        + &quot;(UP.RDB$FIELD_NAME is null or &quot;
<span class="nocode"><a name="3102">3102: </a></span>        + &quot;UP.RDB$FIELD_NAME = RF.RDB$FIELD_NAME) and &quot;
<span class="nocode"><a name="3103">3103: </a></span>        + &quot;UP.RDB$RELATION_NAME = ? and ((&quot;;
<span class="nocode"><a name="3104">3104: </a></span>    private static final String GET_COLUMN_PRIVILEGES_END = &quot; UP.RDB$OBJECT_TYPE = 0) or &quot;
<span class="nocode"><a name="3105">3105: </a></span>        + &quot;(RF.RDB$FIELD_NAME is null and UP.RDB$OBJECT_TYPE = 0)) &quot;
<span class="nocode"><a name="3106">3106: </a></span>        + &quot;order by 4,7 &quot;;
<span class="nocode"><a name="3107">3107: </a></span>
<span class="nocode"><a name="3108">3108: </a></span>    /**
<span class="nocode"><a name="3109">3109: </a></span>     * Gets a description of the access rights for a table's columns.
<span class="nocode"><a name="3110">3110: </a></span>     *
<span class="nocode"><a name="3111">3111: </a></span>     * &lt;P&gt;Only privileges matching the column name criteria are
<span class="nocode"><a name="3112">3112: </a></span>     * returned.  They are ordered by COLUMN_NAME and PRIVILEGE.
<span class="nocode"><a name="3113">3113: </a></span>     *
<span class="nocode"><a name="3114">3114: </a></span>     * &lt;P&gt;Each privilige description has the following columns:
<span class="nocode"><a name="3115">3115: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3116">3116: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be null)
<span class="nocode"><a name="3117">3117: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be null)
<span class="nocode"><a name="3118">3118: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="3119">3119: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name
<span class="nocode"><a name="3120">3120: </a></span>     *  &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; =&gt; grantor of access (may be null)
<span class="nocode"><a name="3121">3121: </a></span>     *  &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String =&gt; grantee of access
<span class="nocode"><a name="3122">3122: </a></span>     *  &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String =&gt; name of access (SELECT,
<span class="nocode"><a name="3123">3123: </a></span>     *      INSERT, UPDATE, REFRENCES, ...)
<span class="nocode"><a name="3124">3124: </a></span>     *  &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String =&gt; &quot;YES&quot; if grantee is permitted
<span class="nocode"><a name="3125">3125: </a></span>     *      to grant to others; &quot;NO&quot; if not; null if unknown
<span class="nocode"><a name="3126">3126: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3127">3127: </a></span>     *
<span class="nocode"><a name="3128">3128: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3129">3129: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3130">3130: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those without a schema
<span class="nocode"><a name="3131">3131: </a></span>     * @param table a table name
<span class="nocode"><a name="3132">3132: </a></span>     * @param columnNamePattern a column name pattern
<span class="nocode"><a name="3133">3133: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column privilege description
<span class="nocode"><a name="3134">3134: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3135">3135: </a></span>     * @see #getSearchStringEscape
<span class="nocode"><a name="3136">3136: </a></span>     */
<span class="nocode"><a name="3137">3137: </a></span>    public ResultSet getColumnPrivileges(String catalog, String schema,
<span class="nocode"><a name="3138">3138: </a></span>        String table, String columnNamePattern) throws SQLException {
<span class="nocode"><a name="3139">3139: </a></span>        checkCatalogAndSchema(catalog, schema);
<span class="nocode"><a name="3140">3140: </a></span>
<span class="nocode"><a name="3141">3141: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[8];
<span class="nocode"><a name="3142">3142: </a></span>
<span class="nocode"><a name="3143">3143: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3144">3144: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3145">3145: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="3146">3146: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="3147">3147: </a></span>        xsqlvars[0].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3148">3148: </a></span>
<span class="nocode"><a name="3149">3149: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3150">3150: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3151">3151: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3152">3152: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="3153">3153: </a></span>        xsqlvars[1].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3154">3154: </a></span>
<span class="nocode"><a name="3155">3155: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3156">3156: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3157">3157: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="3158">3158: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="3159">3159: </a></span>        xsqlvars[2].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3160">3160: </a></span>
<span class="nocode"><a name="3161">3161: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3162">3162: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3163">3163: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3164">3164: </a></span>        xsqlvars[3].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="3165">3165: </a></span>        xsqlvars[3].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3166">3166: </a></span>
<span class="nocode"><a name="3167">3167: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3168">3168: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3169">3169: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="3170">3170: </a></span>        xsqlvars[4].sqlname = &quot;GRANTOR&quot;;
<span class="nocode"><a name="3171">3171: </a></span>        xsqlvars[4].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3172">3172: </a></span>
<span class="nocode"><a name="3173">3173: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3174">3174: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3175">3175: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="3176">3176: </a></span>        xsqlvars[5].sqlname = &quot;GRANTEE&quot;;
<span class="nocode"><a name="3177">3177: </a></span>        xsqlvars[5].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3178">3178: </a></span>
<span class="nocode"><a name="3179">3179: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="3180">3180: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3181">3181: </a></span>        xsqlvars[6].sqllen = 31;
<span class="nocode"><a name="3182">3182: </a></span>        xsqlvars[6].sqlname = &quot;PRIVILEGE&quot;;
<span class="nocode"><a name="3183">3183: </a></span>        xsqlvars[6].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3184">3184: </a></span>
<span class="nocode"><a name="3185">3185: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="3186">3186: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3187">3187: </a></span>        xsqlvars[7].sqllen = 31;
<span class="nocode"><a name="3188">3188: </a></span>        xsqlvars[7].sqlname = &quot;IS_GRANTABLE&quot;;
<span class="nocode"><a name="3189">3189: </a></span>        xsqlvars[7].relname = &quot;COLUMNPRIV&quot;;
<span class="nocode"><a name="3190">3190: </a></span>
<span class="nocode"><a name="3191">3191: </a></span>        Clause columnClause = new Clause(&quot;RF.RDB$FIELD_NAME&quot;, columnNamePattern);
<span class="nocode"><a name="3192">3192: </a></span>        
<span class="nocode"><a name="3193">3193: </a></span>        String sql = GET_COLUMN_PRIVILEGES_START;
<span class="nocode"><a name="3194">3194: </a></span>        sql += columnClause.getCondition();
<span class="nocode"><a name="3195">3195: </a></span>        sql += GET_COLUMN_PRIVILEGES_END;
<span class="nocode"><a name="3196">3196: </a></span>        
<span class="nocode"><a name="3197">3197: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="3198">3198: </a></span>        
<span class="nocode"><a name="3199">3199: </a></span>        // check the original case first
<span class="nocode"><a name="3200">3200: </a></span>        table = stripQuotes(stripEscape(table), false);
<span class="nocode"><a name="3201">3201: </a></span>        params.add(table);
<span class="nocode"><a name="3202">3202: </a></span>        if (!columnClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3203">3203: </a></span>            params.add(columnClause.getOriginalCaseValue());
<span class="nocode"><a name="3204">3204: </a></span>        }
<span class="nocode"><a name="3205">3205: </a></span>        
<span class="nocode"><a name="3206">3206: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="3207">3207: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="3208">3208: </a></span>        
<span class="nocode"><a name="3209">3209: </a></span>        // if nothing was found, check the uppercased identifiers
<span class="nocode"><a name="3210">3210: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="3211">3211: </a></span>            params.clear();
<span class="nocode"><a name="3212">3212: </a></span>            if (!columnClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3213">3213: </a></span>                params.add(stripQuotes(stripEscape(table), true));
<span class="nocode"><a name="3214">3214: </a></span>                params.add(columnClause.getValue());
<span class="nocode"><a name="3215">3215: </a></span>            }
<span class="nocode"><a name="3216">3216: </a></span>            
<span class="nocode"><a name="3217">3217: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="3218">3218: </a></span>            
<span class="nocode"><a name="3219">3219: </a></span>            // return empty result set 
<span class="nocode"><a name="3220">3220: </a></span>            if (!rs.next())
<span class="nocode"><a name="3221">3221: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3222">3222: </a></span>        }
<span class="nocode"><a name="3223">3223: </a></span>
<span class="nocode"><a name="3224">3224: </a></span>        do {
<span class="nocode"><a name="3225">3225: </a></span>            byte[][] row = new byte[8][];
<span class="nocode"><a name="3226">3226: </a></span>            row[0] = null;
<span class="nocode"><a name="3227">3227: </a></span>            row[1] = null;
<span class="nocode"><a name="3228">3228: </a></span>            row[2] = getBytes(rs.getString(&quot;TABLE_NAME&quot;));
<span class="nocode"><a name="3229">3229: </a></span>            row[3] = getBytes(rs.getString(&quot;COLUMN_NAME&quot;));
<span class="nocode"><a name="3230">3230: </a></span>            row[4] = getBytes(rs.getString(&quot;GRANTOR&quot;));
<span class="nocode"><a name="3231">3231: </a></span>            row[5] = getBytes(rs.getString(&quot;GRANTEE&quot;));
<span class="nocode"><a name="3232">3232: </a></span>            String privilege = rs.getString(&quot;PRIVILEGE&quot;);
<span class="nocode"><a name="3233">3233: </a></span>            if (privilege.equals(&quot;A&quot;))
<span class="nocode"><a name="3234">3234: </a></span>                row[6] = getBytes(&quot;ALL&quot;);
<span class="nocode"><a name="3235">3235: </a></span>            else if (privilege.equals(&quot;S&quot;))
<span class="nocode"><a name="3236">3236: </a></span>                row[6] = getBytes(&quot;SELECT&quot;);
<span class="nocode"><a name="3237">3237: </a></span>            else if (privilege.equals(&quot;D&quot;))
<span class="nocode"><a name="3238">3238: </a></span>                row[6] = getBytes(&quot;DELETE&quot;);
<span class="nocode"><a name="3239">3239: </a></span>            else if (privilege.equals(&quot;I&quot;))
<span class="nocode"><a name="3240">3240: </a></span>                row[6] = getBytes(&quot;INSERT&quot;);
<span class="nocode"><a name="3241">3241: </a></span>            else if (privilege.equals(&quot;U&quot;))
<span class="nocode"><a name="3242">3242: </a></span>                row[6] = getBytes(&quot;UPDATE&quot;);
<span class="nocode"><a name="3243">3243: </a></span>            else if (privilege.equals(&quot;R&quot;))
<span class="nocode"><a name="3244">3244: </a></span>                row[6] = getBytes(&quot;REFERENCE&quot;);
<span class="nocode"><a name="3245">3245: </a></span>            else if (privilege.equals(&quot;M&quot;))
<span class="nocode"><a name="3246">3246: </a></span>                row[6] = getBytes(&quot;MEMBEROF&quot;);
<span class="nocode"><a name="3247">3247: </a></span>            int isGrantable = rs.getShort(&quot;IS_GRANTABLE&quot;);
<span class="nocode"><a name="3248">3248: </a></span>            if (isGrantable==0)
<span class="nocode"><a name="3249">3249: </a></span>                row[7] = getBytes(&quot;NO&quot;);
<span class="nocode"><a name="3250">3250: </a></span>            else
<span class="nocode"><a name="3251">3251: </a></span>                row[7] = getBytes(&quot;YES&quot;);
<span class="nocode"><a name="3252">3252: </a></span>
<span class="nocode"><a name="3253">3253: </a></span>            rows.add(row);
<span class="nocode"><a name="3254">3254: </a></span>        } while(rs.next());
<span class="nocode"><a name="3255">3255: </a></span>        
<span class="nocode"><a name="3256">3256: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3257">3257: </a></span>    }
<span class="nocode"><a name="3258">3258: </a></span>
<span class="nocode"><a name="3259">3259: </a></span>    private static final String GET_TABLE_PRIVILEGES_START = &quot;select&quot;
<span class="nocode"><a name="3260">3260: </a></span>        + &quot; null as TABLE_CAT, &quot;
<span class="nocode"><a name="3261">3261: </a></span>        + &quot; null as TABLE_SCHEM,&quot;
<span class="nocode"><a name="3262">3262: </a></span>        + &quot; RDB$RELATION_NAME as TABLE_NAME,&quot;
<span class="nocode"><a name="3263">3263: </a></span>        + &quot; RDB$GRANTOR as GRANTOR, &quot;
<span class="nocode"><a name="3264">3264: </a></span>        + &quot; RDB$USER as GRANTEE, &quot;
<span class="nocode"><a name="3265">3265: </a></span>        + &quot; RDB$PRIVILEGE as PRIVILEGE, &quot;
<span class="nocode"><a name="3266">3266: </a></span>        + &quot; RDB$GRANT_OPTION as IS_GRANTABLE &quot;
<span class="nocode"><a name="3267">3267: </a></span>        + &quot;from&quot;
<span class="nocode"><a name="3268">3268: </a></span>        + &quot; RDB$USER_PRIVILEGES &quot;
<span class="nocode"><a name="3269">3269: </a></span>        + &quot;where &quot;;
<span class="nocode"><a name="3270">3270: </a></span>    private static final String GET_TABLE_PRIVILEGES_END = &quot; RDB$OBJECT_TYPE = 0 and&quot;
<span class="nocode"><a name="3271">3271: </a></span>        + &quot; RDB$FIELD_NAME is null &quot;
<span class="nocode"><a name="3272">3272: </a></span>        + &quot;order by 3, 6&quot;;
<span class="nocode"><a name="3273">3273: </a></span>
<span class="nocode"><a name="3274">3274: </a></span>    /**
<span class="nocode"><a name="3275">3275: </a></span>     * Gets a description of the access rights for each table available
<span class="nocode"><a name="3276">3276: </a></span>     * in a catalog. Note that a table privilege applies to one or
<span class="nocode"><a name="3277">3277: </a></span>     * more columns in the table. It would be wrong to assume that
<span class="nocode"><a name="3278">3278: </a></span>     * this priviledge applies to all columns (this may be true for
<span class="nocode"><a name="3279">3279: </a></span>     * some systems but is not true for all.)
<span class="nocode"><a name="3280">3280: </a></span>     *
<span class="nocode"><a name="3281">3281: </a></span>     * &lt;P&gt;Only privileges matching the schema and table name
<span class="nocode"><a name="3282">3282: </a></span>     * criteria are returned.  They are ordered by TABLE_SCHEM,
<span class="nocode"><a name="3283">3283: </a></span>     * TABLE_NAME, and PRIVILEGE.
<span class="nocode"><a name="3284">3284: </a></span>     *
<span class="nocode"><a name="3285">3285: </a></span>     * &lt;P&gt;Each privilige description has the following columns:
<span class="nocode"><a name="3286">3286: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3287">3287: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be null)
<span class="nocode"><a name="3288">3288: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be null)
<span class="nocode"><a name="3289">3289: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="3290">3290: </a></span>     *  &lt;LI&gt;&lt;B&gt;GRANTOR&lt;/B&gt; =&gt; grantor of access (may be null)
<span class="nocode"><a name="3291">3291: </a></span>     *  &lt;LI&gt;&lt;B&gt;GRANTEE&lt;/B&gt; String =&gt; grantee of access
<span class="nocode"><a name="3292">3292: </a></span>     *  &lt;LI&gt;&lt;B&gt;PRIVILEGE&lt;/B&gt; String =&gt; name of access (SELECT,
<span class="nocode"><a name="3293">3293: </a></span>     *      INSERT, UPDATE, REFRENCES, ...)
<span class="nocode"><a name="3294">3294: </a></span>     *  &lt;LI&gt;&lt;B&gt;IS_GRANTABLE&lt;/B&gt; String =&gt; &quot;YES&quot; if grantee is permitted
<span class="nocode"><a name="3295">3295: </a></span>     *      to grant to others; &quot;NO&quot; if not; null if unknown
<span class="nocode"><a name="3296">3296: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3297">3297: </a></span>     *
<span class="nocode"><a name="3298">3298: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3299">3299: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3300">3300: </a></span>     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those
<span class="nocode"><a name="3301">3301: </a></span>     * without a schema
<span class="nocode"><a name="3302">3302: </a></span>     * @param tableNamePattern a table name pattern
<span class="nocode"><a name="3303">3303: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a table privilege description
<span class="nocode"><a name="3304">3304: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3305">3305: </a></span>     * @see #getSearchStringEscape
<span class="nocode"><a name="3306">3306: </a></span>     */
<span class="nocode"><a name="3307">3307: </a></span>    public ResultSet getTablePrivileges(String catalog, String schemaPattern,
<span class="nocode"><a name="3308">3308: </a></span>                String tableNamePattern) throws SQLException {
<span class="nocode"><a name="3309">3309: </a></span>        checkCatalogAndSchema(catalog, schemaPattern);
<span class="nocode"><a name="3310">3310: </a></span>        tableNamePattern = stripQuotes(stripEscape(tableNamePattern), true);
<span class="nocode"><a name="3311">3311: </a></span>
<span class="nocode"><a name="3312">3312: </a></span>        XSQLVAR[] xsqlvars = buildTablePrivilegeRSMetaData();
<span class="nocode"><a name="3313">3313: </a></span>
<span class="nocode"><a name="3314">3314: </a></span>        Clause tableClause = new Clause(&quot;RDB$RELATION_NAME&quot;, tableNamePattern);
<span class="nocode"><a name="3315">3315: </a></span>        
<span class="nocode"><a name="3316">3316: </a></span>        String sql = GET_TABLE_PRIVILEGES_START;
<span class="nocode"><a name="3317">3317: </a></span>        sql += tableClause.getCondition();
<span class="nocode"><a name="3318">3318: </a></span>        sql += GET_TABLE_PRIVILEGES_END;
<span class="nocode"><a name="3319">3319: </a></span>        
<span class="nocode"><a name="3320">3320: </a></span>        // check the original case identifiers first
<span class="nocode"><a name="3321">3321: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="3322">3322: </a></span>        if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3323">3323: </a></span>            params.add(tableClause.getOriginalCaseValue());
<span class="nocode"><a name="3324">3324: </a></span>        }
<span class="nocode"><a name="3325">3325: </a></span>
<span class="nocode"><a name="3326">3326: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="3327">3327: </a></span>        
<span class="nocode"><a name="3328">3328: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="3329">3329: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="3330">3330: </a></span>            params.clear();
<span class="nocode"><a name="3331">3331: </a></span>            if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3332">3332: </a></span>                params.add(tableClause.getValue());
<span class="nocode"><a name="3333">3333: </a></span>            }
<span class="nocode"><a name="3334">3334: </a></span>            
<span class="nocode"><a name="3335">3335: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="3336">3336: </a></span>            
<span class="nocode"><a name="3337">3337: </a></span>            // if nothing found, return an empty result set
<span class="nocode"><a name="3338">3338: </a></span>            if (!rs.next())
<span class="nocode"><a name="3339">3339: </a></span>                return new FBResultSet(xsqlvars, new ArrayList&lt;byte[][]&gt;());
<span class="nocode"><a name="3340">3340: </a></span>        }
<span class="nocode"><a name="3341">3341: </a></span>        
<span class="nocode"><a name="3342">3342: </a></span>        return processTablePrivileges(xsqlvars, rs);
<span class="nocode"><a name="3343">3343: </a></span>    }
<span class="nocode"><a name="3344">3344: </a></span>    
<span class="nocode"><a name="3345">3345: </a></span>    protected final XSQLVAR[] buildTablePrivilegeRSMetaData() {
<span class="nocode"><a name="3346">3346: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[7];
<span class="nocode"><a name="3347">3347: </a></span>
<span class="nocode"><a name="3348">3348: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3349">3349: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3350">3350: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="3351">3351: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="3352">3352: </a></span>        xsqlvars[0].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3353">3353: </a></span>
<span class="nocode"><a name="3354">3354: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3355">3355: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3356">3356: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3357">3357: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="3358">3358: </a></span>        xsqlvars[1].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3359">3359: </a></span>
<span class="nocode"><a name="3360">3360: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3361">3361: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3362">3362: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="3363">3363: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="3364">3364: </a></span>        xsqlvars[2].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3365">3365: </a></span>
<span class="nocode"><a name="3366">3366: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3367">3367: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3368">3368: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3369">3369: </a></span>        xsqlvars[3].sqlname = &quot;GRANTOR&quot;;
<span class="nocode"><a name="3370">3370: </a></span>        xsqlvars[3].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3371">3371: </a></span>
<span class="nocode"><a name="3372">3372: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3373">3373: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3374">3374: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="3375">3375: </a></span>        xsqlvars[4].sqlname = &quot;GRANTEE&quot;;
<span class="nocode"><a name="3376">3376: </a></span>        xsqlvars[4].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3377">3377: </a></span>
<span class="nocode"><a name="3378">3378: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3379">3379: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3380">3380: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="3381">3381: </a></span>        xsqlvars[5].sqlname = &quot;PRIVILEGE&quot;;
<span class="nocode"><a name="3382">3382: </a></span>        xsqlvars[5].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3383">3383: </a></span>
<span class="nocode"><a name="3384">3384: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="3385">3385: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3386">3386: </a></span>        xsqlvars[6].sqllen = 31;
<span class="nocode"><a name="3387">3387: </a></span>        xsqlvars[6].sqlname = &quot;IS_GRANTABLE&quot;;
<span class="nocode"><a name="3388">3388: </a></span>        xsqlvars[6].relname = &quot;TABLEPRIV&quot;;
<span class="nocode"><a name="3389">3389: </a></span>        
<span class="nocode"><a name="3390">3390: </a></span>        return xsqlvars;
<span class="nocode"><a name="3391">3391: </a></span>    }
<span class="nocode"><a name="3392">3392: </a></span>    
<span class="nocode"><a name="3393">3393: </a></span>    protected final FBResultSet processTablePrivileges(XSQLVAR[] xsqlvars, ResultSet fbTablePrivileges) throws SQLException {
<span class="nocode"><a name="3394">3394: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="3395">3395: </a></span>        
<span class="nocode"><a name="3396">3396: </a></span>        do {
<span class="nocode"><a name="3397">3397: </a></span>            byte[][] row = new byte[7][];
<span class="nocode"><a name="3398">3398: </a></span>            row[0] = null;
<span class="nocode"><a name="3399">3399: </a></span>            row[1] = null;
<span class="nocode"><a name="3400">3400: </a></span>            row[2] = getBytes(fbTablePrivileges.getString(&quot;TABLE_NAME&quot;));
<span class="nocode"><a name="3401">3401: </a></span>            row[3] = getBytes(fbTablePrivileges.getString(&quot;GRANTOR&quot;));
<span class="nocode"><a name="3402">3402: </a></span>            row[4] = getBytes(fbTablePrivileges.getString(&quot;GRANTEE&quot;));
<span class="nocode"><a name="3403">3403: </a></span>            String privilege = fbTablePrivileges.getString(&quot;PRIVILEGE&quot;);
<span class="nocode"><a name="3404">3404: </a></span>            if (privilege.equals(&quot;A&quot;))
<span class="nocode"><a name="3405">3405: </a></span>                row[5] = getBytes(&quot;ALL&quot;);
<span class="nocode"><a name="3406">3406: </a></span>            else if (privilege.equals(&quot;S&quot;))
<span class="nocode"><a name="3407">3407: </a></span>                row[5] = getBytes(&quot;SELECT&quot;);
<span class="nocode"><a name="3408">3408: </a></span>            else if (privilege.equals(&quot;D&quot;))
<span class="nocode"><a name="3409">3409: </a></span>                row[5] = getBytes(&quot;DELETE&quot;);
<span class="nocode"><a name="3410">3410: </a></span>            else if (privilege.equals(&quot;I&quot;))
<span class="nocode"><a name="3411">3411: </a></span>                row[5] = getBytes(&quot;INSERT&quot;);
<span class="nocode"><a name="3412">3412: </a></span>            else if (privilege.equals(&quot;U&quot;))
<span class="nocode"><a name="3413">3413: </a></span>                row[5] = getBytes(&quot;UPDATE&quot;);
<span class="nocode"><a name="3414">3414: </a></span>            else if (privilege.equals(&quot;R&quot;))
<span class="nocode"><a name="3415">3415: </a></span>                row[5] = getBytes(&quot;REFERENCE&quot;); // TODO: JDBC spec specifies REFRENCES (yes: typo and + S)
<span class="nocode"><a name="3416">3416: </a></span>            else if (privilege.equals(&quot;M&quot;))
<span class="nocode"><a name="3417">3417: </a></span>                row[5] = getBytes(&quot;MEMBEROF&quot;);
<span class="nocode"><a name="3418">3418: </a></span>            int isGrantable = fbTablePrivileges.getShort(&quot;IS_GRANTABLE&quot;);
<span class="nocode"><a name="3419">3419: </a></span>            if (isGrantable==0)
<span class="nocode"><a name="3420">3420: </a></span>                row[6] = getBytes(&quot;NO&quot;);
<span class="nocode"><a name="3421">3421: </a></span>            else
<span class="nocode"><a name="3422">3422: </a></span>                row[6] = getBytes(&quot;YES&quot;);
<span class="nocode"><a name="3423">3423: </a></span>
<span class="nocode"><a name="3424">3424: </a></span>            rows.add(row);
<span class="nocode"><a name="3425">3425: </a></span>        } while (fbTablePrivileges.next());
<span class="nocode"><a name="3426">3426: </a></span>        
<span class="nocode"><a name="3427">3427: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3428">3428: </a></span>    }
<span class="nocode"><a name="3429">3429: </a></span>
<span class="nocode"><a name="3430">3430: </a></span>    private static final String GET_BEST_ROW_IDENT = &quot;&quot; +
<span class="nocode"><a name="3431">3431: </a></span>        &quot;select &quot; +
<span class="nocode"><a name="3432">3432: </a></span>        &quot;    rf.rdb$field_name as column_name, &quot; +
<span class="nocode"><a name="3433">3433: </a></span>        &quot;    f.rdb$field_type as field_type, &quot; +
<span class="nocode"><a name="3434">3434: </a></span>        &quot;    f.rdb$field_sub_type as field_sub_type, &quot; +
<span class="nocode"><a name="3435">3435: </a></span>        &quot;    f.rdb$field_scale as field_scale, &quot; +
<span class="nocode"><a name="3436">3436: </a></span>        &quot;    f.rdb$field_precision as field_precision &quot; +
<span class="nocode"><a name="3437">3437: </a></span>        &quot;from &quot; +
<span class="nocode"><a name="3438">3438: </a></span>        &quot;    rdb$relation_constraints rc,&quot; +
<span class="nocode"><a name="3439">3439: </a></span>        &quot;    rdb$index_segments idx,&quot; +
<span class="nocode"><a name="3440">3440: </a></span>        &quot;    rdb$relation_fields rf,&quot; +
<span class="nocode"><a name="3441">3441: </a></span>        &quot;    rdb$fields f &quot; +
<span class="nocode"><a name="3442">3442: </a></span>        &quot;where &quot; +
<span class="nocode"><a name="3443">3443: </a></span>        &quot;    rc.rdb$relation_name = ? &quot; +
<span class="nocode"><a name="3444">3444: </a></span>        &quot;and &quot; +
<span class="nocode"><a name="3445">3445: </a></span>        &quot;    rc.rdb$constraint_type = 'PRIMARY KEY' &quot; +
<span class="nocode"><a name="3446">3446: </a></span>        &quot;and &quot; +
<span class="nocode"><a name="3447">3447: </a></span>        &quot;    idx.rdb$index_name = rc.rdb$index_name &quot; +
<span class="nocode"><a name="3448">3448: </a></span>        &quot;and &quot; +
<span class="nocode"><a name="3449">3449: </a></span>        &quot;    rf.rdb$field_name = idx.rdb$field_name &quot; +
<span class="nocode"><a name="3450">3450: </a></span>        &quot;and &quot; +
<span class="nocode"><a name="3451">3451: </a></span>        &quot;    rf.rdb$relation_name = ? &quot; +
<span class="nocode"><a name="3452">3452: </a></span>        &quot;and &quot; +
<span class="nocode"><a name="3453">3453: </a></span>        &quot;    f.rdb$field_name = rf.rdb$field_source&quot;
<span class="nocode"><a name="3454">3454: </a></span>        ;
<span class="nocode"><a name="3455">3455: </a></span>
<span class="nocode"><a name="3456">3456: </a></span>    /**
<span class="nocode"><a name="3457">3457: </a></span>     * Gets a description of a table's optimal set of columns that
<span class="nocode"><a name="3458">3458: </a></span>     * uniquely identifies a row. They are ordered by SCOPE.
<span class="nocode"><a name="3459">3459: </a></span>     *
<span class="nocode"><a name="3460">3460: </a></span>     * &lt;P&gt;Each column description has the following columns:
<span class="nocode"><a name="3461">3461: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3462">3462: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short =&gt; actual scope of result
<span class="nocode"><a name="3463">3463: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3464">3464: </a></span>     *      &lt;LI&gt; bestRowTemporary - very temporary, while using row
<span class="nocode"><a name="3465">3465: </a></span>     *      &lt;LI&gt; bestRowTransaction - valid for remainder of current transaction
<span class="nocode"><a name="3466">3466: </a></span>     *      &lt;LI&gt; bestRowSession - valid for remainder of current session
<span class="nocode"><a name="3467">3467: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3468">3468: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name
<span class="nocode"><a name="3469">3469: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; short =&gt; SQL data type from java.sql.Types
<span class="nocode"><a name="3470">3470: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; Data source dependent type name,
<span class="nocode"><a name="3471">3471: </a></span>     *  for a UDT the type name is fully qualified
<span class="nocode"><a name="3472">3472: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&gt; precision
<span class="nocode"><a name="3473">3473: </a></span>     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int =&gt; not used
<span class="nocode"><a name="3474">3474: </a></span>     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short  =&gt; scale
<span class="nocode"><a name="3475">3475: </a></span>     *  &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short =&gt; is this a pseudo column
<span class="nocode"><a name="3476">3476: </a></span>     *      like an Oracle ROWID
<span class="nocode"><a name="3477">3477: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3478">3478: </a></span>     *      &lt;LI&gt; bestRowUnknown - may or may not be pseudo column
<span class="nocode"><a name="3479">3479: </a></span>     *      &lt;LI&gt; bestRowNotPseudo - is NOT a pseudo column
<span class="nocode"><a name="3480">3480: </a></span>     *      &lt;LI&gt; bestRowPseudo - is a pseudo column
<span class="nocode"><a name="3481">3481: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3482">3482: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3483">3483: </a></span>     *
<span class="nocode"><a name="3484">3484: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3485">3485: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3486">3486: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those without a schema
<span class="nocode"><a name="3487">3487: </a></span>     * @param table a table name
<span class="nocode"><a name="3488">3488: </a></span>     * @param scope the scope of interest; use same values as SCOPE
<span class="nocode"><a name="3489">3489: </a></span>     * @param nullable include columns that are nullable?
<span class="nocode"><a name="3490">3490: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
<span class="nocode"><a name="3491">3491: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3492">3492: </a></span>     */
<span class="nocode"><a name="3493">3493: </a></span>    public ResultSet getBestRowIdentifier(String catalog, String schema,
<span class="nocode"><a name="3494">3494: </a></span>        String table, int scope, boolean nullable) throws SQLException {
<span class="nocode"><a name="3495">3495: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[8];
<span class="nocode"><a name="3496">3496: </a></span>
<span class="nocode"><a name="3497">3497: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3498">3498: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3499">3499: </a></span>        xsqlvars[0].sqlname = &quot;SCOPE&quot;;
<span class="nocode"><a name="3500">3500: </a></span>        xsqlvars[0].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3501">3501: </a></span>
<span class="nocode"><a name="3502">3502: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3503">3503: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3504">3504: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3505">3505: </a></span>        xsqlvars[1].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="3506">3506: </a></span>        xsqlvars[1].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3507">3507: </a></span>
<span class="nocode"><a name="3508">3508: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3509">3509: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3510">3510: </a></span>        xsqlvars[2].sqlname = &quot;DATA_TYPE&quot;;
<span class="nocode"><a name="3511">3511: </a></span>        xsqlvars[2].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3512">3512: </a></span>
<span class="nocode"><a name="3513">3513: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3514">3514: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3515">3515: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3516">3516: </a></span>        xsqlvars[3].sqlname = &quot;TYPE_NAME&quot;;
<span class="nocode"><a name="3517">3517: </a></span>        xsqlvars[3].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3518">3518: </a></span>
<span class="nocode"><a name="3519">3519: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3520">3520: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="3521">3521: </a></span>        xsqlvars[4].sqlname = &quot;COLUMN_SIZE&quot;;
<span class="nocode"><a name="3522">3522: </a></span>        xsqlvars[4].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3523">3523: </a></span>
<span class="nocode"><a name="3524">3524: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3525">3525: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="3526">3526: </a></span>        xsqlvars[5].sqlname = &quot;BUFFER_LENGTH&quot;;
<span class="nocode"><a name="3527">3527: </a></span>        xsqlvars[5].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3528">3528: </a></span>
<span class="nocode"><a name="3529">3529: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="3530">3530: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3531">3531: </a></span>        xsqlvars[6].sqlname = &quot;DECIMAL_DIGITS&quot;;
<span class="nocode"><a name="3532">3532: </a></span>        xsqlvars[6].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3533">3533: </a></span>
<span class="nocode"><a name="3534">3534: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="3535">3535: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3536">3536: </a></span>        xsqlvars[7].sqlname = &quot;PSEUDO_COLUMN&quot;;
<span class="nocode"><a name="3537">3537: </a></span>        xsqlvars[7].relname = &quot;ROWIDENTIFIER&quot;;
<span class="nocode"><a name="3538">3538: </a></span>
<span class="nocode"><a name="3539">3539: </a></span>        ResultSet tables = getTables(catalog, schema, table, null);
<span class="nocode"><a name="3540">3540: </a></span>        
<span class="nocode"><a name="3541">3541: </a></span>        if (!tables.next())
<span class="nocode"><a name="3542">3542: </a></span>            return new FBResultSet(xsqlvars, new ArrayList&lt;byte[][]&gt;());
<span class="nocode"><a name="3543">3543: </a></span>        
<span class="nocode"><a name="3544">3544: </a></span>        List&lt;byte[][]&gt; rows = getPrimaryKeyIdentifier(tables.getString(3), scope, xsqlvars);
<span class="nocode"><a name="3545">3545: </a></span>
<span class="nocode"><a name="3546">3546: </a></span>        // if no primary key exists, add RDB$DB_KEY as pseudo-column
<span class="nocode"><a name="3547">3547: </a></span>        if (rows.size() == 0) {
<span class="nocode"><a name="3548">3548: </a></span>            byte[][] row = new byte[8][];
<span class="nocode"><a name="3549">3549: </a></span>            row[0] = xsqlvars[0].encodeShort((short)scope);
<span class="nocode"><a name="3550">3550: </a></span>            row[1] = getBytes(&quot;RDB$DB_KEY&quot;);
<span class="nocode"><a name="3551">3551: </a></span>            row[2] = xsqlvars[0].encodeShort((short)getDataType(char_type, (short)0, (short)0));
<span class="nocode"><a name="3552">3552: </a></span>            row[3] = getBytes(getDataTypeName(char_type, (short)0, (short)0));
<span class="nocode"><a name="3553">3553: </a></span>            row[4] = xsqlvars[0].encodeInt(0);
<span class="nocode"><a name="3554">3554: </a></span>            row[5] = null;
<span class="nocode"><a name="3555">3555: </a></span>            row[6] = xsqlvars[0].encodeShort((short)0);
<span class="nocode"><a name="3556">3556: </a></span>            row[7] = xsqlvars[0].encodeShort((short)bestRowPseudo);
<span class="nocode"><a name="3557">3557: </a></span>
<span class="nocode"><a name="3558">3558: </a></span>            rows.add(row);
<span class="nocode"><a name="3559">3559: </a></span>        }
<span class="nocode"><a name="3560">3560: </a></span>        
<span class="nocode"><a name="3561">3561: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3562">3562: </a></span>    }
<span class="nocode"><a name="3563">3563: </a></span>
<span class="nocode"><a name="3564">3564: </a></span>
<span class="nocode"><a name="3565">3565: </a></span>    /**
<span class="nocode"><a name="3566">3566: </a></span>     * Get primary key of the table as best row identifier.
<span class="nocode"><a name="3567">3567: </a></span>     * 
<span class="nocode"><a name="3568">3568: </a></span>     * @param table name of the table.
<span class="nocode"><a name="3569">3569: </a></span>     * @param scope scope, we just include it in the result set.
<span class="nocode"><a name="3570">3570: </a></span>     * @param xsqlvars array of {@link XSQLVAR} instances describing result set.
<span class="nocode"><a name="3571">3571: </a></span>     * 
<span class="nocode"><a name="3572">3572: </a></span>     * @return list of result set values, when size is 0, no primary key has 
<span class="nocode"><a name="3573">3573: </a></span>     * been defined for a table.
<span class="nocode"><a name="3574">3574: </a></span>     * 
<span class="nocode"><a name="3575">3575: </a></span>     * @throws SQLException if something went wrong.
<span class="nocode"><a name="3576">3576: </a></span>     */
<span class="nocode"><a name="3577">3577: </a></span>    private List&lt;byte[][]&gt; getPrimaryKeyIdentifier(String table, int scope, XSQLVAR[] xsqlvars) throws SQLException {
<span class="nocode"><a name="3578">3578: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="3579">3579: </a></span>
<span class="nocode"><a name="3580">3580: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;(2);
<span class="nocode"><a name="3581">3581: </a></span>        params.add(table);
<span class="nocode"><a name="3582">3582: </a></span>        params.add(table);
<span class="nocode"><a name="3583">3583: </a></span>        
<span class="nocode"><a name="3584">3584: </a></span>        ResultSet rs = doQuery(GET_BEST_ROW_IDENT, params);
<span class="nocode"><a name="3585">3585: </a></span>        
<span class="nocode"><a name="3586">3586: </a></span>        while (rs.next()) {
<span class="nocode"><a name="3587">3587: </a></span>            byte[][] row = new byte[8][];
<span class="nocode"><a name="3588">3588: </a></span>            row[0] = xsqlvars[0].encodeShort((short)scope);
<span class="nocode"><a name="3589">3589: </a></span>            row[1] = getBytes(rs.getString(&quot;COLUMN_NAME&quot;));
<span class="nocode"><a name="3590">3590: </a></span>            row[2] = xsqlvars[0].encodeShort((short)getDataType(rs.getShort(&quot;FIELD_TYPE&quot;), 
<span class="nocode"><a name="3591">3591: </a></span>                rs.getShort(&quot;FIELD_SUB_TYPE&quot;), rs.getShort(&quot;FIELD_SCALE&quot;)));
<span class="nocode"><a name="3592">3592: </a></span>            row[3] = getBytes(getDataTypeName(rs.getShort(&quot;FIELD_TYPE&quot;), 
<span class="nocode"><a name="3593">3593: </a></span>                rs.getShort(&quot;FIELD_SUB_TYPE&quot;), rs.getShort(&quot;FIELD_SCALE&quot;)));
<span class="nocode"><a name="3594">3594: </a></span>            row[4] = xsqlvars[0].encodeInt(rs.getInt(&quot;FIELD_PRECISION&quot;));
<span class="nocode"><a name="3595">3595: </a></span>            row[5] = null;
<span class="nocode"><a name="3596">3596: </a></span>            row[6] = xsqlvars[0].encodeShort(rs.getShort(&quot;FIELD_SCALE&quot;));
<span class="nocode"><a name="3597">3597: </a></span>            row[7] = xsqlvars[0].encodeShort((short)bestRowNotPseudo);
<span class="nocode"><a name="3598">3598: </a></span>
<span class="nocode"><a name="3599">3599: </a></span>            rows.add(row);
<span class="nocode"><a name="3600">3600: </a></span>        }
<span class="nocode"><a name="3601">3601: </a></span>        return rows;
<span class="nocode"><a name="3602">3602: </a></span>    }
<span class="nocode"><a name="3603">3603: </a></span>
<span class="nocode"><a name="3604">3604: </a></span>    /**
<span class="nocode"><a name="3605">3605: </a></span>     * Gets a description of a table's columns that are automatically
<span class="nocode"><a name="3606">3606: </a></span>     * updated when any value in a row is updated.  They are
<span class="nocode"><a name="3607">3607: </a></span>     * unordered.
<span class="nocode"><a name="3608">3608: </a></span>     *
<span class="nocode"><a name="3609">3609: </a></span>     * &lt;P&gt;Each column description has the following columns:
<span class="nocode"><a name="3610">3610: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3611">3611: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCOPE&lt;/B&gt; short =&gt; is not used
<span class="nocode"><a name="3612">3612: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name
<span class="nocode"><a name="3613">3613: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; short =&gt; SQL data type from java.sql.Types
<span class="nocode"><a name="3614">3614: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; Data source dependent type name
<span class="nocode"><a name="3615">3615: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_SIZE&lt;/B&gt; int =&gt; precision
<span class="nocode"><a name="3616">3616: </a></span>     *  &lt;LI&gt;&lt;B&gt;BUFFER_LENGTH&lt;/B&gt; int =&gt; length of column value in bytes
<span class="nocode"><a name="3617">3617: </a></span>     *  &lt;LI&gt;&lt;B&gt;DECIMAL_DIGITS&lt;/B&gt; short  =&gt; scale
<span class="nocode"><a name="3618">3618: </a></span>     *  &lt;LI&gt;&lt;B&gt;PSEUDO_COLUMN&lt;/B&gt; short =&gt; is this a pseudo column
<span class="nocode"><a name="3619">3619: </a></span>     *      like an Oracle ROWID
<span class="nocode"><a name="3620">3620: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3621">3621: </a></span>     *      &lt;LI&gt; versionColumnUnknown - may or may not be pseudo column
<span class="nocode"><a name="3622">3622: </a></span>     *      &lt;LI&gt; versionColumnNotPseudo - is NOT a pseudo column
<span class="nocode"><a name="3623">3623: </a></span>     *      &lt;LI&gt; versionColumnPseudo - is a pseudo column
<span class="nocode"><a name="3624">3624: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3625">3625: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3626">3626: </a></span>     *
<span class="nocode"><a name="3627">3627: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3628">3628: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3629">3629: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those without a schema
<span class="nocode"><a name="3630">3630: </a></span>     * @param table a table name
<span class="nocode"><a name="3631">3631: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a column description
<span class="nocode"><a name="3632">3632: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3633">3633: </a></span>     */
<span class="nocode"><a name="3634">3634: </a></span>    public ResultSet getVersionColumns(String catalog, String schema,
<span class="nocode"><a name="3635">3635: </a></span>                String table) throws SQLException {
<span class="nocode"><a name="3636">3636: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[8];
<span class="nocode"><a name="3637">3637: </a></span>
<span class="nocode"><a name="3638">3638: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3639">3639: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3640">3640: </a></span>        xsqlvars[0].sqlname = &quot;SCOPE&quot;;
<span class="nocode"><a name="3641">3641: </a></span>        xsqlvars[0].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3642">3642: </a></span>
<span class="nocode"><a name="3643">3643: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3644">3644: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3645">3645: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3646">3646: </a></span>        xsqlvars[1].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="3647">3647: </a></span>        xsqlvars[1].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3648">3648: </a></span>
<span class="nocode"><a name="3649">3649: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3650">3650: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3651">3651: </a></span>        xsqlvars[2].sqlname = &quot;DATA_TYPE&quot;;
<span class="nocode"><a name="3652">3652: </a></span>        xsqlvars[2].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3653">3653: </a></span>
<span class="nocode"><a name="3654">3654: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3655">3655: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3656">3656: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3657">3657: </a></span>        xsqlvars[3].sqlname = &quot;TYPE_NAME&quot;;
<span class="nocode"><a name="3658">3658: </a></span>        xsqlvars[3].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3659">3659: </a></span>
<span class="nocode"><a name="3660">3660: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3661">3661: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="3662">3662: </a></span>        xsqlvars[4].sqlname = &quot;COLUMN_SIZE&quot;;
<span class="nocode"><a name="3663">3663: </a></span>        xsqlvars[4].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3664">3664: </a></span>
<span class="nocode"><a name="3665">3665: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3666">3666: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="3667">3667: </a></span>        xsqlvars[5].sqlname = &quot;BUFFER_LENGTH&quot;;
<span class="nocode"><a name="3668">3668: </a></span>        xsqlvars[5].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3669">3669: </a></span>
<span class="nocode"><a name="3670">3670: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="3671">3671: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3672">3672: </a></span>        xsqlvars[6].sqlname = &quot;DECIMAL_DIGITS&quot;;
<span class="nocode"><a name="3673">3673: </a></span>        xsqlvars[6].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3674">3674: </a></span>
<span class="nocode"><a name="3675">3675: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="3676">3676: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3677">3677: </a></span>        xsqlvars[7].sqlname = &quot;PSEUDO_COLUMN&quot;;
<span class="nocode"><a name="3678">3678: </a></span>        xsqlvars[7].relname = &quot;VERSIONCOL&quot;;
<span class="nocode"><a name="3679">3679: </a></span>
<span class="nocode"><a name="3680">3680: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="3681">3681: </a></span>
<span class="nocode"><a name="3682">3682: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3683">3683: </a></span>    }
<span class="nocode"><a name="3684">3684: </a></span>
<span class="nocode"><a name="3685">3685: </a></span>
<span class="nocode"><a name="3686">3686: </a></span>    private static final String GET_PRIMARY_KEYS_START = &quot;select &quot;
<span class="nocode"><a name="3687">3687: </a></span>        + &quot; null as TABLE_CAT, &quot;
<span class="nocode"><a name="3688">3688: </a></span>        + &quot; null as TABLE_SCHEM, &quot;
<span class="nocode"><a name="3689">3689: </a></span>        + &quot;RC.RDB$RELATION_NAME as TABLE_NAME, &quot;
<span class="nocode"><a name="3690">3690: </a></span>        + &quot;ISGMT.RDB$FIELD_NAME as COLUMN_NAME, &quot;
<span class="nocode"><a name="3691">3691: </a></span>        + &quot;CAST ((ISGMT.RDB$FIELD_POSITION + 1) as SMALLINT) as KEY_SEQ, &quot;
<span class="nocode"><a name="3692">3692: </a></span>        + &quot;RC.RDB$CONSTRAINT_NAME as PK_NAME &quot;
<span class="nocode"><a name="3693">3693: </a></span>        + &quot;from &quot;
<span class="nocode"><a name="3694">3694: </a></span>        + &quot;RDB$RELATION_CONSTRAINTS RC, &quot;
<span class="nocode"><a name="3695">3695: </a></span>        + &quot;RDB$INDEX_SEGMENTS ISGMT &quot;
<span class="nocode"><a name="3696">3696: </a></span>        + &quot;where &quot;;
<span class="nocode"><a name="3697">3697: </a></span>
<span class="nocode"><a name="3698">3698: </a></span>    private static final String GET_PRIMARY_KEYS_END =
<span class="nocode"><a name="3699">3699: </a></span>        &quot;RC.RDB$INDEX_NAME = ISGMT.RDB$INDEX_NAME and &quot;
<span class="nocode"><a name="3700">3700: </a></span>        + &quot;RC.RDB$CONSTRAINT_TYPE = 'PRIMARY KEY' &quot;
<span class="nocode"><a name="3701">3701: </a></span>        + &quot;order by ISGMT.RDB$FIELD_NAME &quot;;
<span class="nocode"><a name="3702">3702: </a></span>
<span class="nocode"><a name="3703">3703: </a></span>    /**
<span class="nocode"><a name="3704">3704: </a></span>     * Gets a description of a table's primary key columns.  They
<span class="nocode"><a name="3705">3705: </a></span>     * are ordered by COLUMN_NAME.
<span class="nocode"><a name="3706">3706: </a></span>     *
<span class="nocode"><a name="3707">3707: </a></span>     * &lt;P&gt;Each primary key column description has the following columns:
<span class="nocode"><a name="3708">3708: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3709">3709: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be null)
<span class="nocode"><a name="3710">3710: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be null)
<span class="nocode"><a name="3711">3711: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="3712">3712: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name
<span class="nocode"><a name="3713">3713: </a></span>     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&gt; sequence number within primary key
<span class="nocode"><a name="3714">3714: </a></span>     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&gt; primary key name (may be null)
<span class="nocode"><a name="3715">3715: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3716">3716: </a></span>     *
<span class="nocode"><a name="3717">3717: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3718">3718: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3719">3719: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those
<span class="nocode"><a name="3720">3720: </a></span>     * without a schema
<span class="nocode"><a name="3721">3721: </a></span>     * @param table a table name
<span class="nocode"><a name="3722">3722: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a primary key column description
<span class="nocode"><a name="3723">3723: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3724">3724: </a></span>     */
<span class="nocode"><a name="3725">3725: </a></span>    public ResultSet getPrimaryKeys(String catalog, String schema,
<span class="nocode"><a name="3726">3726: </a></span>                String table) throws SQLException {
<span class="nocode"><a name="3727">3727: </a></span>        checkCatalogAndSchema(catalog, schema);
<span class="nocode"><a name="3728">3728: </a></span>
<span class="nocode"><a name="3729">3729: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[6];
<span class="nocode"><a name="3730">3730: </a></span>
<span class="nocode"><a name="3731">3731: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3732">3732: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3733">3733: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="3734">3734: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="3735">3735: </a></span>        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3736">3736: </a></span>
<span class="nocode"><a name="3737">3737: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3738">3738: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3739">3739: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3740">3740: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="3741">3741: </a></span>        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3742">3742: </a></span>
<span class="nocode"><a name="3743">3743: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3744">3744: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3745">3745: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="3746">3746: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="3747">3747: </a></span>        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3748">3748: </a></span>
<span class="nocode"><a name="3749">3749: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3750">3750: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3751">3751: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3752">3752: </a></span>        xsqlvars[3].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="3753">3753: </a></span>        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3754">3754: </a></span>
<span class="nocode"><a name="3755">3755: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3756">3756: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3757">3757: </a></span>        xsqlvars[4].sqlname = &quot;KEY_SEQ&quot;;
<span class="nocode"><a name="3758">3758: </a></span>        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3759">3759: </a></span>
<span class="nocode"><a name="3760">3760: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3761">3761: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3762">3762: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="3763">3763: </a></span>        xsqlvars[5].sqlname = &quot;PK_NAME&quot;;
<span class="nocode"><a name="3764">3764: </a></span>        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3765">3765: </a></span>
<span class="nocode"><a name="3766">3766: </a></span>        Clause tableClause = new Clause(&quot;RC.RDB$RELATION_NAME&quot;, table);
<span class="nocode"><a name="3767">3767: </a></span>
<span class="nocode"><a name="3768">3768: </a></span>        String sql = GET_PRIMARY_KEYS_START;
<span class="nocode"><a name="3769">3769: </a></span>        sql += tableClause.getCondition();
<span class="nocode"><a name="3770">3770: </a></span>        sql += GET_PRIMARY_KEYS_END;
<span class="nocode"><a name="3771">3771: </a></span>        
<span class="nocode"><a name="3772">3772: </a></span>        // check the original case identifiers
<span class="nocode"><a name="3773">3773: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="3774">3774: </a></span>        if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3775">3775: </a></span>            params.add(tableClause.getOriginalCaseValue());
<span class="nocode"><a name="3776">3776: </a></span>        }
<span class="nocode"><a name="3777">3777: </a></span>        
<span class="nocode"><a name="3778">3778: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="3779">3779: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="3780">3780: </a></span>        
<span class="nocode"><a name="3781">3781: </a></span>        // if nothing found, check the uppercased identifier
<span class="nocode"><a name="3782">3782: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="3783">3783: </a></span>            params.clear();
<span class="nocode"><a name="3784">3784: </a></span>            if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="3785">3785: </a></span>                params.add(tableClause.getValue());
<span class="nocode"><a name="3786">3786: </a></span>            }
<span class="nocode"><a name="3787">3787: </a></span>            
<span class="nocode"><a name="3788">3788: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="3789">3789: </a></span>            
<span class="nocode"><a name="3790">3790: </a></span>            // if nothing found, return empty result set
<span class="nocode"><a name="3791">3791: </a></span>            if (!rs.next()) 
<span class="nocode"><a name="3792">3792: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3793">3793: </a></span>        }
<span class="nocode"><a name="3794">3794: </a></span>        
<span class="nocode"><a name="3795">3795: </a></span>        do {
<span class="nocode"><a name="3796">3796: </a></span>            byte[][] row = new byte[6][];
<span class="nocode"><a name="3797">3797: </a></span>            row[0] = null;
<span class="nocode"><a name="3798">3798: </a></span>            row[1] = null;
<span class="nocode"><a name="3799">3799: </a></span>            row[2] = getBytes(rs.getString(&quot;TABLE_NAME&quot;));
<span class="nocode"><a name="3800">3800: </a></span>            row[3] = getBytes(rs.getString(&quot;COLUMN_NAME&quot;));
<span class="nocode"><a name="3801">3801: </a></span>            row[4] = xsqlvars[0].encodeShort(rs.getShort(&quot;KEY_SEQ&quot;));
<span class="nocode"><a name="3802">3802: </a></span>            row[5] = getBytes(rs.getString(&quot;PK_NAME&quot;));
<span class="nocode"><a name="3803">3803: </a></span>
<span class="nocode"><a name="3804">3804: </a></span>            rows.add(row);
<span class="nocode"><a name="3805">3805: </a></span>        } while(rs.next());
<span class="nocode"><a name="3806">3806: </a></span>        
<span class="nocode"><a name="3807">3807: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="3808">3808: </a></span>    }
<span class="nocode"><a name="3809">3809: </a></span>
<span class="nocode"><a name="3810">3810: </a></span>
<span class="nocode"><a name="3811">3811: </a></span>    private static final String GET_IMPORTED_KEYS_START = &quot;select&quot;
<span class="nocode"><a name="3812">3812: </a></span>    +&quot; null as PKTABLE_CAT &quot;
<span class="nocode"><a name="3813">3813: </a></span>    +&quot; ,null as PKTABLE_SCHEM &quot;
<span class="nocode"><a name="3814">3814: </a></span>    +&quot; ,PK.RDB$RELATION_NAME as PKTABLE_NAME &quot;
<span class="nocode"><a name="3815">3815: </a></span>    +&quot; ,ISP.RDB$FIELD_NAME as PKCOLUMN_NAME &quot;
<span class="nocode"><a name="3816">3816: </a></span>    +&quot; ,null as FKTABLE_CAT &quot;
<span class="nocode"><a name="3817">3817: </a></span>    +&quot; ,null as FKTABLE_SCHEM &quot;
<span class="nocode"><a name="3818">3818: </a></span>    +&quot; ,FK.RDB$RELATION_NAME as FKTABLE_NAME &quot;
<span class="nocode"><a name="3819">3819: </a></span>    +&quot; ,ISF.RDB$FIELD_NAME as FKCOLUMN_NAME &quot;
<span class="nocode"><a name="3820">3820: </a></span>    +&quot; ,CAST ((ISP.RDB$FIELD_POSITION + 1) as SMALLINT) as KEY_SEQ &quot;
<span class="nocode"><a name="3821">3821: </a></span>    +&quot; ,RC.RDB$UPDATE_RULE as UPDATE_RULE &quot;
<span class="nocode"><a name="3822">3822: </a></span>    +&quot; ,RC.RDB$DELETE_RULE as DELETE_RULE &quot;
<span class="nocode"><a name="3823">3823: </a></span>    +&quot; ,PK.RDB$CONSTRAINT_NAME as PK_NAME &quot;
<span class="nocode"><a name="3824">3824: </a></span>    +&quot; ,FK.RDB$CONSTRAINT_NAME as FK_NAME &quot;
<span class="nocode"><a name="3825">3825: </a></span>    +&quot; ,null as DEFERRABILITY &quot;
<span class="nocode"><a name="3826">3826: </a></span>    +&quot; from &quot;
<span class="nocode"><a name="3827">3827: </a></span>    +&quot; RDB$RELATION_CONSTRAINTS PK &quot;
<span class="nocode"><a name="3828">3828: </a></span>    +&quot; ,RDB$RELATION_CONSTRAINTS FK &quot;
<span class="nocode"><a name="3829">3829: </a></span>    +&quot; ,RDB$REF_CONSTRAINTS RC &quot;
<span class="nocode"><a name="3830">3830: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISP &quot;
<span class="nocode"><a name="3831">3831: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISF &quot;
<span class="nocode"><a name="3832">3832: </a></span>    +&quot; WHERE &quot;;
<span class="nocode"><a name="3833">3833: </a></span>
<span class="nocode"><a name="3834">3834: </a></span>    private static final String GET_IMPORTED_KEYS_END =
<span class="nocode"><a name="3835">3835: </a></span>    &quot; FK.RDB$CONSTRAINT_NAME = RC.RDB$CONSTRAINT_NAME &quot;
<span class="nocode"><a name="3836">3836: </a></span>    +&quot; and PK.RDB$CONSTRAINT_NAME = RC.RDB$CONST_NAME_UQ &quot;
<span class="nocode"><a name="3837">3837: </a></span>    +&quot; and ISP.RDB$INDEX_NAME = PK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="3838">3838: </a></span>    +&quot; and ISF.RDB$INDEX_NAME = FK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="3839">3839: </a></span>    +&quot; and ISP.RDB$FIELD_POSITION = ISF.RDB$FIELD_POSITION &quot;
<span class="nocode"><a name="3840">3840: </a></span>    +&quot; order by 3, 9 &quot;;
<span class="nocode"><a name="3841">3841: </a></span>
<span class="nocode"><a name="3842">3842: </a></span>    /**
<span class="nocode"><a name="3843">3843: </a></span>     * Gets a description of the primary key columns that are
<span class="nocode"><a name="3844">3844: </a></span>     * referenced by a table's foreign key columns (the primary keys
<span class="nocode"><a name="3845">3845: </a></span>     * imported by a table).  They are ordered by PKTABLE_CAT,
<span class="nocode"><a name="3846">3846: </a></span>     * PKTABLE_SCHEM, PKTABLE_NAME, and KEY_SEQ.
<span class="nocode"><a name="3847">3847: </a></span>     *
<span class="nocode"><a name="3848">3848: </a></span>     * &lt;P&gt;Each primary key column description has the following columns:
<span class="nocode"><a name="3849">3849: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="3850">3850: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&gt; primary key table catalog
<span class="nocode"><a name="3851">3851: </a></span>     *      being imported (may be null)
<span class="nocode"><a name="3852">3852: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&gt; primary key table schema
<span class="nocode"><a name="3853">3853: </a></span>     *      being imported (may be null)
<span class="nocode"><a name="3854">3854: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&gt; primary key table name
<span class="nocode"><a name="3855">3855: </a></span>     *      being imported
<span class="nocode"><a name="3856">3856: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&gt; primary key column name
<span class="nocode"><a name="3857">3857: </a></span>     *      being imported
<span class="nocode"><a name="3858">3858: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&gt; foreign key table catalog (may be null)
<span class="nocode"><a name="3859">3859: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&gt; foreign key table schema (may be null)
<span class="nocode"><a name="3860">3860: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&gt; foreign key table name
<span class="nocode"><a name="3861">3861: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&gt; foreign key column name
<span class="nocode"><a name="3862">3862: </a></span>     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&gt; sequence number within foreign key
<span class="nocode"><a name="3863">3863: </a></span>     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="3864">3864: </a></span>     *       foreign key when primary is updated:
<span class="nocode"><a name="3865">3865: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3866">3866: </a></span>     *      &lt;LI&gt; importedNoAction - do not allow update of primary
<span class="nocode"><a name="3867">3867: </a></span>     *               key if it has been imported
<span class="nocode"><a name="3868">3868: </a></span>     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
<span class="nocode"><a name="3869">3869: </a></span>     *               with primary key update
<span class="nocode"><a name="3870">3870: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="3871">3871: </a></span>     *               its primary key has been updated
<span class="nocode"><a name="3872">3872: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
<span class="nocode"><a name="3873">3873: </a></span>     *               if its primary key has been updated
<span class="nocode"><a name="3874">3874: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="3875">3875: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="3876">3876: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3877">3877: </a></span>     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="3878">3878: </a></span>     *      the foreign key when primary is deleted.
<span class="nocode"><a name="3879">3879: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3880">3880: </a></span>     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of primary
<span class="nocode"><a name="3881">3881: </a></span>     *               key if it has been imported
<span class="nocode"><a name="3882">3882: </a></span>     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
<span class="nocode"><a name="3883">3883: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="3884">3884: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="3885">3885: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="3886">3886: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="3887">3887: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
<span class="nocode"><a name="3888">3888: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="3889">3889: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3890">3890: </a></span>     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&gt; foreign key name (may be null)
<span class="nocode"><a name="3891">3891: </a></span>     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&gt; primary key name (may be null)
<span class="nocode"><a name="3892">3892: </a></span>     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&gt; can the evaluation of foreign key
<span class="nocode"><a name="3893">3893: </a></span>     *      constraints be deferred until commit
<span class="nocode"><a name="3894">3894: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="3895">3895: </a></span>     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
<span class="nocode"><a name="3896">3896: </a></span>     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
<span class="nocode"><a name="3897">3897: </a></span>     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
<span class="nocode"><a name="3898">3898: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="3899">3899: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="3900">3900: </a></span>     *
<span class="nocode"><a name="3901">3901: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="3902">3902: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="3903">3903: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those
<span class="nocode"><a name="3904">3904: </a></span>     * without a schema
<span class="nocode"><a name="3905">3905: </a></span>     * @param table a table name
<span class="nocode"><a name="3906">3906: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a primary key column description
<span class="nocode"><a name="3907">3907: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="3908">3908: </a></span>     * @see #getExportedKeys
<span class="nocode"><a name="3909">3909: </a></span>     */
<span class="nocode"><a name="3910">3910: </a></span>    public ResultSet getImportedKeys(String catalog, String schema,
<span class="nocode"><a name="3911">3911: </a></span>                String table) throws SQLException {
<span class="nocode"><a name="3912">3912: </a></span>        checkCatalogAndSchema(catalog, schema);
<span class="nocode"><a name="3913">3913: </a></span>
<span class="nocode"><a name="3914">3914: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[14];
<span class="nocode"><a name="3915">3915: </a></span>
<span class="nocode"><a name="3916">3916: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="3917">3917: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3918">3918: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="3919">3919: </a></span>        xsqlvars[0].sqlname = &quot;PKTABLE_CAT&quot;;
<span class="nocode"><a name="3920">3920: </a></span>        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3921">3921: </a></span>
<span class="nocode"><a name="3922">3922: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="3923">3923: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3924">3924: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="3925">3925: </a></span>        xsqlvars[1].sqlname = &quot;PKTABLE_SCHEM&quot;;
<span class="nocode"><a name="3926">3926: </a></span>        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3927">3927: </a></span>
<span class="nocode"><a name="3928">3928: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="3929">3929: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3930">3930: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="3931">3931: </a></span>        xsqlvars[2].sqlname = &quot;PKTABLE_NAME&quot;;
<span class="nocode"><a name="3932">3932: </a></span>        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3933">3933: </a></span>
<span class="nocode"><a name="3934">3934: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="3935">3935: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3936">3936: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="3937">3937: </a></span>        xsqlvars[3].sqlname = &quot;PKCOLUMN_NAME&quot;;
<span class="nocode"><a name="3938">3938: </a></span>        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3939">3939: </a></span>
<span class="nocode"><a name="3940">3940: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="3941">3941: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3942">3942: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="3943">3943: </a></span>        xsqlvars[4].sqlname = &quot;FKTABLE_CAT&quot;;
<span class="nocode"><a name="3944">3944: </a></span>        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3945">3945: </a></span>
<span class="nocode"><a name="3946">3946: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="3947">3947: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3948">3948: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="3949">3949: </a></span>        xsqlvars[5].sqlname = &quot;FKTABLE_SCHEM&quot;;
<span class="nocode"><a name="3950">3950: </a></span>        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3951">3951: </a></span>
<span class="nocode"><a name="3952">3952: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="3953">3953: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3954">3954: </a></span>        xsqlvars[6].sqllen = 31;
<span class="nocode"><a name="3955">3955: </a></span>        xsqlvars[6].sqlname = &quot;FKTABLE_NAME&quot;;
<span class="nocode"><a name="3956">3956: </a></span>        xsqlvars[6].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3957">3957: </a></span>
<span class="nocode"><a name="3958">3958: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="3959">3959: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3960">3960: </a></span>        xsqlvars[7].sqllen = 31;
<span class="nocode"><a name="3961">3961: </a></span>        xsqlvars[7].sqlname = &quot;FKCOLUMN_NAME&quot;;
<span class="nocode"><a name="3962">3962: </a></span>        xsqlvars[7].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3963">3963: </a></span>
<span class="nocode"><a name="3964">3964: </a></span>        xsqlvars[8] = new XSQLVAR();
<span class="nocode"><a name="3965">3965: </a></span>        xsqlvars[8].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3966">3966: </a></span>        xsqlvars[8].sqlname = &quot;KEY_SEQ&quot;;
<span class="nocode"><a name="3967">3967: </a></span>        xsqlvars[8].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3968">3968: </a></span>
<span class="nocode"><a name="3969">3969: </a></span>        xsqlvars[9] = new XSQLVAR();
<span class="nocode"><a name="3970">3970: </a></span>        xsqlvars[9].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3971">3971: </a></span>        xsqlvars[9].sqlname = &quot;UPDATE_RULE&quot;;
<span class="nocode"><a name="3972">3972: </a></span>        xsqlvars[9].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3973">3973: </a></span>
<span class="nocode"><a name="3974">3974: </a></span>        xsqlvars[10] = new XSQLVAR();
<span class="nocode"><a name="3975">3975: </a></span>        xsqlvars[10].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3976">3976: </a></span>        xsqlvars[10].sqlname = &quot;DELETE_RULE&quot;;
<span class="nocode"><a name="3977">3977: </a></span>        xsqlvars[10].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3978">3978: </a></span>
<span class="nocode"><a name="3979">3979: </a></span>        xsqlvars[11] = new XSQLVAR();
<span class="nocode"><a name="3980">3980: </a></span>        xsqlvars[11].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3981">3981: </a></span>        xsqlvars[11].sqllen = 31;
<span class="nocode"><a name="3982">3982: </a></span>        xsqlvars[11].sqlname = &quot;FK_NAME&quot;;
<span class="nocode"><a name="3983">3983: </a></span>        xsqlvars[11].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3984">3984: </a></span>
<span class="nocode"><a name="3985">3985: </a></span>        xsqlvars[12] = new XSQLVAR();
<span class="nocode"><a name="3986">3986: </a></span>        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="3987">3987: </a></span>        xsqlvars[12].sqllen = 31;
<span class="nocode"><a name="3988">3988: </a></span>        xsqlvars[12].sqlname = &quot;PK_NAME&quot;;
<span class="nocode"><a name="3989">3989: </a></span>        xsqlvars[12].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3990">3990: </a></span>
<span class="nocode"><a name="3991">3991: </a></span>        xsqlvars[13] = new XSQLVAR();
<span class="nocode"><a name="3992">3992: </a></span>        xsqlvars[13].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="3993">3993: </a></span>        xsqlvars[13].sqlname = &quot;DEFERRABILITY&quot;;
<span class="nocode"><a name="3994">3994: </a></span>        xsqlvars[13].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="3995">3995: </a></span>
<span class="nocode"><a name="3996">3996: </a></span>        Clause tableClause = new Clause(&quot;FK.RDB$RELATION_NAME&quot;, table);
<span class="nocode"><a name="3997">3997: </a></span>        
<span class="nocode"><a name="3998">3998: </a></span>        String sql = GET_IMPORTED_KEYS_START;
<span class="nocode"><a name="3999">3999: </a></span>        sql += tableClause.getCondition();
<span class="nocode"><a name="4000">4000: </a></span>        sql += GET_IMPORTED_KEYS_END;
<span class="nocode"><a name="4001">4001: </a></span>
<span class="nocode"><a name="4002">4002: </a></span>        // check the original case identifiers first
<span class="nocode"><a name="4003">4003: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="4004">4004: </a></span>        if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4005">4005: </a></span>            params.add(tableClause.getOriginalCaseValue());
<span class="nocode"><a name="4006">4006: </a></span>        }
<span class="nocode"><a name="4007">4007: </a></span>        
<span class="nocode"><a name="4008">4008: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="4009">4009: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="4010">4010: </a></span>        
<span class="nocode"><a name="4011">4011: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="4012">4012: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="4013">4013: </a></span>            params.clear();
<span class="nocode"><a name="4014">4014: </a></span>            if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4015">4015: </a></span>                params.add(tableClause.getValue());
<span class="nocode"><a name="4016">4016: </a></span>            }
<span class="nocode"><a name="4017">4017: </a></span>            
<span class="nocode"><a name="4018">4018: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="4019">4019: </a></span>            
<span class="nocode"><a name="4020">4020: </a></span>            // if nothing found, return an empty result set
<span class="nocode"><a name="4021">4021: </a></span>            if (!rs.next())
<span class="nocode"><a name="4022">4022: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4023">4023: </a></span>        }
<span class="nocode"><a name="4024">4024: </a></span>        
<span class="nocode"><a name="4025">4025: </a></span>        do {
<span class="nocode"><a name="4026">4026: </a></span>            byte[][] row = new byte[14][];
<span class="nocode"><a name="4027">4027: </a></span>            row[0] = null;
<span class="nocode"><a name="4028">4028: </a></span>            row[1] = null;
<span class="nocode"><a name="4029">4029: </a></span>            row[2] = getBytes(rs.getString(&quot;PKTABLE_NAME&quot;));
<span class="nocode"><a name="4030">4030: </a></span>            row[3] = getBytes(rs.getString(&quot;PKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4031">4031: </a></span>            row[4] = null;
<span class="nocode"><a name="4032">4032: </a></span>            row[5] = null;
<span class="nocode"><a name="4033">4033: </a></span>            row[6] = getBytes(rs.getString(&quot;FKTABLE_NAME&quot;));
<span class="nocode"><a name="4034">4034: </a></span>            row[7] = getBytes(rs.getString(&quot;FKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4035">4035: </a></span>            row[8] = xsqlvars[0].encodeShort(rs.getShort(&quot;KEY_SEQ&quot;));
<span class="nocode"><a name="4036">4036: </a></span>            String updateRule = rs.getString(&quot;UPDATE_RULE&quot;);
<span class="nocode"><a name="4037">4037: </a></span>            if (updateRule.equals(&quot;NO ACTION&quot;) || updateRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4038">4038: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4039">4039: </a></span>            else if (updateRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4040">4040: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4041">4041: </a></span>            else if (updateRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4042">4042: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4043">4043: </a></span>            else if (updateRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4044">4044: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4045">4045: </a></span>            String deleteRule = rs.getString(&quot;DELETE_RULE&quot;);
<span class="nocode"><a name="4046">4046: </a></span>            if (deleteRule.equals(&quot;NO ACTION&quot;) || deleteRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4047">4047: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4048">4048: </a></span>            else if (deleteRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4049">4049: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4050">4050: </a></span>            else if (deleteRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4051">4051: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4052">4052: </a></span>            else if (deleteRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4053">4053: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4054">4054: </a></span>            row[11] = getBytes(rs.getString(&quot;FK_NAME&quot;));
<span class="nocode"><a name="4055">4055: </a></span>            row[12] = getBytes(rs.getString(&quot;PK_NAME&quot;));
<span class="nocode"><a name="4056">4056: </a></span>            row[13] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNotDeferrable);
<span class="nocode"><a name="4057">4057: </a></span>            rows.add(row);
<span class="nocode"><a name="4058">4058: </a></span>        } while (rs.next());
<span class="nocode"><a name="4059">4059: </a></span>        
<span class="nocode"><a name="4060">4060: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4061">4061: </a></span>    }
<span class="nocode"><a name="4062">4062: </a></span>
<span class="nocode"><a name="4063">4063: </a></span>
<span class="nocode"><a name="4064">4064: </a></span>    private static final String GET_EXPORTED_KEYS_START = &quot;select&quot;
<span class="nocode"><a name="4065">4065: </a></span>    +&quot; null as PKTABLE_CAT &quot;
<span class="nocode"><a name="4066">4066: </a></span>    +&quot; ,null as PKTABLE_SCHEM &quot;
<span class="nocode"><a name="4067">4067: </a></span>    +&quot; ,PK.RDB$RELATION_NAME as PKTABLE_NAME &quot;
<span class="nocode"><a name="4068">4068: </a></span>    +&quot; ,ISP.RDB$FIELD_NAME as PKCOLUMN_NAME &quot;
<span class="nocode"><a name="4069">4069: </a></span>    +&quot; ,null as FKTABLE_CAT &quot;
<span class="nocode"><a name="4070">4070: </a></span>    +&quot; ,null as FKTABLE_SCHEM &quot;
<span class="nocode"><a name="4071">4071: </a></span>    +&quot; ,FK.RDB$RELATION_NAME as FKTABLE_NAME &quot;
<span class="nocode"><a name="4072">4072: </a></span>    +&quot; ,ISF.RDB$FIELD_NAME as FKCOLUMN_NAME &quot;
<span class="nocode"><a name="4073">4073: </a></span>    +&quot; ,CAST ((ISP.RDB$FIELD_POSITION + 1) as SMALLINT) as KEY_SEQ &quot;
<span class="nocode"><a name="4074">4074: </a></span>    +&quot; ,RC.RDB$UPDATE_RULE as UPDATE_RULE &quot;
<span class="nocode"><a name="4075">4075: </a></span>    +&quot; ,RC.RDB$DELETE_RULE as DELETE_RULE &quot;
<span class="nocode"><a name="4076">4076: </a></span>    +&quot; ,PK.RDB$CONSTRAINT_NAME as PK_NAME &quot;
<span class="nocode"><a name="4077">4077: </a></span>    +&quot; ,FK.RDB$CONSTRAINT_NAME as FK_NAME &quot;
<span class="nocode"><a name="4078">4078: </a></span>    +&quot; ,null as DEFERRABILITY &quot;
<span class="nocode"><a name="4079">4079: </a></span>    +&quot; from &quot;
<span class="nocode"><a name="4080">4080: </a></span>    +&quot; RDB$RELATION_CONSTRAINTS PK &quot;
<span class="nocode"><a name="4081">4081: </a></span>    +&quot; ,RDB$RELATION_CONSTRAINTS FK &quot;
<span class="nocode"><a name="4082">4082: </a></span>    +&quot; ,RDB$REF_CONSTRAINTS RC &quot;
<span class="nocode"><a name="4083">4083: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISP &quot;
<span class="nocode"><a name="4084">4084: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISF &quot;
<span class="nocode"><a name="4085">4085: </a></span>    +&quot; WHERE &quot;;
<span class="nocode"><a name="4086">4086: </a></span>
<span class="nocode"><a name="4087">4087: </a></span>    private static final String GET_EXPORTED_KEYS_END =
<span class="nocode"><a name="4088">4088: </a></span>    &quot; FK.RDB$CONSTRAINT_NAME = RC.RDB$CONSTRAINT_NAME &quot;
<span class="nocode"><a name="4089">4089: </a></span>    +&quot; and PK.RDB$CONSTRAINT_NAME = RC.RDB$CONST_NAME_UQ &quot;
<span class="nocode"><a name="4090">4090: </a></span>    +&quot; and ISP.RDB$INDEX_NAME = PK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="4091">4091: </a></span>    +&quot; and ISF.RDB$INDEX_NAME = FK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="4092">4092: </a></span>    +&quot; and ISP.RDB$FIELD_POSITION = ISF.RDB$FIELD_POSITION &quot;
<span class="nocode"><a name="4093">4093: </a></span>    +&quot; order by 7, 9 &quot;;
<span class="nocode"><a name="4094">4094: </a></span>
<span class="nocode"><a name="4095">4095: </a></span>    /**
<span class="nocode"><a name="4096">4096: </a></span>     * Gets a description of the foreign key columns that reference a
<span class="nocode"><a name="4097">4097: </a></span>     * table's primary key columns (the foreign keys exported by a
<span class="nocode"><a name="4098">4098: </a></span>     * table).  They are ordered by FKTABLE_CAT, FKTABLE_SCHEM,
<span class="nocode"><a name="4099">4099: </a></span>     * FKTABLE_NAME, and KEY_SEQ.
<span class="nocode"><a name="4100">4100: </a></span>     *
<span class="nocode"><a name="4101">4101: </a></span>     * &lt;P&gt;Each foreign key column description has the following columns:
<span class="nocode"><a name="4102">4102: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="4103">4103: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&gt; primary key table catalog (may be null)
<span class="nocode"><a name="4104">4104: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&gt; primary key table schema (may be null)
<span class="nocode"><a name="4105">4105: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&gt; primary key table name
<span class="nocode"><a name="4106">4106: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&gt; primary key column name
<span class="nocode"><a name="4107">4107: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&gt; foreign key table catalog (may be null)
<span class="nocode"><a name="4108">4108: </a></span>     *      being exported (may be null)
<span class="nocode"><a name="4109">4109: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&gt; foreign key table schema (may be null)
<span class="nocode"><a name="4110">4110: </a></span>     *      being exported (may be null)
<span class="nocode"><a name="4111">4111: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&gt; foreign key table name
<span class="nocode"><a name="4112">4112: </a></span>     *      being exported
<span class="nocode"><a name="4113">4113: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&gt; foreign key column name
<span class="nocode"><a name="4114">4114: </a></span>     *      being exported
<span class="nocode"><a name="4115">4115: </a></span>     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&gt; sequence number within foreign key
<span class="nocode"><a name="4116">4116: </a></span>     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="4117">4117: </a></span>     *       foreign key when primary is updated:
<span class="nocode"><a name="4118">4118: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4119">4119: </a></span>     *      &lt;LI&gt; importedNoAction - do not allow update of primary
<span class="nocode"><a name="4120">4120: </a></span>     *               key if it has been imported
<span class="nocode"><a name="4121">4121: </a></span>     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
<span class="nocode"><a name="4122">4122: </a></span>     *               with primary key update
<span class="nocode"><a name="4123">4123: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="4124">4124: </a></span>     *               its primary key has been updated
<span class="nocode"><a name="4125">4125: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
<span class="nocode"><a name="4126">4126: </a></span>     *               if its primary key has been updated
<span class="nocode"><a name="4127">4127: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="4128">4128: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="4129">4129: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4130">4130: </a></span>     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="4131">4131: </a></span>     *      the foreign key when primary is deleted.
<span class="nocode"><a name="4132">4132: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4133">4133: </a></span>     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of primary
<span class="nocode"><a name="4134">4134: </a></span>     *               key if it has been imported
<span class="nocode"><a name="4135">4135: </a></span>     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
<span class="nocode"><a name="4136">4136: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="4137">4137: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="4138">4138: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="4139">4139: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="4140">4140: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
<span class="nocode"><a name="4141">4141: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="4142">4142: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4143">4143: </a></span>     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&gt; foreign key name (may be null)
<span class="nocode"><a name="4144">4144: </a></span>     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&gt; primary key name (may be null)
<span class="nocode"><a name="4145">4145: </a></span>     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&gt; can the evaluation of foreign key
<span class="nocode"><a name="4146">4146: </a></span>     *      constraints be deferred until commit
<span class="nocode"><a name="4147">4147: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4148">4148: </a></span>     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
<span class="nocode"><a name="4149">4149: </a></span>     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
<span class="nocode"><a name="4150">4150: </a></span>     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
<span class="nocode"><a name="4151">4151: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4152">4152: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="4153">4153: </a></span>     *
<span class="nocode"><a name="4154">4154: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="4155">4155: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="4156">4156: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those
<span class="nocode"><a name="4157">4157: </a></span>     * without a schema
<span class="nocode"><a name="4158">4158: </a></span>     * @param table a table name
<span class="nocode"><a name="4159">4159: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a foreign key column description
<span class="nocode"><a name="4160">4160: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="4161">4161: </a></span>     * @see #getImportedKeys
<span class="nocode"><a name="4162">4162: </a></span>     */
<span class="nocode"><a name="4163">4163: </a></span>    public ResultSet getExportedKeys(String catalog, String schema,
<span class="nocode"><a name="4164">4164: </a></span>                String table) throws SQLException {
<span class="nocode"><a name="4165">4165: </a></span>        checkCatalogAndSchema(catalog, schema);
<span class="nocode"><a name="4166">4166: </a></span>
<span class="nocode"><a name="4167">4167: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[14];
<span class="nocode"><a name="4168">4168: </a></span>
<span class="nocode"><a name="4169">4169: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="4170">4170: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4171">4171: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="4172">4172: </a></span>        xsqlvars[0].sqlname = &quot;PKTABLE_CAT&quot;;
<span class="nocode"><a name="4173">4173: </a></span>        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4174">4174: </a></span>
<span class="nocode"><a name="4175">4175: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="4176">4176: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4177">4177: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="4178">4178: </a></span>        xsqlvars[1].sqlname = &quot;PKTABLE_SCHEM&quot;;
<span class="nocode"><a name="4179">4179: </a></span>        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4180">4180: </a></span>
<span class="nocode"><a name="4181">4181: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="4182">4182: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4183">4183: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="4184">4184: </a></span>        xsqlvars[2].sqlname = &quot;PKTABLE_NAME&quot;;
<span class="nocode"><a name="4185">4185: </a></span>        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4186">4186: </a></span>
<span class="nocode"><a name="4187">4187: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="4188">4188: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4189">4189: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="4190">4190: </a></span>        xsqlvars[3].sqlname = &quot;PKCOLUMN_NAME&quot;;
<span class="nocode"><a name="4191">4191: </a></span>        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4192">4192: </a></span>
<span class="nocode"><a name="4193">4193: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="4194">4194: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4195">4195: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="4196">4196: </a></span>        xsqlvars[4].sqlname = &quot;FKTABLE_CAT&quot;;
<span class="nocode"><a name="4197">4197: </a></span>        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4198">4198: </a></span>
<span class="nocode"><a name="4199">4199: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="4200">4200: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4201">4201: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="4202">4202: </a></span>        xsqlvars[5].sqlname = &quot;FKTABLE_SCHEM&quot;;
<span class="nocode"><a name="4203">4203: </a></span>        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4204">4204: </a></span>
<span class="nocode"><a name="4205">4205: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="4206">4206: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4207">4207: </a></span>        xsqlvars[6].sqllen = 31;
<span class="nocode"><a name="4208">4208: </a></span>        xsqlvars[6].sqlname = &quot;FKTABLE_NAME&quot;;
<span class="nocode"><a name="4209">4209: </a></span>        xsqlvars[6].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4210">4210: </a></span>
<span class="nocode"><a name="4211">4211: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="4212">4212: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4213">4213: </a></span>        xsqlvars[7].sqllen = 31;
<span class="nocode"><a name="4214">4214: </a></span>        xsqlvars[7].sqlname = &quot;FKCOLUMN_NAME&quot;;
<span class="nocode"><a name="4215">4215: </a></span>        xsqlvars[7].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4216">4216: </a></span>
<span class="nocode"><a name="4217">4217: </a></span>        xsqlvars[8] = new XSQLVAR();
<span class="nocode"><a name="4218">4218: </a></span>        xsqlvars[8].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="4219">4219: </a></span>        xsqlvars[8].sqlname = &quot;KEY_SEQ&quot;;
<span class="nocode"><a name="4220">4220: </a></span>        xsqlvars[8].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4221">4221: </a></span>
<span class="nocode"><a name="4222">4222: </a></span>        xsqlvars[9] = new XSQLVAR();
<span class="nocode"><a name="4223">4223: </a></span>        xsqlvars[9].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="4224">4224: </a></span>        xsqlvars[9].sqlname = &quot;UPDATE_RULE&quot;;
<span class="nocode"><a name="4225">4225: </a></span>        xsqlvars[9].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4226">4226: </a></span>
<span class="nocode"><a name="4227">4227: </a></span>        xsqlvars[10] = new XSQLVAR();
<span class="nocode"><a name="4228">4228: </a></span>        xsqlvars[10].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="4229">4229: </a></span>        xsqlvars[10].sqlname = &quot;DELETE_RULE&quot;;
<span class="nocode"><a name="4230">4230: </a></span>        xsqlvars[10].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4231">4231: </a></span>
<span class="nocode"><a name="4232">4232: </a></span>        xsqlvars[11] = new XSQLVAR();
<span class="nocode"><a name="4233">4233: </a></span>        xsqlvars[11].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4234">4234: </a></span>        xsqlvars[11].sqllen = 31;
<span class="nocode"><a name="4235">4235: </a></span>        xsqlvars[11].sqlname = &quot;FK_NAME&quot;;
<span class="nocode"><a name="4236">4236: </a></span>        xsqlvars[11].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4237">4237: </a></span>
<span class="nocode"><a name="4238">4238: </a></span>        xsqlvars[12] = new XSQLVAR();
<span class="nocode"><a name="4239">4239: </a></span>        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4240">4240: </a></span>        xsqlvars[12].sqllen = 31;
<span class="nocode"><a name="4241">4241: </a></span>        xsqlvars[12].sqlname = &quot;PK_NAME&quot;;
<span class="nocode"><a name="4242">4242: </a></span>        xsqlvars[12].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4243">4243: </a></span>
<span class="nocode"><a name="4244">4244: </a></span>        xsqlvars[13] = new XSQLVAR();
<span class="nocode"><a name="4245">4245: </a></span>        xsqlvars[13].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="4246">4246: </a></span>        xsqlvars[13].sqlname = &quot;DEFERRABILITY&quot;;
<span class="nocode"><a name="4247">4247: </a></span>        xsqlvars[13].relname = &quot;COLUMNINFO&quot;;
<span class="nocode"><a name="4248">4248: </a></span>
<span class="nocode"><a name="4249">4249: </a></span>        Clause tableClause = new Clause(&quot;PK.RDB$RELATION_NAME&quot;, table);
<span class="nocode"><a name="4250">4250: </a></span>
<span class="nocode"><a name="4251">4251: </a></span>        String sql = GET_EXPORTED_KEYS_START;
<span class="nocode"><a name="4252">4252: </a></span>        sql += tableClause.getCondition();
<span class="nocode"><a name="4253">4253: </a></span>        sql += GET_EXPORTED_KEYS_END;
<span class="nocode"><a name="4254">4254: </a></span>        
<span class="nocode"><a name="4255">4255: </a></span>        // check the original case identifiers first
<span class="nocode"><a name="4256">4256: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="4257">4257: </a></span>        if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4258">4258: </a></span>            params.add(tableClause.getOriginalCaseValue());
<span class="nocode"><a name="4259">4259: </a></span>        }
<span class="nocode"><a name="4260">4260: </a></span>
<span class="nocode"><a name="4261">4261: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="4262">4262: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="4263">4263: </a></span>        
<span class="nocode"><a name="4264">4264: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="4265">4265: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="4266">4266: </a></span>            params.clear();
<span class="nocode"><a name="4267">4267: </a></span>            if (!tableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4268">4268: </a></span>                params.add(tableClause.getValue());
<span class="nocode"><a name="4269">4269: </a></span>            }
<span class="nocode"><a name="4270">4270: </a></span>            
<span class="nocode"><a name="4271">4271: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="4272">4272: </a></span>            
<span class="nocode"><a name="4273">4273: </a></span>            // if nothing found, return an empty result set
<span class="nocode"><a name="4274">4274: </a></span>            if (!rs.next())
<span class="nocode"><a name="4275">4275: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4276">4276: </a></span>        }
<span class="nocode"><a name="4277">4277: </a></span>
<span class="nocode"><a name="4278">4278: </a></span>        do {
<span class="nocode"><a name="4279">4279: </a></span>            byte[][] row = new byte[14][];
<span class="nocode"><a name="4280">4280: </a></span>            row[0] = null;
<span class="nocode"><a name="4281">4281: </a></span>            row[1] = null;
<span class="nocode"><a name="4282">4282: </a></span>            row[2] = getBytes(rs.getString(&quot;PKTABLE_NAME&quot;));
<span class="nocode"><a name="4283">4283: </a></span>            row[3] = getBytes(rs.getString(&quot;PKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4284">4284: </a></span>            row[4] = null;
<span class="nocode"><a name="4285">4285: </a></span>            row[5] = null;
<span class="nocode"><a name="4286">4286: </a></span>            row[6] = getBytes(rs.getString(&quot;FKTABLE_NAME&quot;));
<span class="nocode"><a name="4287">4287: </a></span>            row[7] = getBytes(rs.getString(&quot;FKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4288">4288: </a></span>            row[8] = xsqlvars[0].encodeShort(rs.getShort(&quot;KEY_SEQ&quot;));
<span class="nocode"><a name="4289">4289: </a></span>            String updateRule = rs.getString(&quot;UPDATE_RULE&quot;);
<span class="nocode"><a name="4290">4290: </a></span>            if (updateRule.equals(&quot;NO ACTION&quot;) || updateRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4291">4291: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4292">4292: </a></span>            else if (updateRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4293">4293: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4294">4294: </a></span>            else if (updateRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4295">4295: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4296">4296: </a></span>            else if (updateRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4297">4297: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4298">4298: </a></span>            String deleteRule = rs.getString(&quot;DELETE_RULE&quot;);
<span class="nocode"><a name="4299">4299: </a></span>            if (deleteRule.equals(&quot;NO ACTION&quot;) || deleteRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4300">4300: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4301">4301: </a></span>            else if (deleteRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4302">4302: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4303">4303: </a></span>            else if (deleteRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4304">4304: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4305">4305: </a></span>            else if (deleteRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4306">4306: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4307">4307: </a></span>
<span class="nocode"><a name="4308">4308: </a></span>            row[11] = getBytes(rs.getString(&quot;FK_NAME&quot;));
<span class="nocode"><a name="4309">4309: </a></span>            row[12] = getBytes(rs.getString(&quot;PK_NAME&quot;));
<span class="nocode"><a name="4310">4310: </a></span>            row[13] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNotDeferrable);
<span class="nocode"><a name="4311">4311: </a></span>
<span class="nocode"><a name="4312">4312: </a></span>            rows.add(row);
<span class="nocode"><a name="4313">4313: </a></span>        } while(rs.next());
<span class="nocode"><a name="4314">4314: </a></span>        
<span class="nocode"><a name="4315">4315: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4316">4316: </a></span>    }
<span class="nocode"><a name="4317">4317: </a></span>
<span class="nocode"><a name="4318">4318: </a></span>
<span class="nocode"><a name="4319">4319: </a></span>
<span class="nocode"><a name="4320">4320: </a></span>    private static final String GET_CROSS_KEYS_START = &quot;select&quot;
<span class="nocode"><a name="4321">4321: </a></span>    +&quot; null as PKTABLE_CAT &quot;
<span class="nocode"><a name="4322">4322: </a></span>    +&quot; ,null as PKTABLE_SCHEM &quot;
<span class="nocode"><a name="4323">4323: </a></span>    +&quot; ,PK.RDB$RELATION_NAME as PKTABLE_NAME &quot;
<span class="nocode"><a name="4324">4324: </a></span>    +&quot; ,ISP.RDB$FIELD_NAME as PKCOLUMN_NAME &quot;
<span class="nocode"><a name="4325">4325: </a></span>    +&quot; ,null as FKTABLE_CAT &quot;
<span class="nocode"><a name="4326">4326: </a></span>    +&quot; ,null as FKTABLE_SCHEM &quot;
<span class="nocode"><a name="4327">4327: </a></span>    +&quot; ,FK.RDB$RELATION_NAME as FKTABLE_NAME &quot;
<span class="nocode"><a name="4328">4328: </a></span>    +&quot; ,ISF.RDB$FIELD_NAME as FKCOLUMN_NAME &quot;
<span class="nocode"><a name="4329">4329: </a></span>    +&quot; ,CAST ((ISP.RDB$FIELD_POSITION + 1) as SMALLINT) as KEY_SEQ &quot;
<span class="nocode"><a name="4330">4330: </a></span>    +&quot; ,RC.RDB$UPDATE_RULE as UPDATE_RULE &quot;
<span class="nocode"><a name="4331">4331: </a></span>    +&quot; ,RC.RDB$DELETE_RULE as DELETE_RULE &quot;
<span class="nocode"><a name="4332">4332: </a></span>    +&quot; ,PK.RDB$CONSTRAINT_NAME as PK_NAME &quot;
<span class="nocode"><a name="4333">4333: </a></span>    +&quot; ,FK.RDB$CONSTRAINT_NAME as FK_NAME &quot;
<span class="nocode"><a name="4334">4334: </a></span>    +&quot; ,null as DEFERRABILITY &quot;
<span class="nocode"><a name="4335">4335: </a></span>    +&quot; from &quot;
<span class="nocode"><a name="4336">4336: </a></span>    +&quot; RDB$RELATION_CONSTRAINTS PK &quot;
<span class="nocode"><a name="4337">4337: </a></span>    +&quot; ,RDB$RELATION_CONSTRAINTS FK &quot;
<span class="nocode"><a name="4338">4338: </a></span>    +&quot; ,RDB$REF_CONSTRAINTS RC &quot;
<span class="nocode"><a name="4339">4339: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISP &quot;
<span class="nocode"><a name="4340">4340: </a></span>    +&quot; ,RDB$INDEX_SEGMENTS ISF &quot;
<span class="nocode"><a name="4341">4341: </a></span>    +&quot; WHERE &quot;;
<span class="nocode"><a name="4342">4342: </a></span>
<span class="nocode"><a name="4343">4343: </a></span>    private static final String GET_CROSS_KEYS_END =
<span class="nocode"><a name="4344">4344: </a></span>    &quot; FK.RDB$CONSTRAINT_NAME = RC.RDB$CONSTRAINT_NAME &quot;
<span class="nocode"><a name="4345">4345: </a></span>    +&quot; and PK.RDB$CONSTRAINT_NAME = RC.RDB$CONST_NAME_UQ &quot;
<span class="nocode"><a name="4346">4346: </a></span>    +&quot; and ISP.RDB$INDEX_NAME = PK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="4347">4347: </a></span>    +&quot; and ISF.RDB$INDEX_NAME = FK.RDB$INDEX_NAME &quot;
<span class="nocode"><a name="4348">4348: </a></span>    +&quot; and ISP.RDB$FIELD_POSITION = ISF.RDB$FIELD_POSITION &quot;
<span class="nocode"><a name="4349">4349: </a></span>    +&quot; order by 7, 9 &quot;;
<span class="nocode"><a name="4350">4350: </a></span>
<span class="nocode"><a name="4351">4351: </a></span>    /**
<span class="nocode"><a name="4352">4352: </a></span>     * Gets a description of the foreign key columns in the foreign key
<span class="nocode"><a name="4353">4353: </a></span>     * table that reference the primary key columns of the primary key
<span class="nocode"><a name="4354">4354: </a></span>     * table (describe how one table imports another's key). This
<span class="nocode"><a name="4355">4355: </a></span>     * should normally return a single foreign key/primary key pair
<span class="nocode"><a name="4356">4356: </a></span>     * (most tables only import a foreign key from a table once.)  They
<span class="nocode"><a name="4357">4357: </a></span>     * are ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and
<span class="nocode"><a name="4358">4358: </a></span>     * KEY_SEQ.
<span class="nocode"><a name="4359">4359: </a></span>     *
<span class="nocode"><a name="4360">4360: </a></span>     * &lt;P&gt;Each foreign key column description has the following columns:
<span class="nocode"><a name="4361">4361: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="4362">4362: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_CAT&lt;/B&gt; String =&gt; primary key table catalog (may be null)
<span class="nocode"><a name="4363">4363: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_SCHEM&lt;/B&gt; String =&gt; primary key table schema (may be null)
<span class="nocode"><a name="4364">4364: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKTABLE_NAME&lt;/B&gt; String =&gt; primary key table name
<span class="nocode"><a name="4365">4365: </a></span>     *  &lt;LI&gt;&lt;B&gt;PKCOLUMN_NAME&lt;/B&gt; String =&gt; primary key column name
<span class="nocode"><a name="4366">4366: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_CAT&lt;/B&gt; String =&gt; foreign key table catalog (may be null)
<span class="nocode"><a name="4367">4367: </a></span>     *      being exported (may be null)
<span class="nocode"><a name="4368">4368: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_SCHEM&lt;/B&gt; String =&gt; foreign key table schema (may be null)
<span class="nocode"><a name="4369">4369: </a></span>     *      being exported (may be null)
<span class="nocode"><a name="4370">4370: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKTABLE_NAME&lt;/B&gt; String =&gt; foreign key table name
<span class="nocode"><a name="4371">4371: </a></span>     *      being exported
<span class="nocode"><a name="4372">4372: </a></span>     *  &lt;LI&gt;&lt;B&gt;FKCOLUMN_NAME&lt;/B&gt; String =&gt; foreign key column name
<span class="nocode"><a name="4373">4373: </a></span>     *      being exported
<span class="nocode"><a name="4374">4374: </a></span>     *  &lt;LI&gt;&lt;B&gt;KEY_SEQ&lt;/B&gt; short =&gt; sequence number within foreign key
<span class="nocode"><a name="4375">4375: </a></span>     *  &lt;LI&gt;&lt;B&gt;UPDATE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="4376">4376: </a></span>     *       foreign key when primary is updated:
<span class="nocode"><a name="4377">4377: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4378">4378: </a></span>     *      &lt;LI&gt; importedNoAction - do not allow update of primary
<span class="nocode"><a name="4379">4379: </a></span>     *               key if it has been imported
<span class="nocode"><a name="4380">4380: </a></span>     *      &lt;LI&gt; importedKeyCascade - change imported key to agree
<span class="nocode"><a name="4381">4381: </a></span>     *               with primary key update
<span class="nocode"><a name="4382">4382: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="4383">4383: </a></span>     *               its primary key has been updated
<span class="nocode"><a name="4384">4384: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default values
<span class="nocode"><a name="4385">4385: </a></span>     *               if its primary key has been updated
<span class="nocode"><a name="4386">4386: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="4387">4387: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="4388">4388: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4389">4389: </a></span>     *  &lt;LI&gt;&lt;B&gt;DELETE_RULE&lt;/B&gt; short =&gt; What happens to
<span class="nocode"><a name="4390">4390: </a></span>     *      the foreign key when primary is deleted.
<span class="nocode"><a name="4391">4391: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4392">4392: </a></span>     *      &lt;LI&gt; importedKeyNoAction - do not allow delete of primary
<span class="nocode"><a name="4393">4393: </a></span>     *               key if it has been imported
<span class="nocode"><a name="4394">4394: </a></span>     *      &lt;LI&gt; importedKeyCascade - delete rows that import a deleted key
<span class="nocode"><a name="4395">4395: </a></span>     *      &lt;LI&gt; importedKeySetNull - change imported key to NULL if
<span class="nocode"><a name="4396">4396: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="4397">4397: </a></span>     *      &lt;LI&gt; importedKeyRestrict - same as importedKeyNoAction
<span class="nocode"><a name="4398">4398: </a></span>     *                                 (for ODBC 2.x compatibility)
<span class="nocode"><a name="4399">4399: </a></span>     *      &lt;LI&gt; importedKeySetDefault - change imported key to default if
<span class="nocode"><a name="4400">4400: </a></span>     *               its primary key has been deleted
<span class="nocode"><a name="4401">4401: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4402">4402: </a></span>     *  &lt;LI&gt;&lt;B&gt;FK_NAME&lt;/B&gt; String =&gt; foreign key name (may be null)
<span class="nocode"><a name="4403">4403: </a></span>     *  &lt;LI&gt;&lt;B&gt;PK_NAME&lt;/B&gt; String =&gt; primary key name (may be null)
<span class="nocode"><a name="4404">4404: </a></span>     *  &lt;LI&gt;&lt;B&gt;DEFERRABILITY&lt;/B&gt; short =&gt; can the evaluation of foreign key
<span class="nocode"><a name="4405">4405: </a></span>     *      constraints be deferred until commit
<span class="nocode"><a name="4406">4406: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4407">4407: </a></span>     *      &lt;LI&gt; importedKeyInitiallyDeferred - see SQL92 for definition
<span class="nocode"><a name="4408">4408: </a></span>     *      &lt;LI&gt; importedKeyInitiallyImmediate - see SQL92 for definition
<span class="nocode"><a name="4409">4409: </a></span>     *      &lt;LI&gt; importedKeyNotDeferrable - see SQL92 for definition
<span class="nocode"><a name="4410">4410: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4411">4411: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="4412">4412: </a></span>     *
<span class="nocode"><a name="4413">4413: </a></span>     * @param primaryCatalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="4414">4414: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="4415">4415: </a></span>     * @param primarySchema a schema name; &quot;&quot; retrieves those
<span class="nocode"><a name="4416">4416: </a></span>     * without a schema
<span class="nocode"><a name="4417">4417: </a></span>     * @param primaryTable the table name that exports the key
<span class="nocode"><a name="4418">4418: </a></span>     * @param foreignCatalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="4419">4419: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="4420">4420: </a></span>     * @param foreignSchema a schema name; &quot;&quot; retrieves those
<span class="nocode"><a name="4421">4421: </a></span>     * without a schema
<span class="nocode"><a name="4422">4422: </a></span>     * @param foreignTable the table name that imports the key
<span class="nocode"><a name="4423">4423: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a foreign key column description
<span class="nocode"><a name="4424">4424: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="4425">4425: </a></span>     * @see #getImportedKeys
<span class="nocode"><a name="4426">4426: </a></span>     */
<span class="nocode"><a name="4427">4427: </a></span>    public ResultSet getCrossReference(
<span class="nocode"><a name="4428">4428: </a></span>        String primaryCatalog, String primarySchema, String primaryTable,
<span class="nocode"><a name="4429">4429: </a></span>        String foreignCatalog, String foreignSchema, String foreignTable
<span class="nocode"><a name="4430">4430: </a></span>        ) throws SQLException {
<span class="nocode"><a name="4431">4431: </a></span><span style="background-color: #ffffcc">        checkCatalogAndSchema(primaryCatalog, primarySchema);</span>
<span class="nocode"><a name="4432">4432: </a></span><span style="background-color: #ffffcc">        checkCatalogAndSchema(foreignCatalog, foreignSchema);</span>
<span class="nocode"><a name="4433">4433: </a></span>
<span class="nocode"><a name="4434">4434: </a></span><span style="background-color: #ffffcc">        XSQLVAR[] xsqlvars = new XSQLVAR[14];</span>
<span class="nocode"><a name="4435">4435: </a></span>
<span class="nocode"><a name="4436">4436: </a></span><span style="background-color: #ffffcc">        xsqlvars[0] = new XSQLVAR();</span>
<span class="nocode"><a name="4437">4437: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4438">4438: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqllen = 31;</span>
<span class="nocode"><a name="4439">4439: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqlname = &quot;PKTABLE_CAT&quot;;</span>
<span class="nocode"><a name="4440">4440: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4441">4441: </a></span>
<span class="nocode"><a name="4442">4442: </a></span><span style="background-color: #ffffcc">        xsqlvars[1] = new XSQLVAR();</span>
<span class="nocode"><a name="4443">4443: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4444">4444: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqllen = 31;</span>
<span class="nocode"><a name="4445">4445: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqlname = &quot;PKTABLE_SCHEM&quot;;</span>
<span class="nocode"><a name="4446">4446: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4447">4447: </a></span>
<span class="nocode"><a name="4448">4448: </a></span><span style="background-color: #ffffcc">        xsqlvars[2] = new XSQLVAR();</span>
<span class="nocode"><a name="4449">4449: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4450">4450: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqllen = 31;</span>
<span class="nocode"><a name="4451">4451: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqlname = &quot;PKTABLE_NAME&quot;;</span>
<span class="nocode"><a name="4452">4452: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4453">4453: </a></span>
<span class="nocode"><a name="4454">4454: </a></span><span style="background-color: #ffffcc">        xsqlvars[3] = new XSQLVAR();</span>
<span class="nocode"><a name="4455">4455: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4456">4456: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqllen = 31;</span>
<span class="nocode"><a name="4457">4457: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqlname = &quot;PKCOLUMN_NAME&quot;;</span>
<span class="nocode"><a name="4458">4458: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4459">4459: </a></span>
<span class="nocode"><a name="4460">4460: </a></span><span style="background-color: #ffffcc">        xsqlvars[4] = new XSQLVAR();</span>
<span class="nocode"><a name="4461">4461: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4462">4462: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqllen = 31;</span>
<span class="nocode"><a name="4463">4463: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqlname = &quot;FKTABLE_CAT&quot;;</span>
<span class="nocode"><a name="4464">4464: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4465">4465: </a></span>
<span class="nocode"><a name="4466">4466: </a></span><span style="background-color: #ffffcc">        xsqlvars[5] = new XSQLVAR();</span>
<span class="nocode"><a name="4467">4467: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4468">4468: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqllen = 31;</span>
<span class="nocode"><a name="4469">4469: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqlname = &quot;FKTABLE_SCHEM&quot;;</span>
<span class="nocode"><a name="4470">4470: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4471">4471: </a></span>
<span class="nocode"><a name="4472">4472: </a></span><span style="background-color: #ffffcc">        xsqlvars[6] = new XSQLVAR();</span>
<span class="nocode"><a name="4473">4473: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4474">4474: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqllen = 31;</span>
<span class="nocode"><a name="4475">4475: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqlname = &quot;FKTABLE_NAME&quot;;</span>
<span class="nocode"><a name="4476">4476: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4477">4477: </a></span>
<span class="nocode"><a name="4478">4478: </a></span><span style="background-color: #ffffcc">        xsqlvars[7] = new XSQLVAR();</span>
<span class="nocode"><a name="4479">4479: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4480">4480: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqllen = 31;</span>
<span class="nocode"><a name="4481">4481: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqlname = &quot;FKCOLUMN_NAME&quot;;</span>
<span class="nocode"><a name="4482">4482: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4483">4483: </a></span>
<span class="nocode"><a name="4484">4484: </a></span><span style="background-color: #ffffcc">        xsqlvars[8] = new XSQLVAR();</span>
<span class="nocode"><a name="4485">4485: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4486">4486: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqlname = &quot;KEY_SEQ&quot;;</span>
<span class="nocode"><a name="4487">4487: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4488">4488: </a></span>
<span class="nocode"><a name="4489">4489: </a></span><span style="background-color: #ffffcc">        xsqlvars[9] = new XSQLVAR();</span>
<span class="nocode"><a name="4490">4490: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4491">4491: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqlname = &quot;UPDATE_RULE&quot;;</span>
<span class="nocode"><a name="4492">4492: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4493">4493: </a></span>
<span class="nocode"><a name="4494">4494: </a></span><span style="background-color: #ffffcc">        xsqlvars[10] = new XSQLVAR();</span>
<span class="nocode"><a name="4495">4495: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4496">4496: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqlname = &quot;DELETE_RULE&quot;;</span>
<span class="nocode"><a name="4497">4497: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4498">4498: </a></span>
<span class="nocode"><a name="4499">4499: </a></span><span style="background-color: #ffffcc">        xsqlvars[11] = new XSQLVAR();</span>
<span class="nocode"><a name="4500">4500: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4501">4501: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqllen = 31;</span>
<span class="nocode"><a name="4502">4502: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqlname = &quot;FK_NAME&quot;;</span>
<span class="nocode"><a name="4503">4503: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4504">4504: </a></span>
<span class="nocode"><a name="4505">4505: </a></span><span style="background-color: #ffffcc">        xsqlvars[12] = new XSQLVAR();</span>
<span class="nocode"><a name="4506">4506: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4507">4507: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqllen = 31;</span>
<span class="nocode"><a name="4508">4508: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqlname = &quot;PK_NAME&quot;;</span>
<span class="nocode"><a name="4509">4509: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4510">4510: </a></span>
<span class="nocode"><a name="4511">4511: </a></span><span style="background-color: #ffffcc">        xsqlvars[13] = new XSQLVAR();</span>
<span class="nocode"><a name="4512">4512: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4513">4513: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqlname = &quot;DEFERRABILITY&quot;;</span>
<span class="nocode"><a name="4514">4514: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].relname = &quot;COLUMNINFO&quot;;</span>
<span class="nocode"><a name="4515">4515: </a></span>
<span class="nocode"><a name="4516">4516: </a></span><span style="background-color: #ffffcc">        Clause primaryTableClause = new Clause(&quot;PK.RDB$RELATION_NAME&quot;, primaryTable);</span>
<span class="nocode"><a name="4517">4517: </a></span><span style="background-color: #ffffcc">        Clause foreignTableClause = new Clause(&quot;FK.RDB$RELATION_NAME&quot;, foreignTable);</span>
<span class="nocode"><a name="4518">4518: </a></span>        
<span class="nocode"><a name="4519">4519: </a></span><span style="background-color: #ffffcc">        String sql = GET_CROSS_KEYS_START;</span>
<span class="nocode"><a name="4520">4520: </a></span><span style="background-color: #ffffcc">        sql += primaryTableClause.getCondition();</span>
<span class="nocode"><a name="4521">4521: </a></span><span style="background-color: #ffffcc">        sql += foreignTableClause.getCondition();</span>
<span class="nocode"><a name="4522">4522: </a></span><span style="background-color: #ffffcc">        sql += GET_CROSS_KEYS_END;</span>
<span class="nocode"><a name="4523">4523: </a></span>        
<span class="nocode"><a name="4524">4524: </a></span><span style="background-color: #ffffcc">        List&lt;String&gt; params = new ArrayList&lt;String&gt;();</span>
<span class="nocode"><a name="4525">4525: </a></span>        
<span class="nocode"><a name="4526">4526: </a></span>        // check the original case first
<span class="nocode"><a name="4527">4527: </a></span><span style="background-color: #ffffcc">        if (!primaryTableClause.getCondition().equals(&quot;&quot;)) {</span>
<span class="nocode"><a name="4528">4528: </a></span><span style="background-color: #ffffcc">            params.add(primaryTableClause.getOriginalCaseValue());</span>
<span class="nocode"><a name="4529">4529: </a></span>        }
<span class="nocode"><a name="4530">4530: </a></span><span style="background-color: #ffffcc">        if (!foreignTableClause.getCondition().equals(&quot;&quot;)) {</span>
<span class="nocode"><a name="4531">4531: </a></span><span style="background-color: #ffffcc">            params.add(foreignTableClause.getOriginalCaseValue());</span>
<span class="nocode"><a name="4532">4532: </a></span>        }
<span class="nocode"><a name="4533">4533: </a></span>
<span class="nocode"><a name="4534">4534: </a></span><span style="background-color: #ffffcc">        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();</span>
<span class="nocode"><a name="4535">4535: </a></span><span style="background-color: #ffffcc">        ResultSet rs = doQuery(sql, params);</span>
<span class="nocode"><a name="4536">4536: </a></span>
<span class="nocode"><a name="4537">4537: </a></span>        // if nothing found, check the uppercased identifiers
<span class="nocode"><a name="4538">4538: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="4539">4539: </a></span>            params.clear();
<span class="nocode"><a name="4540">4540: </a></span>            if (!primaryTableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4541">4541: </a></span>                params.add(primaryTableClause.getValue());
<span class="nocode"><a name="4542">4542: </a></span>            }
<span class="nocode"><a name="4543">4543: </a></span>            if (!foreignTableClause.getCondition().equals(&quot;&quot;)) {
<span class="nocode"><a name="4544">4544: </a></span>                params.add(foreignTableClause.getValue());
<span class="nocode"><a name="4545">4545: </a></span>            }
<span class="nocode"><a name="4546">4546: </a></span>
<span class="nocode"><a name="4547">4547: </a></span>            rs = doQuery(sql, params);
<span class="nocode"><a name="4548">4548: </a></span>            
<span class="nocode"><a name="4549">4549: </a></span>            // return empty result set if nothing found
<span class="nocode"><a name="4550">4550: </a></span>            if (!rs.next())
<span class="nocode"><a name="4551">4551: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4552">4552: </a></span>        }
<span class="nocode"><a name="4553">4553: </a></span>        
<span class="nocode"><a name="4554">4554: </a></span>        do {
<span class="nocode"><a name="4555">4555: </a></span>            byte[][] row = new byte[14][];
<span class="nocode"><a name="4556">4556: </a></span>            row[0] = null;
<span class="nocode"><a name="4557">4557: </a></span>            row[1] = null;
<span class="nocode"><a name="4558">4558: </a></span>            row[2] = getBytes(rs.getString(&quot;PKTABLE_NAME&quot;));
<span class="nocode"><a name="4559">4559: </a></span>            row[3] = getBytes(rs.getString(&quot;PKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4560">4560: </a></span>            row[4] = null;
<span class="nocode"><a name="4561">4561: </a></span>            row[5] = null;
<span class="nocode"><a name="4562">4562: </a></span>            row[6] = getBytes(rs.getString(&quot;FKTABLE_NAME&quot;));
<span class="nocode"><a name="4563">4563: </a></span>            row[7] = getBytes(rs.getString(&quot;FKCOLUMN_NAME&quot;));
<span class="nocode"><a name="4564">4564: </a></span>            row[8] = xsqlvars[0].encodeShort(rs.getShort(&quot;KEY_SEQ&quot;));
<span class="nocode"><a name="4565">4565: </a></span>            String updateRule = rs.getString(&quot;UPDATE_RULE&quot;);
<span class="nocode"><a name="4566">4566: </a></span>            if (updateRule.equals(&quot;NO ACTION&quot;) || updateRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4567">4567: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4568">4568: </a></span>            else if (updateRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4569">4569: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4570">4570: </a></span>            else if (updateRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4571">4571: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4572">4572: </a></span>            else if (updateRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4573">4573: </a></span>                row[9] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4574">4574: </a></span>            String deleteRule = rs.getString(&quot;DELETE_RULE&quot;);
<span class="nocode"><a name="4575">4575: </a></span>            if (deleteRule.equals(&quot;NO ACTION&quot;) || deleteRule.equals(&quot;RESTRICT&quot;))
<span class="nocode"><a name="4576">4576: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNoAction);
<span class="nocode"><a name="4577">4577: </a></span>            else if (deleteRule.equals(&quot;CASCADE&quot;))
<span class="nocode"><a name="4578">4578: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyCascade);
<span class="nocode"><a name="4579">4579: </a></span>            else if (deleteRule.equals(&quot;SET NULL&quot;))
<span class="nocode"><a name="4580">4580: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetNull);
<span class="nocode"><a name="4581">4581: </a></span>            else if (deleteRule.equals(&quot;SET DEFAULT&quot;))
<span class="nocode"><a name="4582">4582: </a></span>                row[10] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeySetDefault);
<span class="nocode"><a name="4583">4583: </a></span>            row[11] = getBytes(rs.getString(&quot;FK_NAME&quot;));
<span class="nocode"><a name="4584">4584: </a></span>            row[12] = getBytes(rs.getString(&quot;PK_NAME&quot;));
<span class="nocode"><a name="4585">4585: </a></span>            row[13] = xsqlvars[0].encodeShort((short) DatabaseMetaData.importedKeyNotDeferrable);
<span class="nocode"><a name="4586">4586: </a></span>
<span class="nocode"><a name="4587">4587: </a></span>            rows.add(row);
<span class="nocode"><a name="4588">4588: </a></span>        } while(rs.next());
<span class="nocode"><a name="4589">4589: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="4590">4590: </a></span>    }
<span class="nocode"><a name="4591">4591: </a></span>
<span class="nocode"><a name="4592">4592: </a></span>
<span class="nocode"><a name="4593">4593: </a></span>    /**
<span class="nocode"><a name="4594">4594: </a></span>     * Simple convertor function to convert integer values to Short objects.
<span class="nocode"><a name="4595">4595: </a></span>     * Used in {@link #getTypeInfo()} for values of {@link java.sql.Types} class.
<span class="nocode"><a name="4596">4596: </a></span>     *
<span class="nocode"><a name="4597">4597: </a></span>     * @param value integer value to convert
<span class="nocode"><a name="4598">4598: </a></span>     * @return instance of java.lang.Short representing the value
<span class="nocode"><a name="4599">4599: </a></span>     */
<span class="nocode"><a name="4600">4600: </a></span>    private byte[] createShort(int value) throws SQLException {
<span class="nocode"><a name="4601">4601: </a></span><span style="background-color: #ffffcc">        if (value &gt; Short.MAX_VALUE)</span>
<span class="nocode"><a name="4602">4602: </a></span>            throw new FBSQLException(&quot;Cannot convert integer to short.&quot;,
<span class="nocode"><a name="4603">4603: </a></span>                    FBSQLException.SQL_STATE_INVALID_ARG_VALUE);
<span class="nocode"><a name="4604">4604: </a></span>        
<span class="nocode"><a name="4605">4605: </a></span><span style="background-color: #ffffcc">        return new XSQLVAR().encodeShort((short)value);</span>
<span class="nocode"><a name="4606">4606: </a></span>    }
<span class="nocode"><a name="4607">4607: </a></span>
<span class="nocode"><a name="4608">4608: </a></span>    /**
<span class="nocode"><a name="4609">4609: </a></span>     * Gets a description of all the standard SQL types supported by
<span class="nocode"><a name="4610">4610: </a></span>     * this database. They are ordered by DATA_TYPE and then by how
<span class="nocode"><a name="4611">4611: </a></span>     * closely the data type maps to the corresponding JDBC SQL type.
<span class="nocode"><a name="4612">4612: </a></span>     *
<span class="nocode"><a name="4613">4613: </a></span>     * &lt;P&gt;Each type description has the following columns:
<span class="nocode"><a name="4614">4614: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="4615">4615: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; Type name
<span class="nocode"><a name="4616">4616: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; short =&gt; SQL data type from java.sql.Types
<span class="nocode"><a name="4617">4617: </a></span>     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int =&gt; maximum precision
<span class="nocode"><a name="4618">4618: </a></span>     *  &lt;LI&gt;&lt;B&gt;LITERAL_PREFIX&lt;/B&gt; String =&gt; prefix used to quote a literal
<span class="nocode"><a name="4619">4619: </a></span>     *      (may be null)
<span class="nocode"><a name="4620">4620: </a></span>     *  &lt;LI&gt;&lt;B&gt;LITERAL_SUFFIX&lt;/B&gt; String =&gt; suffix used to quote a literal
<span class="nocode"><a name="4621">4621: </a></span>            (may be null)
<span class="nocode"><a name="4622">4622: </a></span>     *  &lt;LI&gt;&lt;B&gt;CREATE_PARAMS&lt;/B&gt; String =&gt; parameters used in creating
<span class="nocode"><a name="4623">4623: </a></span>     *      the type (may be null)
<span class="nocode"><a name="4624">4624: </a></span>     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short =&gt; can you use NULL for this type?
<span class="nocode"><a name="4625">4625: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4626">4626: </a></span>     *      &lt;LI&gt; typeNoNulls - does not allow NULL values
<span class="nocode"><a name="4627">4627: </a></span>     *      &lt;LI&gt; typeNullable - allows NULL values
<span class="nocode"><a name="4628">4628: </a></span>     *      &lt;LI&gt; typeNullableUnknown - nullability unknown
<span class="nocode"><a name="4629">4629: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4630">4630: </a></span>     *  &lt;LI&gt;&lt;B&gt;CASE_SENSITIVE&lt;/B&gt; boolean=&gt; is it case sensitive?
<span class="nocode"><a name="4631">4631: </a></span>     *  &lt;LI&gt;&lt;B&gt;SEARCHABLE&lt;/B&gt; short =&gt; can you use &quot;WHERE&quot; based on this type:
<span class="nocode"><a name="4632">4632: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4633">4633: </a></span>     *      &lt;LI&gt; typePredNone - No support
<span class="nocode"><a name="4634">4634: </a></span>     *      &lt;LI&gt; typePredChar - Only supported with WHERE .. LIKE
<span class="nocode"><a name="4635">4635: </a></span>     *      &lt;LI&gt; typePredBasic - Supported except for WHERE .. LIKE
<span class="nocode"><a name="4636">4636: </a></span>     *      &lt;LI&gt; typeSearchable - Supported for all WHERE ..
<span class="nocode"><a name="4637">4637: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4638">4638: </a></span>     *  &lt;LI&gt;&lt;B&gt;UNSIGNED_ATTRIBUTE&lt;/B&gt; boolean =&gt; is it unsigned?
<span class="nocode"><a name="4639">4639: </a></span>     *  &lt;LI&gt;&lt;B&gt;FIXED_PREC_SCALE&lt;/B&gt; boolean =&gt; can it be a money value?
<span class="nocode"><a name="4640">4640: </a></span>     *  &lt;LI&gt;&lt;B&gt;AUTO_INCREMENT&lt;/B&gt; boolean =&gt; can it be used for an
<span class="nocode"><a name="4641">4641: </a></span>     *      auto-increment value?
<span class="nocode"><a name="4642">4642: </a></span>     *  &lt;LI&gt;&lt;B&gt;LOCAL_TYPE_NAME&lt;/B&gt; String =&gt; localized version of type name
<span class="nocode"><a name="4643">4643: </a></span>     *      (may be null)
<span class="nocode"><a name="4644">4644: </a></span>     *  &lt;LI&gt;&lt;B&gt;MINIMUM_SCALE&lt;/B&gt; short =&gt; minimum scale supported
<span class="nocode"><a name="4645">4645: </a></span>     *  &lt;LI&gt;&lt;B&gt;MAXIMUM_SCALE&lt;/B&gt; short =&gt; maximum scale supported
<span class="nocode"><a name="4646">4646: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATA_TYPE&lt;/B&gt; int =&gt; unused
<span class="nocode"><a name="4647">4647: </a></span>     *  &lt;LI&gt;&lt;B&gt;SQL_DATETIME_SUB&lt;/B&gt; int =&gt; unused
<span class="nocode"><a name="4648">4648: </a></span>     *  &lt;LI&gt;&lt;B&gt;NUM_PREC_RADIX&lt;/B&gt; int =&gt; usually 2 or 10
<span class="nocode"><a name="4649">4649: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="4650">4650: </a></span>     *
<span class="nocode"><a name="4651">4651: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is an SQL type description
<span class="nocode"><a name="4652">4652: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="4653">4653: </a></span>     */
<span class="nocode"><a name="4654">4654: </a></span>    public  ResultSet getTypeInfo() throws SQLException {
<span class="nocode"><a name="4655">4655: </a></span>
<span class="nocode"><a name="4656">4656: </a></span><span style="background-color: #ffffcc">		final XSQLVAR anXSQLVAR = new XSQLVAR();</span>
<span class="nocode"><a name="4657">4657: </a></span>
<span class="nocode"><a name="4658">4658: </a></span><span style="background-color: #ffffcc">        byte[] shortZero = anXSQLVAR.encodeShort((short)0);</span>
<span class="nocode"><a name="4659">4659: </a></span><span style="background-color: #ffffcc">        byte[] CASESENSITIVE = getBytes(&quot;T&quot;);</span>
<span class="nocode"><a name="4660">4660: </a></span><span style="background-color: #ffffcc">        byte[] CASEINSENSITIVE = getBytes(&quot;F&quot;);</span>
<span class="nocode"><a name="4661">4661: </a></span><span style="background-color: #ffffcc">        byte[] UNSIGNED = getBytes(&quot;T&quot;);</span>
<span class="nocode"><a name="4662">4662: </a></span><span style="background-color: #ffffcc">        byte[] SIGNED = getBytes(&quot;F&quot;);</span>
<span class="nocode"><a name="4663">4663: </a></span><span style="background-color: #ffffcc">        byte[] FIXEDSCALE = getBytes(&quot;T&quot;);</span>
<span class="nocode"><a name="4664">4664: </a></span><span style="background-color: #ffffcc">        byte[] VARIABLESCALE = getBytes(&quot;F&quot;);</span>
<span class="nocode"><a name="4665">4665: </a></span><span style="background-color: #ffffcc">        byte[] NOTAUTOINC = getBytes(&quot;F&quot;);</span>
<span class="nocode"><a name="4666">4666: </a></span><span style="background-color: #ffffcc">        byte[] BINARY = anXSQLVAR.encodeInt(2);</span>
<span class="nocode"><a name="4667">4667: </a></span><span style="background-color: #ffffcc">        byte[] PREDNONE = anXSQLVAR.encodeShort((short) DatabaseMetaData.typePredNone);</span>
<span class="nocode"><a name="4668">4668: </a></span>        // TODO Find out why unused
<span class="nocode"><a name="4669">4669: </a></span><span style="background-color: #ffffcc">        byte[] PREDBASIC = anXSQLVAR.encodeShort((short) DatabaseMetaData.typePredBasic);</span>
<span class="nocode"><a name="4670">4670: </a></span><span style="background-color: #ffffcc">        byte[] SEARCHABLE = anXSQLVAR.encodeShort((short) DatabaseMetaData.typeSearchable);</span>
<span class="nocode"><a name="4671">4671: </a></span><span style="background-color: #ffffcc">        byte[] NULLABLE = anXSQLVAR.encodeShort((short) DatabaseMetaData.typeNullable);</span>
<span class="nocode"><a name="4672">4672: </a></span>        //need to construct xsqlvar[] for ResultSetMetaData.
<span class="nocode"><a name="4673">4673: </a></span><span style="background-color: #ffffcc">        XSQLVAR[] xsqlvars = new XSQLVAR[18];</span>
<span class="nocode"><a name="4674">4674: </a></span>
<span class="nocode"><a name="4675">4675: </a></span><span style="background-color: #ffffcc">        xsqlvars[0] = new XSQLVAR();</span>
<span class="nocode"><a name="4676">4676: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4677">4677: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqllen = 31;</span>
<span class="nocode"><a name="4678">4678: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqlname = &quot;TYPE_NAME&quot;;</span>
<span class="nocode"><a name="4679">4679: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4680">4680: </a></span>
<span class="nocode"><a name="4681">4681: </a></span><span style="background-color: #ffffcc">        xsqlvars[1] = new XSQLVAR();</span>
<span class="nocode"><a name="4682">4682: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4683">4683: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqlname = &quot;DATA_TYPE&quot;;</span>
<span class="nocode"><a name="4684">4684: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4685">4685: </a></span>
<span class="nocode"><a name="4686">4686: </a></span><span style="background-color: #ffffcc">        xsqlvars[2] = new XSQLVAR();</span>
<span class="nocode"><a name="4687">4687: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="4688">4688: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqlname = &quot;PRECISION&quot;;</span>
<span class="nocode"><a name="4689">4689: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4690">4690: </a></span>
<span class="nocode"><a name="4691">4691: </a></span><span style="background-color: #ffffcc">        xsqlvars[3] = new XSQLVAR();</span>
<span class="nocode"><a name="4692">4692: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4693">4693: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqllen = 1;</span>
<span class="nocode"><a name="4694">4694: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqlname = &quot;LITERAL_PREFIX&quot;;</span>
<span class="nocode"><a name="4695">4695: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4696">4696: </a></span>
<span class="nocode"><a name="4697">4697: </a></span><span style="background-color: #ffffcc">        xsqlvars[4] = new XSQLVAR();</span>
<span class="nocode"><a name="4698">4698: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4699">4699: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqllen = 1;</span>
<span class="nocode"><a name="4700">4700: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqlname = &quot;LITERAL_SUFFIX&quot;;</span>
<span class="nocode"><a name="4701">4701: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4702">4702: </a></span>
<span class="nocode"><a name="4703">4703: </a></span><span style="background-color: #ffffcc">        xsqlvars[5] = new XSQLVAR();</span>
<span class="nocode"><a name="4704">4704: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4705">4705: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqllen = 31;</span>
<span class="nocode"><a name="4706">4706: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqlname = &quot;CREATE_PARAMS&quot;;</span>
<span class="nocode"><a name="4707">4707: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4708">4708: </a></span>
<span class="nocode"><a name="4709">4709: </a></span><span style="background-color: #ffffcc">        xsqlvars[6] = new XSQLVAR();</span>
<span class="nocode"><a name="4710">4710: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4711">4711: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqlname = &quot;NULLABLE&quot;;</span>
<span class="nocode"><a name="4712">4712: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4713">4713: </a></span>
<span class="nocode"><a name="4714">4714: </a></span><span style="background-color: #ffffcc">        xsqlvars[7] = new XSQLVAR();</span>
<span class="nocode"><a name="4715">4715: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqltype = ISCConstants.SQL_TEXT;</span>
<span class="nocode"><a name="4716">4716: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqllen = 1;</span>
<span class="nocode"><a name="4717">4717: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].sqlname = &quot;CASE_SENSITIVE&quot;;</span>
<span class="nocode"><a name="4718">4718: </a></span><span style="background-color: #ffffcc">        xsqlvars[7].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4719">4719: </a></span>
<span class="nocode"><a name="4720">4720: </a></span><span style="background-color: #ffffcc">        xsqlvars[8] = new XSQLVAR();</span>
<span class="nocode"><a name="4721">4721: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4722">4722: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].sqlname = &quot;SEARCHABLE&quot;;</span>
<span class="nocode"><a name="4723">4723: </a></span><span style="background-color: #ffffcc">        xsqlvars[8].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4724">4724: </a></span>
<span class="nocode"><a name="4725">4725: </a></span><span style="background-color: #ffffcc">        xsqlvars[9] = new XSQLVAR();</span>
<span class="nocode"><a name="4726">4726: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqltype = ISCConstants.SQL_TEXT;</span>
<span class="nocode"><a name="4727">4727: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqllen = 1;</span>
<span class="nocode"><a name="4728">4728: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].sqlname = &quot;UNSIGNED_ATTRIBUTE&quot;;</span>
<span class="nocode"><a name="4729">4729: </a></span><span style="background-color: #ffffcc">        xsqlvars[9].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4730">4730: </a></span>
<span class="nocode"><a name="4731">4731: </a></span><span style="background-color: #ffffcc">        xsqlvars[10] = new XSQLVAR();</span>
<span class="nocode"><a name="4732">4732: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqltype = ISCConstants.SQL_TEXT;</span>
<span class="nocode"><a name="4733">4733: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqllen = 1;</span>
<span class="nocode"><a name="4734">4734: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].sqlname = &quot;FIXED_PREC_SCALE&quot;;</span>
<span class="nocode"><a name="4735">4735: </a></span><span style="background-color: #ffffcc">        xsqlvars[10].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4736">4736: </a></span>
<span class="nocode"><a name="4737">4737: </a></span><span style="background-color: #ffffcc">        xsqlvars[11] = new XSQLVAR();</span>
<span class="nocode"><a name="4738">4738: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqltype = ISCConstants.SQL_TEXT;</span>
<span class="nocode"><a name="4739">4739: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqllen = 1;</span>
<span class="nocode"><a name="4740">4740: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].sqlname = &quot;AUTO_INCREMENT&quot;;</span>
<span class="nocode"><a name="4741">4741: </a></span><span style="background-color: #ffffcc">        xsqlvars[11].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4742">4742: </a></span>
<span class="nocode"><a name="4743">4743: </a></span><span style="background-color: #ffffcc">        xsqlvars[12] = new XSQLVAR();</span>
<span class="nocode"><a name="4744">4744: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="4745">4745: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqllen = 31;</span>
<span class="nocode"><a name="4746">4746: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].sqlname = &quot;LOCAL_TYPE_NAME&quot;;</span>
<span class="nocode"><a name="4747">4747: </a></span><span style="background-color: #ffffcc">        xsqlvars[12].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4748">4748: </a></span>
<span class="nocode"><a name="4749">4749: </a></span><span style="background-color: #ffffcc">        xsqlvars[13] = new XSQLVAR();</span>
<span class="nocode"><a name="4750">4750: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4751">4751: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].sqlname = &quot;MINIMUM_SCALE&quot;;</span>
<span class="nocode"><a name="4752">4752: </a></span><span style="background-color: #ffffcc">        xsqlvars[13].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4753">4753: </a></span>
<span class="nocode"><a name="4754">4754: </a></span><span style="background-color: #ffffcc">        xsqlvars[14] = new XSQLVAR();</span>
<span class="nocode"><a name="4755">4755: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="4756">4756: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].sqlname = &quot;MAXIMUM_SCALE&quot;;</span>
<span class="nocode"><a name="4757">4757: </a></span><span style="background-color: #ffffcc">        xsqlvars[14].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4758">4758: </a></span>
<span class="nocode"><a name="4759">4759: </a></span><span style="background-color: #ffffcc">        xsqlvars[15] = new XSQLVAR();</span>
<span class="nocode"><a name="4760">4760: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="4761">4761: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].sqlname = &quot;SQL_DATA_TYPE&quot;;</span>
<span class="nocode"><a name="4762">4762: </a></span><span style="background-color: #ffffcc">        xsqlvars[15].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4763">4763: </a></span>
<span class="nocode"><a name="4764">4764: </a></span><span style="background-color: #ffffcc">        xsqlvars[16] = new XSQLVAR();</span>
<span class="nocode"><a name="4765">4765: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="4766">4766: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].sqlname = &quot;SQL_DATETIME_SUB&quot;;</span>
<span class="nocode"><a name="4767">4767: </a></span><span style="background-color: #ffffcc">        xsqlvars[16].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4768">4768: </a></span>
<span class="nocode"><a name="4769">4769: </a></span><span style="background-color: #ffffcc">        xsqlvars[17] = new XSQLVAR();</span>
<span class="nocode"><a name="4770">4770: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="4771">4771: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].sqlname = &quot;NUM_PREC_RADIX&quot;;</span>
<span class="nocode"><a name="4772">4772: </a></span><span style="background-color: #ffffcc">        xsqlvars[17].relname = &quot;TYPEINFO&quot;;</span>
<span class="nocode"><a name="4773">4773: </a></span>
<span class="nocode"><a name="4774">4774: </a></span>        //dialect 3 only
<span class="nocode"><a name="4775">4775: </a></span><span style="background-color: #ffffcc">        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();</span>
<span class="nocode"><a name="4776">4776: </a></span>
<span class="nocode"><a name="4777">4777: </a></span>        //BIGINT=-5
<span class="nocode"><a name="4778">4778: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;BIGINT&quot;), createShort(Types.BIGINT)</span>
<span class="nocode"><a name="4779">4779: </a></span>            , anXSQLVAR.encodeInt(64), null, null, null,
<span class="nocode"><a name="4780">4780: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, FIXEDSCALE,
<span class="nocode"><a name="4781">4781: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_INT64), null, BINARY});
<span class="nocode"><a name="4782">4782: </a></span>        
<span class="nocode"><a name="4783">4783: </a></span>        //LONGVARBINARY=-4
<span class="nocode"><a name="4784">4784: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;BLOB SUB_TYPE 0&quot;), createShort(Types.LONGVARBINARY)</span>
<span class="nocode"><a name="4785">4785: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4786">4786: </a></span>            NULLABLE, CASESENSITIVE, PREDNONE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4787">4787: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_BLOB), null, BINARY});
<span class="nocode"><a name="4788">4788: </a></span>
<span class="nocode"><a name="4789">4789: </a></span>        //LONGVARCHAR=-1
<span class="nocode"><a name="4790">4790: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;BLOB SUB_TYPE 1&quot;), createShort(Types.LONGVARCHAR)</span>
<span class="nocode"><a name="4791">4791: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4792">4792: </a></span>            NULLABLE, CASESENSITIVE, PREDNONE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4793">4793: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_BLOB), null, BINARY});
<span class="nocode"><a name="4794">4794: </a></span>
<span class="nocode"><a name="4795">4795: </a></span>        //CHAR=1
<span class="nocode"><a name="4796">4796: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;CHAR&quot;), createShort(Types.CHAR)</span>
<span class="nocode"><a name="4797">4797: </a></span>            , anXSQLVAR.encodeInt(32664), getBytes(&quot;'&quot;), getBytes(&quot;'&quot;), getBytes(&quot;length&quot;),
<span class="nocode"><a name="4798">4798: </a></span>            NULLABLE, CASESENSITIVE, SEARCHABLE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4799">4799: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_TEXT), null, BINARY});
<span class="nocode"><a name="4800">4800: </a></span>
<span class="nocode"><a name="4801">4801: </a></span>        //NUMERIC=2
<span class="nocode"><a name="4802">4802: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;NUMERIC&quot;), createShort(Types.NUMERIC)</span>
<span class="nocode"><a name="4803">4803: </a></span>            , anXSQLVAR.encodeInt(18), null, null, getBytes(&quot;precision,scale&quot;),
<span class="nocode"><a name="4804">4804: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, FIXEDSCALE,
<span class="nocode"><a name="4805">4805: </a></span>            NOTAUTOINC, null, shortZero, createShort(18), anXSQLVAR.encodeInt(ISCConstants.SQL_INT64), null, BINARY});
<span class="nocode"><a name="4806">4806: </a></span>
<span class="nocode"><a name="4807">4807: </a></span>        //DECIMAL=3
<span class="nocode"><a name="4808">4808: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;DECIMAL&quot;), createShort(Types.DECIMAL)</span>
<span class="nocode"><a name="4809">4809: </a></span>            , anXSQLVAR.encodeInt(18), null, null, getBytes(&quot;precision,scale&quot;),
<span class="nocode"><a name="4810">4810: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, FIXEDSCALE,
<span class="nocode"><a name="4811">4811: </a></span>            NOTAUTOINC, null, shortZero, createShort(18), anXSQLVAR.encodeInt(ISCConstants.SQL_INT64), null, BINARY});
<span class="nocode"><a name="4812">4812: </a></span>
<span class="nocode"><a name="4813">4813: </a></span>        //INTEGER=4
<span class="nocode"><a name="4814">4814: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;INTEGER&quot;), createShort(Types.INTEGER)</span>
<span class="nocode"><a name="4815">4815: </a></span>            , anXSQLVAR.encodeInt(32), null, null, null,
<span class="nocode"><a name="4816">4816: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, FIXEDSCALE,
<span class="nocode"><a name="4817">4817: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_LONG), null, BINARY});
<span class="nocode"><a name="4818">4818: </a></span>
<span class="nocode"><a name="4819">4819: </a></span>        //SMALLINT=5
<span class="nocode"><a name="4820">4820: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;SMALLINT&quot;), createShort(Types.SMALLINT)</span>
<span class="nocode"><a name="4821">4821: </a></span>            , anXSQLVAR.encodeInt(16), null, null, null,
<span class="nocode"><a name="4822">4822: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, FIXEDSCALE,
<span class="nocode"><a name="4823">4823: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_SHORT), null, BINARY});
<span class="nocode"><a name="4824">4824: </a></span>
<span class="nocode"><a name="4825">4825: </a></span>        //FLOAT=6
<span class="nocode"><a name="4826">4826: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;FLOAT&quot;), createShort(Types.FLOAT)</span>
<span class="nocode"><a name="4827">4827: </a></span>            , anXSQLVAR.encodeInt(7), null, null, null,
<span class="nocode"><a name="4828">4828: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, VARIABLESCALE,
<span class="nocode"><a name="4829">4829: </a></span>            NOTAUTOINC, null, createShort(0), createShort(7), anXSQLVAR.encodeInt(ISCConstants.SQL_FLOAT), null, BINARY});
<span class="nocode"><a name="4830">4830: </a></span>
<span class="nocode"><a name="4831">4831: </a></span>        //DOUBLE=8
<span class="nocode"><a name="4832">4832: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;DOUBLE PRECISION&quot;), createShort(Types.DOUBLE)</span>
<span class="nocode"><a name="4833">4833: </a></span>            , anXSQLVAR.encodeInt(15), null, null, null,
<span class="nocode"><a name="4834">4834: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, SIGNED, VARIABLESCALE,
<span class="nocode"><a name="4835">4835: </a></span>            NOTAUTOINC, null, createShort(0), createShort(15), anXSQLVAR.encodeInt(ISCConstants.SQL_DOUBLE), null, BINARY});
<span class="nocode"><a name="4836">4836: </a></span>
<span class="nocode"><a name="4837">4837: </a></span>        //VARCHAR=12
<span class="nocode"><a name="4838">4838: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;VARCHAR&quot;), createShort(Types.VARCHAR)</span>
<span class="nocode"><a name="4839">4839: </a></span>            , anXSQLVAR.encodeInt(32664), getBytes(&quot;'&quot;), getBytes(&quot;'&quot;), getBytes(&quot;length&quot;),
<span class="nocode"><a name="4840">4840: </a></span>            NULLABLE, CASESENSITIVE, SEARCHABLE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4841">4841: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_VARYING), null, BINARY});
<span class="nocode"><a name="4842">4842: </a></span>
<span class="nocode"><a name="4843">4843: </a></span>        //DATE=91
<span class="nocode"><a name="4844">4844: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;DATE&quot;), createShort(Types.DATE)</span>
<span class="nocode"><a name="4845">4845: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4846">4846: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4847">4847: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_TYPE_DATE), null, BINARY});
<span class="nocode"><a name="4848">4848: </a></span>
<span class="nocode"><a name="4849">4849: </a></span>        //TIME=92
<span class="nocode"><a name="4850">4850: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;TIME&quot;), createShort(Types.TIME)</span>
<span class="nocode"><a name="4851">4851: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4852">4852: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4853">4853: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_TYPE_TIME), null, BINARY});
<span class="nocode"><a name="4854">4854: </a></span>
<span class="nocode"><a name="4855">4855: </a></span>        //TIMESTAMP=93
<span class="nocode"><a name="4856">4856: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;TIMESTAMP&quot;), createShort(Types.TIMESTAMP)</span>
<span class="nocode"><a name="4857">4857: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4858">4858: </a></span>            NULLABLE, CASEINSENSITIVE, SEARCHABLE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4859">4859: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_TIMESTAMP), null, BINARY});
<span class="nocode"><a name="4860">4860: </a></span>
<span class="nocode"><a name="4861">4861: </a></span>        //OTHER=1111
<span class="nocode"><a name="4862">4862: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;ARRAY&quot;), createShort(Types.OTHER)</span>
<span class="nocode"><a name="4863">4863: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4864">4864: </a></span>            NULLABLE, CASESENSITIVE, PREDNONE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4865">4865: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_ARRAY), null, BINARY});
<span class="nocode"><a name="4866">4866: </a></span>
<span class="nocode"><a name="4867">4867: </a></span>        //BLOB=2004
<span class="nocode"><a name="4868">4868: </a></span><span style="background-color: #ffffcc">        rows.add(new byte[][] {getBytes(&quot;BLOB SUB_TYPE &lt;0 &quot;), createShort(Types.BLOB)</span>
<span class="nocode"><a name="4869">4869: </a></span>            , anXSQLVAR.encodeInt(0), null, null, null,
<span class="nocode"><a name="4870">4870: </a></span>            NULLABLE, CASESENSITIVE, PREDNONE, UNSIGNED, FIXEDSCALE,
<span class="nocode"><a name="4871">4871: </a></span>            NOTAUTOINC, null, shortZero, shortZero, anXSQLVAR.encodeInt(ISCConstants.SQL_BLOB), null, BINARY});
<span class="nocode"><a name="4872">4872: </a></span>
<span class="nocode"><a name="4873">4873: </a></span><span style="background-color: #ffffcc">        return new FBResultSet(xsqlvars, rows);</span>
<span class="nocode"><a name="4874">4874: </a></span>
<span class="nocode"><a name="4875">4875: </a></span>    }
<span class="nocode"><a name="4876">4876: </a></span>
<span class="nocode"><a name="4877">4877: </a></span>    private static final String GET_INDEX_INFO_START = &quot;SELECT &quot;
<span class="nocode"><a name="4878">4878: </a></span>        + &quot;  ind.RDB$RELATION_NAME AS TABLE_NAME&quot;
<span class="nocode"><a name="4879">4879: </a></span>        + &quot;, ind.RDB$UNIQUE_FLAG AS UNIQUE_FLAG&quot;
<span class="nocode"><a name="4880">4880: </a></span>        + &quot;, ind.RDB$INDEX_NAME as INDEX_NAME&quot;
<span class="nocode"><a name="4881">4881: </a></span>        + &quot;, ise.rdb$field_position + 1 as ORDINAL_POSITION&quot;
<span class="nocode"><a name="4882">4882: </a></span>        + &quot;, ise.rdb$field_name as COLUMN_NAME&quot;
<span class="nocode"><a name="4883">4883: </a></span>        + &quot;, ind.RDB$EXPRESSION_SOURCE as EXPRESSION_SOURCE&quot;
<span class="nocode"><a name="4884">4884: </a></span>        + &quot;, ind.RDB$INDEX_TYPE as ASC_OR_DESC &quot;
<span class="nocode"><a name="4885">4885: </a></span>        + &quot;FROM &quot;
<span class="nocode"><a name="4886">4886: </a></span>        + &quot;  rdb$indices ind &quot;
<span class="nocode"><a name="4887">4887: </a></span>        + &quot;  LEFT JOIN rdb$index_segments ise ON ind.rdb$index_name = ise.rdb$index_name &quot;
<span class="nocode"><a name="4888">4888: </a></span>        ;
<span class="nocode"><a name="4889">4889: </a></span>    
<span class="nocode"><a name="4890">4890: </a></span>    private static final String GET_INDEX_INFO =
<span class="nocode"><a name="4891">4891: </a></span>        GET_INDEX_INFO_START
<span class="nocode"><a name="4892">4892: </a></span>        + &quot;WHERE &quot; 
<span class="nocode"><a name="4893">4893: </a></span>        + &quot;  ind.rdb$relation_name = ? &quot;
<span class="nocode"><a name="4894">4894: </a></span>        + &quot;ORDER BY 2, 3, 4&quot;
<span class="nocode"><a name="4895">4895: </a></span>        ;
<span class="nocode"><a name="4896">4896: </a></span>    
<span class="nocode"><a name="4897">4897: </a></span>    private static final String GET_INDEX_INFO_UPPER =
<span class="nocode"><a name="4898">4898: </a></span>        GET_INDEX_INFO_START
<span class="nocode"><a name="4899">4899: </a></span>        + &quot;WHERE &quot; 
<span class="nocode"><a name="4900">4900: </a></span>        + &quot;  UPPER(ind.rdb$relation_name) = ? &quot;
<span class="nocode"><a name="4901">4901: </a></span>        + &quot;ORDER BY 2, 3, 4&quot;
<span class="nocode"><a name="4902">4902: </a></span>        ;
<span class="nocode"><a name="4903">4903: </a></span>
<span class="nocode"><a name="4904">4904: </a></span>    /**
<span class="nocode"><a name="4905">4905: </a></span>     * Gets a description of a table's indices and statistics. They are
<span class="nocode"><a name="4906">4906: </a></span>     * ordered by NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
<span class="nocode"><a name="4907">4907: </a></span>     *
<span class="nocode"><a name="4908">4908: </a></span>     * &lt;P&gt;Each index column description has the following columns:
<span class="nocode"><a name="4909">4909: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="4910">4910: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; table catalog (may be null)
<span class="nocode"><a name="4911">4911: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; table schema (may be null)
<span class="nocode"><a name="4912">4912: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; table name
<span class="nocode"><a name="4913">4913: </a></span>     *  &lt;LI&gt;&lt;B&gt;NON_UNIQUE&lt;/B&gt; boolean =&gt; Can index values be non-unique?
<span class="nocode"><a name="4914">4914: </a></span>     *      false when TYPE is tableIndexStatistic
<span class="nocode"><a name="4915">4915: </a></span>     *  &lt;LI&gt;&lt;B&gt;INDEX_QUALIFIER&lt;/B&gt; String =&gt; index catalog (may be null);
<span class="nocode"><a name="4916">4916: </a></span>     *      null when TYPE is tableIndexStatistic
<span class="nocode"><a name="4917">4917: </a></span>     *  &lt;LI&gt;&lt;B&gt;INDEX_NAME&lt;/B&gt; String =&gt; index name; null when TYPE is
<span class="nocode"><a name="4918">4918: </a></span>     *      tableIndexStatistic
<span class="nocode"><a name="4919">4919: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE&lt;/B&gt; short =&gt; index type:
<span class="nocode"><a name="4920">4920: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="4921">4921: </a></span>     *      &lt;LI&gt; tableIndexStatistic - this identifies table statistics that are
<span class="nocode"><a name="4922">4922: </a></span>     *           returned in conjuction with a table's index descriptions
<span class="nocode"><a name="4923">4923: </a></span>     *      &lt;LI&gt; tableIndexClustered - this is a clustered index
<span class="nocode"><a name="4924">4924: </a></span>     *      &lt;LI&gt; tableIndexHashed - this is a hashed index
<span class="nocode"><a name="4925">4925: </a></span>     *      &lt;LI&gt; tableIndexOther - this is some other style of index
<span class="nocode"><a name="4926">4926: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="4927">4927: </a></span>     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; short =&gt; column sequence number
<span class="nocode"><a name="4928">4928: </a></span>     *      within index; zero when TYPE is tableIndexStatistic
<span class="nocode"><a name="4929">4929: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column name; null when TYPE is
<span class="nocode"><a name="4930">4930: </a></span>     *      tableIndexStatistic
<span class="nocode"><a name="4931">4931: </a></span>     *  &lt;LI&gt;&lt;B&gt;ASC_OR_DESC&lt;/B&gt; String =&gt; column sort sequence, &quot;A&quot; =&gt; ascending,
<span class="nocode"><a name="4932">4932: </a></span>     *      &quot;D&quot; =&gt; descending, may be null if sort sequence is not supported;
<span class="nocode"><a name="4933">4933: </a></span>     *      null when TYPE is tableIndexStatistic
<span class="nocode"><a name="4934">4934: </a></span>     *  &lt;LI&gt;&lt;B&gt;CARDINALITY&lt;/B&gt; int =&gt; When TYPE is tableIndexStatistic, then
<span class="nocode"><a name="4935">4935: </a></span>     *      this is the number of rows in the table; otherwise, it is the
<span class="nocode"><a name="4936">4936: </a></span>     *      number of unique values in the index.
<span class="nocode"><a name="4937">4937: </a></span>     *  &lt;LI&gt;&lt;B&gt;PAGES&lt;/B&gt; int =&gt; When TYPE is  tableIndexStatisic then
<span class="nocode"><a name="4938">4938: </a></span>     *      this is the number of pages used for the table, otherwise it
<span class="nocode"><a name="4939">4939: </a></span>     *      is the number of pages used for the current index.
<span class="nocode"><a name="4940">4940: </a></span>     *  &lt;LI&gt;&lt;B&gt;FILTER_CONDITION&lt;/B&gt; String =&gt; Filter condition, if any.
<span class="nocode"><a name="4941">4941: </a></span>     *      (may be null)
<span class="nocode"><a name="4942">4942: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="4943">4943: </a></span>     *
<span class="nocode"><a name="4944">4944: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a
<span class="nocode"><a name="4945">4945: </a></span>     * catalog; null means drop catalog name from the selection criteria
<span class="nocode"><a name="4946">4946: </a></span>     * @param schema a schema name; &quot;&quot; retrieves those without a schema
<span class="nocode"><a name="4947">4947: </a></span>     * @param table a table name
<span class="nocode"><a name="4948">4948: </a></span>     * @param unique when true, return only indices for unique values;
<span class="nocode"><a name="4949">4949: </a></span>     *     when false, return indices regardless of whether unique or not
<span class="nocode"><a name="4950">4950: </a></span>     * @param approximate when true, result is allowed to reflect approximate
<span class="nocode"><a name="4951">4951: </a></span>     *     or out of data values; when false, results are requested to be
<span class="nocode"><a name="4952">4952: </a></span>     *     accurate
<span class="nocode"><a name="4953">4953: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is an index column description
<span class="nocode"><a name="4954">4954: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="4955">4955: </a></span>     */
<span class="nocode"><a name="4956">4956: </a></span>    public ResultSet getIndexInfo(String catalog, String schema, String table,
<span class="nocode"><a name="4957">4957: </a></span>        boolean unique, boolean approximate) throws SQLException {
<span class="nocode"><a name="4958">4958: </a></span>        checkCatalogAndSchema(catalog, schema);
<span class="nocode"><a name="4959">4959: </a></span>
<span class="nocode"><a name="4960">4960: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[13];
<span class="nocode"><a name="4961">4961: </a></span>
<span class="nocode"><a name="4962">4962: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="4963">4963: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4964">4964: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="4965">4965: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="4966">4966: </a></span>        xsqlvars[0].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4967">4967: </a></span>
<span class="nocode"><a name="4968">4968: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="4969">4969: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4970">4970: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="4971">4971: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="4972">4972: </a></span>        xsqlvars[1].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4973">4973: </a></span>
<span class="nocode"><a name="4974">4974: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="4975">4975: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4976">4976: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="4977">4977: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="4978">4978: </a></span>        xsqlvars[2].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4979">4979: </a></span>
<span class="nocode"><a name="4980">4980: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="4981">4981: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_TEXT;
<span class="nocode"><a name="4982">4982: </a></span>        xsqlvars[3].sqllen = 1;
<span class="nocode"><a name="4983">4983: </a></span>        xsqlvars[3].sqlname = &quot;NON_UNIQUE&quot;;
<span class="nocode"><a name="4984">4984: </a></span>        xsqlvars[3].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4985">4985: </a></span>
<span class="nocode"><a name="4986">4986: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="4987">4987: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4988">4988: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="4989">4989: </a></span>        xsqlvars[4].sqlname = &quot;INDEX_QUALIFIER&quot;;
<span class="nocode"><a name="4990">4990: </a></span>        xsqlvars[4].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4991">4991: </a></span>
<span class="nocode"><a name="4992">4992: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="4993">4993: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="4994">4994: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="4995">4995: </a></span>        xsqlvars[5].sqlname = &quot;INDEX_NAME&quot;;
<span class="nocode"><a name="4996">4996: </a></span>        xsqlvars[5].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="4997">4997: </a></span>
<span class="nocode"><a name="4998">4998: </a></span>        xsqlvars[6] = new XSQLVAR();
<span class="nocode"><a name="4999">4999: </a></span>        xsqlvars[6].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="5000">5000: </a></span>        xsqlvars[6].sqlname = &quot;TYPE&quot;;
<span class="nocode"><a name="5001">5001: </a></span>        xsqlvars[6].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5002">5002: </a></span>
<span class="nocode"><a name="5003">5003: </a></span>        xsqlvars[7] = new XSQLVAR();
<span class="nocode"><a name="5004">5004: </a></span>        xsqlvars[7].sqltype = ISCConstants.SQL_SHORT;
<span class="nocode"><a name="5005">5005: </a></span>        xsqlvars[7].sqlname = &quot;ORDINAL_POSITION&quot;;
<span class="nocode"><a name="5006">5006: </a></span>        xsqlvars[7].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5007">5007: </a></span>
<span class="nocode"><a name="5008">5008: </a></span>        xsqlvars[8] = new XSQLVAR();
<span class="nocode"><a name="5009">5009: </a></span>        xsqlvars[8].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5010">5010: </a></span>        xsqlvars[8].sqllen = 31;
<span class="nocode"><a name="5011">5011: </a></span>        xsqlvars[8].sqlname = &quot;COLUMN_NAME&quot;;
<span class="nocode"><a name="5012">5012: </a></span>        xsqlvars[8].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5013">5013: </a></span>
<span class="nocode"><a name="5014">5014: </a></span>        xsqlvars[9] = new XSQLVAR();
<span class="nocode"><a name="5015">5015: </a></span>        xsqlvars[9].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5016">5016: </a></span>        xsqlvars[9].sqllen = 31;
<span class="nocode"><a name="5017">5017: </a></span>        xsqlvars[9].sqlname = &quot;ASC_OR_DESC&quot;;
<span class="nocode"><a name="5018">5018: </a></span>        xsqlvars[9].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5019">5019: </a></span>
<span class="nocode"><a name="5020">5020: </a></span>        xsqlvars[10] = new XSQLVAR();
<span class="nocode"><a name="5021">5021: </a></span>        xsqlvars[10].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="5022">5022: </a></span>        xsqlvars[10].sqlname = &quot;CARDINALITY&quot;;
<span class="nocode"><a name="5023">5023: </a></span>        xsqlvars[10].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5024">5024: </a></span>
<span class="nocode"><a name="5025">5025: </a></span>        xsqlvars[11] = new XSQLVAR();
<span class="nocode"><a name="5026">5026: </a></span>        xsqlvars[11].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="5027">5027: </a></span>        xsqlvars[11].sqlname = &quot;PAGES&quot;;
<span class="nocode"><a name="5028">5028: </a></span>        xsqlvars[11].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5029">5029: </a></span>
<span class="nocode"><a name="5030">5030: </a></span>        xsqlvars[12] = new XSQLVAR();
<span class="nocode"><a name="5031">5031: </a></span>        xsqlvars[12].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5032">5032: </a></span>        xsqlvars[12].sqllen = 31;
<span class="nocode"><a name="5033">5033: </a></span>        xsqlvars[12].sqlname = &quot;FILTER_CONDITION&quot;;
<span class="nocode"><a name="5034">5034: </a></span>        xsqlvars[12].relname = &quot;INDEXINFO&quot;;
<span class="nocode"><a name="5035">5035: </a></span>
<span class="nocode"><a name="5036">5036: </a></span>        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;();
<span class="nocode"><a name="5037">5037: </a></span>        
<span class="nocode"><a name="5038">5038: </a></span>        if (table == null) {
<span class="nocode"><a name="5039">5039: </a></span>            return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5040">5040: </a></span>        }
<span class="nocode"><a name="5041">5041: </a></span>
<span class="nocode"><a name="5042">5042: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="5043">5043: </a></span>        params.add(table);
<span class="nocode"><a name="5044">5044: </a></span>
<span class="nocode"><a name="5045">5045: </a></span>        ResultSet rs = doQuery(GET_INDEX_INFO, params);
<span class="nocode"><a name="5046">5046: </a></span>
<span class="nocode"><a name="5047">5047: </a></span>        // if no direct match happened, check the uppercased match
<span class="nocode"><a name="5048">5048: </a></span>        if (!rs.next()) {
<span class="nocode"><a name="5049">5049: </a></span>            params.set(0, table.toUpperCase());
<span class="nocode"><a name="5050">5050: </a></span>            rs = doQuery(GET_INDEX_INFO_UPPER, params);
<span class="nocode"><a name="5051">5051: </a></span>            
<span class="nocode"><a name="5052">5052: </a></span>            // open the second result set and check whether we have rows
<span class="nocode"><a name="5053">5053: </a></span>            // if no rows are available, we have to exit now, otherwise the 
<span class="nocode"><a name="5054">5054: </a></span>            // following do/while loop will throw SQLException that the
<span class="nocode"><a name="5055">5055: </a></span>            // result set is not positioned on a row
<span class="nocode"><a name="5056">5056: </a></span>            if (!rs.next())
<span class="nocode"><a name="5057">5057: </a></span>                return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5058">5058: </a></span>        }
<span class="nocode"><a name="5059">5059: </a></span>        
<span class="nocode"><a name="5060">5060: </a></span>        do {
<span class="nocode"><a name="5061">5061: </a></span>            byte[][] row = new byte[13][];
<span class="nocode"><a name="5062">5062: </a></span>            row[0] = null;
<span class="nocode"><a name="5063">5063: </a></span>            row[1] = null;
<span class="nocode"><a name="5064">5064: </a></span>            row[2] = getBytes(rs.getString(&quot;TABLE_NAME&quot;));
<span class="nocode"><a name="5065">5065: </a></span>            boolean isNotUnique = (rs.getInt(&quot;UNIQUE_FLAG&quot;) == 0);
<span class="nocode"><a name="5066">5066: </a></span>            if (unique &amp;&amp; isNotUnique) {
<span class="nocode"><a name="5067">5067: </a></span>                // Skip indices that are not unique, as requested
<span class="nocode"><a name="5068">5068: </a></span>                continue;
<span class="nocode"><a name="5069">5069: </a></span>            }
<span class="nocode"><a name="5070">5070: </a></span>            row[3] = getBytes(isNotUnique ? &quot;T&quot; : &quot;F&quot;);
<span class="nocode"><a name="5071">5071: </a></span>            row[4] = null;
<span class="nocode"><a name="5072">5072: </a></span>            row[5] = getBytes(rs.getString(&quot;INDEX_NAME&quot;));
<span class="nocode"><a name="5073">5073: </a></span>            row[6] = xsqlvars[0].encodeShort(DatabaseMetaData.tableIndexOther);
<span class="nocode"><a name="5074">5074: </a></span>            String columnName = rs.getString(&quot;COLUMN_NAME&quot;);
<span class="nocode"><a name="5075">5075: </a></span>            if (rs.wasNull()) {
<span class="nocode"><a name="5076">5076: </a></span>                row[7] = xsqlvars[0].encodeShort((short)1);
<span class="nocode"><a name="5077">5077: </a></span>                String expressionSource = rs.getString(&quot;EXPRESSION_SOURCE&quot;);
<span class="nocode"><a name="5078">5078: </a></span>                if (expressionSource != null) {
<span class="nocode"><a name="5079">5079: </a></span>                    row[8] = getBytes(expressionSource);
<span class="nocode"><a name="5080">5080: </a></span>                    if (expressionSource.length() &gt; xsqlvars[8].sqllen) {
<span class="nocode"><a name="5081">5081: </a></span>                        xsqlvars[8].sqllen = expressionSource.length();
<span class="nocode"><a name="5082">5082: </a></span>                    }
<span class="nocode"><a name="5083">5083: </a></span>                } else {
<span class="nocode"><a name="5084">5084: </a></span>                    row[8] = null;
<span class="nocode"><a name="5085">5085: </a></span>                }
<span class="nocode"><a name="5086">5086: </a></span>            } else {
<span class="nocode"><a name="5087">5087: </a></span>                row[7] = xsqlvars[0].encodeShort(rs.getShort(&quot;ORDINAL_POSITION&quot;));
<span class="nocode"><a name="5088">5088: </a></span>                row[8] = getBytes(columnName);
<span class="nocode"><a name="5089">5089: </a></span>            }
<span class="nocode"><a name="5090">5090: </a></span>            int ascOrDesc = rs.getInt(&quot;ASC_OR_DESC&quot;);
<span class="nocode"><a name="5091">5091: </a></span>            if (ascOrDesc == 0) {
<span class="nocode"><a name="5092">5092: </a></span>                row[9] = getBytes(&quot;A&quot;);
<span class="nocode"><a name="5093">5093: </a></span>            } else if (ascOrDesc == 1) {
<span class="nocode"><a name="5094">5094: </a></span>                row[9] = getBytes(&quot;D&quot;);
<span class="nocode"><a name="5095">5095: </a></span>            } else {
<span class="nocode"><a name="5096">5096: </a></span>                row[9] = null;
<span class="nocode"><a name="5097">5097: </a></span>            }
<span class="nocode"><a name="5098">5098: </a></span>            // NOTE: We are setting CARDINALITY and PAGES to NULL as we don't have this info; might contravene JDBC spec
<span class="nocode"><a name="5099">5099: </a></span>            // TODO use 1 / RDB$STATISTICS for approximation of CARDINALITY?
<span class="nocode"><a name="5100">5100: </a></span>            row[10] = null;
<span class="nocode"><a name="5101">5101: </a></span>            // TODO query RDB$PAGES for PAGES information?
<span class="nocode"><a name="5102">5102: </a></span>            row[11] = null;
<span class="nocode"><a name="5103">5103: </a></span>            row[12] = null;
<span class="nocode"><a name="5104">5104: </a></span>
<span class="nocode"><a name="5105">5105: </a></span>            rows.add(row);
<span class="nocode"><a name="5106">5106: </a></span>            
<span class="nocode"><a name="5107">5107: </a></span>        } while (rs.next());
<span class="nocode"><a name="5108">5108: </a></span>        
<span class="nocode"><a name="5109">5109: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5110">5110: </a></span>    }
<span class="nocode"><a name="5111">5111: </a></span>
<span class="nocode"><a name="5112">5112: </a></span>    //--------------------------JDBC 2.0-----------------------------
<span class="nocode"><a name="5113">5113: </a></span>
<span class="nocode"><a name="5114">5114: </a></span>    /**
<span class="nocode"><a name="5115">5115: </a></span>     * Does the database support the given result set type?
<span class="nocode"><a name="5116">5116: </a></span>     *
<span class="nocode"><a name="5117">5117: </a></span>     * @param type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
<span class="nocode"><a name="5118">5118: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5119">5119: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5120">5120: </a></span>     * @see Connection
<span class="nocode"><a name="5121">5121: </a></span>     * @since 1.2
<span class="nocode"><a name="5122">5122: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5123">5123: </a></span>     */
<span class="nocode"><a name="5124">5124: </a></span>    public boolean supportsResultSetType(int type) throws SQLException {
<span class="nocode"><a name="5125">5125: </a></span>        switch (type){
<span class="nocode"><a name="5126">5126: </a></span>            case ResultSet.TYPE_FORWARD_ONLY:
<span class="nocode"><a name="5127">5127: </a></span>            case ResultSet.TYPE_SCROLL_INSENSITIVE :
<span class="nocode"><a name="5128">5128: </a></span>            case ResultSet.TYPE_SCROLL_SENSITIVE :
<span class="nocode"><a name="5129">5129: </a></span>                return true;
<span class="nocode"><a name="5130">5130: </a></span>            default:
<span class="nocode"><a name="5131">5131: </a></span>                return false;
<span class="nocode"><a name="5132">5132: </a></span>        }
<span class="nocode"><a name="5133">5133: </a></span>    }
<span class="nocode"><a name="5134">5134: </a></span>
<span class="nocode"><a name="5135">5135: </a></span>    /**
<span class="nocode"><a name="5136">5136: </a></span>     * Does the database support the concurrency type in combination
<span class="nocode"><a name="5137">5137: </a></span>     * with the given result set type?
<span class="nocode"><a name="5138">5138: </a></span>     *
<span class="nocode"><a name="5139">5139: </a></span>     * @param type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
<span class="nocode"><a name="5140">5140: </a></span>     * @param concurrency type defined in &lt;code&gt;java.sql.ResultSet&lt;/code&gt;
<span class="nocode"><a name="5141">5141: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if so; &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5142">5142: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5143">5143: </a></span>     * @see Connection
<span class="nocode"><a name="5144">5144: </a></span>     * @since 1.2
<span class="nocode"><a name="5145">5145: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5146">5146: </a></span>     */
<span class="nocode"><a name="5147">5147: </a></span>    public boolean supportsResultSetConcurrency(int type, int concurrency) throws SQLException {
<span class="nocode"><a name="5148">5148: </a></span>        switch(type) {
<span class="nocode"><a name="5149">5149: </a></span>            case ResultSet.TYPE_FORWARD_ONLY:
<span class="nocode"><a name="5150">5150: </a></span>            case ResultSet.TYPE_SCROLL_INSENSITIVE :
<span class="nocode"><a name="5151">5151: </a></span>            case ResultSet.TYPE_SCROLL_SENSITIVE :
<span class="nocode"><a name="5152">5152: </a></span>                return concurrency == ResultSet.CONCUR_READ_ONLY || 
<span class="nocode"><a name="5153">5153: </a></span>                    concurrency == ResultSet.CONCUR_UPDATABLE;
<span class="nocode"><a name="5154">5154: </a></span>            default:
<span class="nocode"><a name="5155">5155: </a></span>                return false;
<span class="nocode"><a name="5156">5156: </a></span>        }
<span class="nocode"><a name="5157">5157: </a></span>    }
<span class="nocode"><a name="5158">5158: </a></span>
<span class="nocode"><a name="5159">5159: </a></span>    /**
<span class="nocode"><a name="5160">5160: </a></span>     *
<span class="nocode"><a name="5161">5161: </a></span>     * Indicates whether a result set's own updates are visible.
<span class="nocode"><a name="5162">5162: </a></span>     *
<span class="nocode"><a name="5163">5163: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5164">5164: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if updates are visible for the result set type;
<span class="nocode"><a name="5165">5165: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5166">5166: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5167">5167: </a></span>     * @since 1.2
<span class="nocode"><a name="5168">5168: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5169">5169: </a></span>     */
<span class="nocode"><a name="5170">5170: </a></span>    public boolean ownUpdatesAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5171">5171: </a></span>        return ResultSet.TYPE_SCROLL_INSENSITIVE == type ||
<span class="nocode"><a name="5172">5172: </a></span>            ResultSet.TYPE_SCROLL_SENSITIVE == type;
<span class="nocode"><a name="5173">5173: </a></span>    }
<span class="nocode"><a name="5174">5174: </a></span>
<span class="nocode"><a name="5175">5175: </a></span>    /**
<span class="nocode"><a name="5176">5176: </a></span>     *
<span class="nocode"><a name="5177">5177: </a></span>     * Indicates whether a result set's own deletes are visible.
<span class="nocode"><a name="5178">5178: </a></span>     *
<span class="nocode"><a name="5179">5179: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5180">5180: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if deletes are visible for the result set type;
<span class="nocode"><a name="5181">5181: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5182">5182: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5183">5183: </a></span>     * @since 1.2
<span class="nocode"><a name="5184">5184: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5185">5185: </a></span>     */
<span class="nocode"><a name="5186">5186: </a></span>    public boolean ownDeletesAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5187">5187: </a></span>        return ResultSet.TYPE_SCROLL_INSENSITIVE == type ||
<span class="nocode"><a name="5188">5188: </a></span>            ResultSet.TYPE_SCROLL_SENSITIVE == type;
<span class="nocode"><a name="5189">5189: </a></span>    }
<span class="nocode"><a name="5190">5190: </a></span>
<span class="nocode"><a name="5191">5191: </a></span>    /**
<span class="nocode"><a name="5192">5192: </a></span>     *
<span class="nocode"><a name="5193">5193: </a></span>     * Indicates whether a result set's own inserts are visible.
<span class="nocode"><a name="5194">5194: </a></span>     *
<span class="nocode"><a name="5195">5195: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5196">5196: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if inserts are visible for the result set type;
<span class="nocode"><a name="5197">5197: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5198">5198: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5199">5199: </a></span>     * @since 1.2
<span class="nocode"><a name="5200">5200: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5201">5201: </a></span>     */
<span class="nocode"><a name="5202">5202: </a></span>    public boolean ownInsertsAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5203">5203: </a></span>        return ResultSet.TYPE_SCROLL_INSENSITIVE == type ||
<span class="nocode"><a name="5204">5204: </a></span>            ResultSet.TYPE_SCROLL_SENSITIVE == type;
<span class="nocode"><a name="5205">5205: </a></span>    }
<span class="nocode"><a name="5206">5206: </a></span>
<span class="nocode"><a name="5207">5207: </a></span>    /**
<span class="nocode"><a name="5208">5208: </a></span>     *
<span class="nocode"><a name="5209">5209: </a></span>     * Indicates whether updates made by others are visible.
<span class="nocode"><a name="5210">5210: </a></span>     *
<span class="nocode"><a name="5211">5211: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5212">5212: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if updates made by others
<span class="nocode"><a name="5213">5213: </a></span>     * are visible for the result set type;
<span class="nocode"><a name="5214">5214: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5215">5215: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5216">5216: </a></span>     * @since 1.2
<span class="nocode"><a name="5217">5217: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5218">5218: </a></span>     */
<span class="nocode"><a name="5219">5219: </a></span>    public boolean othersUpdatesAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5220">5220: </a></span>        return false;
<span class="nocode"><a name="5221">5221: </a></span>    }
<span class="nocode"><a name="5222">5222: </a></span>
<span class="nocode"><a name="5223">5223: </a></span>    /**
<span class="nocode"><a name="5224">5224: </a></span>     *
<span class="nocode"><a name="5225">5225: </a></span>     * Indicates whether deletes made by others are visible.
<span class="nocode"><a name="5226">5226: </a></span>     *
<span class="nocode"><a name="5227">5227: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5228">5228: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if deletes made by others
<span class="nocode"><a name="5229">5229: </a></span>     * are visible for the result set type;
<span class="nocode"><a name="5230">5230: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5231">5231: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5232">5232: </a></span>     * @since 1.2
<span class="nocode"><a name="5233">5233: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5234">5234: </a></span>     */
<span class="nocode"><a name="5235">5235: </a></span>    public boolean othersDeletesAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5236">5236: </a></span>        return false;
<span class="nocode"><a name="5237">5237: </a></span>    }
<span class="nocode"><a name="5238">5238: </a></span>
<span class="nocode"><a name="5239">5239: </a></span>    /**
<span class="nocode"><a name="5240">5240: </a></span>     *
<span class="nocode"><a name="5241">5241: </a></span>     * Indicates whether inserts made by others are visible.
<span class="nocode"><a name="5242">5242: </a></span>     *
<span class="nocode"><a name="5243">5243: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5244">5244: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if inserts made by others
<span class="nocode"><a name="5245">5245: </a></span>     * are visible for the result set type;
<span class="nocode"><a name="5246">5246: </a></span>     *        &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5247">5247: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5248">5248: </a></span>     * @since 1.2
<span class="nocode"><a name="5249">5249: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5250">5250: </a></span>     */
<span class="nocode"><a name="5251">5251: </a></span>    public boolean othersInsertsAreVisible(int type) throws SQLException {
<span class="nocode"><a name="5252">5252: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="5253">5253: </a></span>    }
<span class="nocode"><a name="5254">5254: </a></span>
<span class="nocode"><a name="5255">5255: </a></span>    /**
<span class="nocode"><a name="5256">5256: </a></span>     *
<span class="nocode"><a name="5257">5257: </a></span>     * Indicates whether or not a visible row update can be detected by
<span class="nocode"><a name="5258">5258: </a></span>     * calling the method &lt;code&gt;ResultSet.rowUpdated&lt;/code&gt;.
<span class="nocode"><a name="5259">5259: </a></span>     *
<span class="nocode"><a name="5260">5260: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5261">5261: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if changes are detected by the result set type;
<span class="nocode"><a name="5262">5262: </a></span>     *         &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5263">5263: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5264">5264: </a></span>     * @since 1.2
<span class="nocode"><a name="5265">5265: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5266">5266: </a></span>     */
<span class="nocode"><a name="5267">5267: </a></span>    public boolean updatesAreDetected(int type) throws SQLException {
<span class="nocode"><a name="5268">5268: </a></span>        return false;
<span class="nocode"><a name="5269">5269: </a></span>    }
<span class="nocode"><a name="5270">5270: </a></span>
<span class="nocode"><a name="5271">5271: </a></span>    /**
<span class="nocode"><a name="5272">5272: </a></span>     *
<span class="nocode"><a name="5273">5273: </a></span>     * Indicates whether or not a visible row delete can be detected by
<span class="nocode"><a name="5274">5274: </a></span>     * calling ResultSet.rowDeleted().  If deletesAreDetected()
<span class="nocode"><a name="5275">5275: </a></span>     * returns false, then deleted rows are removed from the result set.
<span class="nocode"><a name="5276">5276: </a></span>     *
<span class="nocode"><a name="5277">5277: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5278">5278: </a></span>     * @return true if changes are detected by the resultset type
<span class="nocode"><a name="5279">5279: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5280">5280: </a></span>     * @since 1.2
<span class="nocode"><a name="5281">5281: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5282">5282: </a></span>     */
<span class="nocode"><a name="5283">5283: </a></span>    public boolean deletesAreDetected(int type) throws SQLException {
<span class="nocode"><a name="5284">5284: </a></span>        return false;
<span class="nocode"><a name="5285">5285: </a></span>    }
<span class="nocode"><a name="5286">5286: </a></span>
<span class="nocode"><a name="5287">5287: </a></span>    /**
<span class="nocode"><a name="5288">5288: </a></span>     *
<span class="nocode"><a name="5289">5289: </a></span>     * Indicates whether or not a visible row insert can be detected
<span class="nocode"><a name="5290">5290: </a></span>     * by calling ResultSet.rowInserted().
<span class="nocode"><a name="5291">5291: </a></span>     *
<span class="nocode"><a name="5292">5292: </a></span>     * @param type result set type, i.e. ResultSet.TYPE_XXX
<span class="nocode"><a name="5293">5293: </a></span>     * @return true if changes are detected by the resultset type
<span class="nocode"><a name="5294">5294: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5295">5295: </a></span>     * @since 1.2
<span class="nocode"><a name="5296">5296: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5297">5297: </a></span>     */
<span class="nocode"><a name="5298">5298: </a></span>    public boolean insertsAreDetected(int type) throws SQLException {
<span class="nocode"><a name="5299">5299: </a></span>        return false;
<span class="nocode"><a name="5300">5300: </a></span>    }
<span class="nocode"><a name="5301">5301: </a></span>
<span class="nocode"><a name="5302">5302: </a></span>    /**
<span class="nocode"><a name="5303">5303: </a></span>     *
<span class="nocode"><a name="5304">5304: </a></span>     * Indicates whether the driver supports batch updates.
<span class="nocode"><a name="5305">5305: </a></span>     * @return true if the driver supports batch updates; false otherwise
<span class="nocode"><a name="5306">5306: </a></span>     * @since 1.2
<span class="nocode"><a name="5307">5307: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5308">5308: </a></span>     */
<span class="nocode"><a name="5309">5309: </a></span>    public boolean supportsBatchUpdates() throws SQLException {
<span class="nocode"><a name="5310">5310: </a></span>        return true;
<span class="nocode"><a name="5311">5311: </a></span>    }
<span class="nocode"><a name="5312">5312: </a></span>
<span class="nocode"><a name="5313">5313: </a></span>    /**
<span class="nocode"><a name="5314">5314: </a></span>     * Retrieves a description of the user-defined types (UDTs) defined
<span class="nocode"><a name="5315">5315: </a></span>     * in a particular schema.  Schema-specific UDTs may have type
<span class="nocode"><a name="5316">5316: </a></span>     * &lt;code&gt;JAVA_OBJECT&lt;/code&gt;, &lt;code&gt;STRUCT&lt;/code&gt;,
<span class="nocode"><a name="5317">5317: </a></span>     * or &lt;code&gt;DISTINCT&lt;/code&gt;.
<span class="nocode"><a name="5318">5318: </a></span>     *
<span class="nocode"><a name="5319">5319: </a></span>     * &lt;P&gt;Only types matching the catalog, schema, type name and type
<span class="nocode"><a name="5320">5320: </a></span>     * criteria are returned.  They are ordered by &lt;code&gt;DATA_TYPE&lt;/code&gt;,
<span class="nocode"><a name="5321">5321: </a></span>     * &lt;code&gt;TYPE_CAT&lt;/code&gt;, &lt;code&gt;TYPE_SCHEM&lt;/code&gt;  and
<span class="nocode"><a name="5322">5322: </a></span>     * &lt;code&gt;TYPE_NAME&lt;/code&gt;.  The type name parameter may be a fully-qualified
<span class="nocode"><a name="5323">5323: </a></span>     * name.  In this case, the catalog and schemaPattern parameters are
<span class="nocode"><a name="5324">5324: </a></span>     * ignored.
<span class="nocode"><a name="5325">5325: </a></span>     *
<span class="nocode"><a name="5326">5326: </a></span>     * &lt;P&gt;Each type description has the following columns:
<span class="nocode"><a name="5327">5327: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5328">5328: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String =&gt; the type's catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5329">5329: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String =&gt; type's schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5330">5330: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; type name
<span class="nocode"><a name="5331">5331: </a></span>     *  &lt;LI&gt;&lt;B&gt;CLASS_NAME&lt;/B&gt; String =&gt; Java class name
<span class="nocode"><a name="5332">5332: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&gt; type value defined in java.sql.Types.
<span class="nocode"><a name="5333">5333: </a></span>     *     One of JAVA_OBJECT, STRUCT, or DISTINCT
<span class="nocode"><a name="5334">5334: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; explanatory comment on the type
<span class="nocode"><a name="5335">5335: </a></span>     *  &lt;LI&gt;&lt;B&gt;BASE_TYPE&lt;/B&gt; short =&gt; type code of the source type of a
<span class="nocode"><a name="5336">5336: </a></span>     *     DISTINCT type or the type that implements the user-generated
<span class="nocode"><a name="5337">5337: </a></span>     *     reference type of the SELF_REFERENCING_COLUMN of a structured
<span class="nocode"><a name="5338">5338: </a></span>     *     type as defined in java.sql.Types (&lt;code&gt;null&lt;/code&gt; if DATA_TYPE is not
<span class="nocode"><a name="5339">5339: </a></span>     *     DISTINCT or not STRUCT with REFERENCE_GENERATION = USER_DEFINED)
<span class="nocode"><a name="5340">5340: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5341">5341: </a></span>     *
<span class="nocode"><a name="5342">5342: </a></span>     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support UDTs, an empty
<span class="nocode"><a name="5343">5343: </a></span>     * result set is returned.
<span class="nocode"><a name="5344">5344: </a></span>     *
<span class="nocode"><a name="5345">5345: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="5346">5346: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="5347">5347: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="5348">5348: </a></span>     *        the search
<span class="nocode"><a name="5349">5349: </a></span>     * @param schemaPattern a schema pattern name; must match the schema name
<span class="nocode"><a name="5350">5350: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="5351">5351: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="5352">5352: </a></span>     *        the search
<span class="nocode"><a name="5353">5353: </a></span>     * @param typeNamePattern a type name pattern; must match the type name
<span class="nocode"><a name="5354">5354: </a></span>     *        as it is stored in the database; may be a fully qualified name
<span class="nocode"><a name="5355">5355: </a></span>     * @param types a list of user-defined types (JAVA_OBJECT,
<span class="nocode"><a name="5356">5356: </a></span>     *        STRUCT, or DISTINCT) to include; &lt;code&gt;null&lt;/code&gt; returns all types
<span class="nocode"><a name="5357">5357: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; object in which each row describes a UDT
<span class="nocode"><a name="5358">5358: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5359">5359: </a></span>     * @see #getSearchStringEscape
<span class="nocode"><a name="5360">5360: </a></span>     * @since 1.2
<span class="nocode"><a name="5361">5361: </a></span>     */
<span class="nocode"><a name="5362">5362: </a></span>    public ResultSet getUDTs(String catalog, String schemaPattern,
<span class="nocode"><a name="5363">5363: </a></span>              String typeNamePattern, int[] types) throws SQLException {
<span class="nocode"><a name="5364">5364: </a></span><span style="background-color: #ffffcc">        XSQLVAR[] xsqlvars = new XSQLVAR[7];</span>
<span class="nocode"><a name="5365">5365: </a></span>
<span class="nocode"><a name="5366">5366: </a></span><span style="background-color: #ffffcc">        xsqlvars[0] = new XSQLVAR();</span>
<span class="nocode"><a name="5367">5367: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="5368">5368: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqllen = 31;</span>
<span class="nocode"><a name="5369">5369: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].sqlname = &quot;TYPE_CAT&quot;;</span>
<span class="nocode"><a name="5370">5370: </a></span><span style="background-color: #ffffcc">        xsqlvars[0].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5371">5371: </a></span>
<span class="nocode"><a name="5372">5372: </a></span><span style="background-color: #ffffcc">        xsqlvars[1] = new XSQLVAR();</span>
<span class="nocode"><a name="5373">5373: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="5374">5374: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqllen = 31;</span>
<span class="nocode"><a name="5375">5375: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].sqlname = &quot;TYPE_SCHEM&quot;;</span>
<span class="nocode"><a name="5376">5376: </a></span><span style="background-color: #ffffcc">        xsqlvars[1].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5377">5377: </a></span>
<span class="nocode"><a name="5378">5378: </a></span><span style="background-color: #ffffcc">        xsqlvars[2] = new XSQLVAR();</span>
<span class="nocode"><a name="5379">5379: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="5380">5380: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqllen = 31;</span>
<span class="nocode"><a name="5381">5381: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].sqlname = &quot;TYPE_NAME&quot;;</span>
<span class="nocode"><a name="5382">5382: </a></span><span style="background-color: #ffffcc">        xsqlvars[2].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5383">5383: </a></span>
<span class="nocode"><a name="5384">5384: </a></span><span style="background-color: #ffffcc">        xsqlvars[3] = new XSQLVAR();</span>
<span class="nocode"><a name="5385">5385: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="5386">5386: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqllen = 31;</span>
<span class="nocode"><a name="5387">5387: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].sqlname = &quot;CLASS_NAME&quot;;</span>
<span class="nocode"><a name="5388">5388: </a></span><span style="background-color: #ffffcc">        xsqlvars[3].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5389">5389: </a></span>
<span class="nocode"><a name="5390">5390: </a></span><span style="background-color: #ffffcc">        xsqlvars[4] = new XSQLVAR();</span>
<span class="nocode"><a name="5391">5391: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqltype = ISCConstants.SQL_LONG;</span>
<span class="nocode"><a name="5392">5392: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].sqlname = &quot;DATA_TYPE&quot;;</span>
<span class="nocode"><a name="5393">5393: </a></span><span style="background-color: #ffffcc">        xsqlvars[4].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5394">5394: </a></span>
<span class="nocode"><a name="5395">5395: </a></span><span style="background-color: #ffffcc">        xsqlvars[5] = new XSQLVAR();</span>
<span class="nocode"><a name="5396">5396: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;</span>
<span class="nocode"><a name="5397">5397: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqllen = 31;</span>
<span class="nocode"><a name="5398">5398: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].sqlname = &quot;REMARKS&quot;;</span>
<span class="nocode"><a name="5399">5399: </a></span><span style="background-color: #ffffcc">        xsqlvars[5].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5400">5400: </a></span>        
<span class="nocode"><a name="5401">5401: </a></span><span style="background-color: #ffffcc">        xsqlvars[6] = new XSQLVAR();</span>
<span class="nocode"><a name="5402">5402: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqltype = ISCConstants.SQL_SHORT;</span>
<span class="nocode"><a name="5403">5403: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].sqlname = &quot;BASE_TYPE&quot;;</span>
<span class="nocode"><a name="5404">5404: </a></span><span style="background-color: #ffffcc">        xsqlvars[6].relname = &quot;UDT&quot;;</span>
<span class="nocode"><a name="5405">5405: </a></span>
<span class="nocode"><a name="5406">5406: </a></span><span style="background-color: #ffffcc">        List&lt;byte[][]&gt; rows = new ArrayList&lt;byte[][]&gt;(0);</span>
<span class="nocode"><a name="5407">5407: </a></span>
<span class="nocode"><a name="5408">5408: </a></span><span style="background-color: #ffffcc">        return new FBResultSet(xsqlvars, rows);</span>
<span class="nocode"><a name="5409">5409: </a></span>    }
<span class="nocode"><a name="5410">5410: </a></span>
<span class="nocode"><a name="5411">5411: </a></span>
<span class="nocode"><a name="5412">5412: </a></span>
<span class="nocode"><a name="5413">5413: </a></span>    /**
<span class="nocode"><a name="5414">5414: </a></span>     * Retrieves the connection that produced this metadata object.
<span class="nocode"><a name="5415">5415: </a></span>     *
<span class="nocode"><a name="5416">5416: </a></span>     * @return the connection that produced this metadata object
<span class="nocode"><a name="5417">5417: </a></span>     * @since 1.2
<span class="nocode"><a name="5418">5418: </a></span>     * @see &lt;a href=&quot;package-summary.html#2.0 API&quot;&gt;What Is in the JDBC 2.0 API&lt;/a&gt;
<span class="nocode"><a name="5419">5419: </a></span>     */
<span class="nocode"><a name="5420">5420: </a></span>    public Connection getConnection() throws SQLException {
<span class="nocode"><a name="5421">5421: </a></span>        return connection;
<span class="nocode"><a name="5422">5422: </a></span>    }
<span class="nocode"><a name="5423">5423: </a></span>
<span class="nocode"><a name="5424">5424: </a></span>    //jdbc 3 methods
<span class="nocode"><a name="5425">5425: </a></span>
<span class="nocode"><a name="5426">5426: </a></span>
<span class="nocode"><a name="5427">5427: </a></span>    /**
<span class="nocode"><a name="5428">5428: </a></span>     * &lt;b&gt;This operation is not supported&lt;/b&gt;
<span class="nocode"><a name="5429">5429: </a></span>     *
<span class="nocode"><a name="5430">5430: </a></span>     * @param param1 &lt;description&gt;
<span class="nocode"><a name="5431">5431: </a></span>     * @param param2 &lt;description&gt;
<span class="nocode"><a name="5432">5432: </a></span>     * @param param3 &lt;description&gt;
<span class="nocode"><a name="5433">5433: </a></span>     * @param param4 &lt;description&gt;
<span class="nocode"><a name="5434">5434: </a></span>     * @return &lt;description&gt;
<span class="nocode"><a name="5435">5435: </a></span>     * @exception java.sql.SQLException &lt;description&gt;
<span class="nocode"><a name="5436">5436: </a></span>     */
<span class="nocode"><a name="5437">5437: </a></span>    public ResultSet getAttributes(String param1, String param2, String param3, String param4) throws SQLException {
<span class="nocode"><a name="5438">5438: </a></span>        throw new FBDriverNotCapableException();
<span class="nocode"><a name="5439">5439: </a></span>    }
<span class="nocode"><a name="5440">5440: </a></span>
<span class="nocode"><a name="5441">5441: </a></span>    /**
<span class="nocode"><a name="5442">5442: </a></span>     * Retrieves whether this database supports savepoints.
<span class="nocode"><a name="5443">5443: </a></span>     *
<span class="nocode"><a name="5444">5444: </a></span>     * @return true if savepoints are supported; false otherwise 
<span class="nocode"><a name="5445">5445: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5446">5446: </a></span>     */
<span class="nocode"><a name="5447">5447: </a></span>    public boolean supportsSavepoints() throws SQLException {
<span class="nocode"><a name="5448">5448: </a></span>        return gdsHelper.compareToVersion(1, 5) &gt;= 0;
<span class="nocode"><a name="5449">5449: </a></span>    }
<span class="nocode"><a name="5450">5450: </a></span>
<span class="nocode"><a name="5451">5451: </a></span>    /**
<span class="nocode"><a name="5452">5452: </a></span>     * Retrieve whether this database supports named parameters.
<span class="nocode"><a name="5453">5453: </a></span>     *
<span class="nocode"><a name="5454">5454: </a></span>     * @return true if named parameters are supported, false otherwise 
<span class="nocode"><a name="5455">5455: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5456">5456: </a></span>     */
<span class="nocode"><a name="5457">5457: </a></span>    public boolean supportsNamedParameters() throws SQLException {
<span class="nocode"><a name="5458">5458: </a></span>        return false;
<span class="nocode"><a name="5459">5459: </a></span>    }
<span class="nocode"><a name="5460">5460: </a></span>
<span class="nocode"><a name="5461">5461: </a></span>    /**
<span class="nocode"><a name="5462">5462: </a></span>     * Retrieves whether it is possible to have multiple &lt;code&gt;ResultSet&lt;/code&gt;
<span class="nocode"><a name="5463">5463: </a></span>     * objects returned from a &lt;code&gt;CallableStatement&lt;/code&gt; object 
<span class="nocode"><a name="5464">5464: </a></span>     * simultaneously.
<span class="nocode"><a name="5465">5465: </a></span>     *
<span class="nocode"><a name="5466">5466: </a></span>     * @return true if multiple open ResultSets are supported, false otherwise
<span class="nocode"><a name="5467">5467: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5468">5468: </a></span>     */
<span class="nocode"><a name="5469">5469: </a></span>    public boolean supportsMultipleOpenResults() throws SQLException {
<span class="nocode"><a name="5470">5470: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="5471">5471: </a></span>    }
<span class="nocode"><a name="5472">5472: </a></span>
<span class="nocode"><a name="5473">5473: </a></span>    /**
<span class="nocode"><a name="5474">5474: </a></span>     * Retrieves whether auto-generated keys can be retrieved after creation.
<span class="nocode"><a name="5475">5475: </a></span>     *
<span class="nocode"><a name="5476">5476: </a></span>     * @return true if auto-generated keys can be retrieved, false otherwise
<span class="nocode"><a name="5477">5477: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5478">5478: </a></span>     */
<span class="nocode"><a name="5479">5479: </a></span>    public boolean supportsGetGeneratedKeys() throws SQLException {
<span class="nocode"><a name="5480">5480: </a></span>        return true;
<span class="nocode"><a name="5481">5481: </a></span>    }
<span class="nocode"><a name="5482">5482: </a></span>
<span class="nocode"><a name="5483">5483: </a></span>    /**
<span class="nocode"><a name="5484">5484: </a></span>     *
<span class="nocode"><a name="5485">5485: </a></span>     * Retrieves a description of the user-defined type (UDT) hierarchies 
<span class="nocode"><a name="5486">5486: </a></span>     * defined in a particular schema in this database. Only the immediate 
<span class="nocode"><a name="5487">5487: </a></span>     * super type/sub type relationship is modeled.
<span class="nocode"><a name="5488">5488: </a></span>     * &lt;P&gt;
<span class="nocode"><a name="5489">5489: </a></span>     * Only supertype information for UDTs matching the catalog, 
<span class="nocode"><a name="5490">5490: </a></span>     * schema, and type name is returned. The type name parameter
<span class="nocode"><a name="5491">5491: </a></span>     * may be a fully-qualified name. When the UDT name supplied is a 
<span class="nocode"><a name="5492">5492: </a></span>     * fully-qualified name, the catalog and schemaPattern parameters are 
<span class="nocode"><a name="5493">5493: </a></span>     * ignored. 
<span class="nocode"><a name="5494">5494: </a></span>     * &lt;P&gt;
<span class="nocode"><a name="5495">5495: </a></span>     * If a UDT does not have a direct super type, it is not listed here.
<span class="nocode"><a name="5496">5496: </a></span>     * A row of the &lt;code&gt;ResultSet&lt;/code&gt; object returned by this method
<span class="nocode"><a name="5497">5497: </a></span>     * describes the designated UDT and a direct supertype. A row has the 
<span class="nocode"><a name="5498">5498: </a></span>     * following columns:
<span class="nocode"><a name="5499">5499: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5500">5500: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_CAT&lt;/B&gt; String =&gt; the UDT's catalog (may be 
<span class="nocode"><a name="5501">5501: </a></span>     *  &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5502">5502: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_SCHEM&lt;/B&gt; String =&gt; UDT's schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5503">5503: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; type name of the UDT
<span class="nocode"><a name="5504">5504: </a></span>     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_CAT&lt;/B&gt; String =&gt; the direct super type's catalog 
<span class="nocode"><a name="5505">5505: </a></span>     *                           (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5506">5506: </a></span>     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_SCHEM&lt;/B&gt; String =&gt; the direct super type's schema 
<span class="nocode"><a name="5507">5507: </a></span>     *                             (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5508">5508: </a></span>     *  &lt;LI&gt;&lt;B&gt;SUPERTYPE_NAME&lt;/B&gt; String =&gt; the direct super type's name
<span class="nocode"><a name="5509">5509: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5510">5510: </a></span>     *
<span class="nocode"><a name="5511">5511: </a></span>     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support type hierarchies, an 
<span class="nocode"><a name="5512">5512: </a></span>     * empty result set is returned.
<span class="nocode"><a name="5513">5513: </a></span>     *
<span class="nocode"><a name="5514">5514: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="5515">5515: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection 
<span class="nocode"><a name="5516">5516: </a></span>     *        criteria
<span class="nocode"><a name="5517">5517: </a></span>     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those 
<span class="nocode"><a name="5518">5518: </a></span>     *        without a schema
<span class="nocode"><a name="5519">5519: </a></span>     * @param tableNamePattern a UDT name pattern; may be a fully-qualified
<span class="nocode"><a name="5520">5520: </a></span>     *        name
<span class="nocode"><a name="5521">5521: </a></span>     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which a row gives information
<span class="nocode"><a name="5522">5522: </a></span>     *         about the designated UDT
<span class="nocode"><a name="5523">5523: </a></span>     * @throws SQLException if a database access error occurs
<span class="nocode"><a name="5524">5524: </a></span>     */
<span class="nocode"><a name="5525">5525: </a></span>    public ResultSet getSuperTypes(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {
<span class="nocode"><a name="5526">5526: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[6];
<span class="nocode"><a name="5527">5527: </a></span>
<span class="nocode"><a name="5528">5528: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="5529">5529: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5530">5530: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="5531">5531: </a></span>        xsqlvars[0].sqlname = &quot;TYPE_CAT&quot;;
<span class="nocode"><a name="5532">5532: </a></span>        xsqlvars[0].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5533">5533: </a></span>
<span class="nocode"><a name="5534">5534: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="5535">5535: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5536">5536: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="5537">5537: </a></span>        xsqlvars[1].sqlname = &quot;TYPE_SCHEM&quot;;
<span class="nocode"><a name="5538">5538: </a></span>        xsqlvars[1].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5539">5539: </a></span>
<span class="nocode"><a name="5540">5540: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="5541">5541: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5542">5542: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="5543">5543: </a></span>        xsqlvars[2].sqlname = &quot;TYPE_NAME&quot;;
<span class="nocode"><a name="5544">5544: </a></span>        xsqlvars[2].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5545">5545: </a></span>
<span class="nocode"><a name="5546">5546: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5547">5547: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="5548">5548: </a></span>        xsqlvars[3].sqlname = &quot;SUPERTYPE_CAT&quot;;
<span class="nocode"><a name="5549">5549: </a></span>        xsqlvars[3].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5550">5550: </a></span>
<span class="nocode"><a name="5551">5551: </a></span>        xsqlvars[4] = new XSQLVAR();
<span class="nocode"><a name="5552">5552: </a></span>        xsqlvars[4].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5553">5553: </a></span>        xsqlvars[4].sqllen = 31;
<span class="nocode"><a name="5554">5554: </a></span>        xsqlvars[4].sqlname = &quot;SUPERTYPE_SCHEM&quot;;
<span class="nocode"><a name="5555">5555: </a></span>        xsqlvars[4].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5556">5556: </a></span>
<span class="nocode"><a name="5557">5557: </a></span>        xsqlvars[5] = new XSQLVAR();
<span class="nocode"><a name="5558">5558: </a></span>        xsqlvars[5].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5559">5559: </a></span>        xsqlvars[5].sqllen = 31;
<span class="nocode"><a name="5560">5560: </a></span>        xsqlvars[5].sqlname = &quot;SUPERTYPE_NAME&quot;;
<span class="nocode"><a name="5561">5561: </a></span>        xsqlvars[5].relname = &quot;SUPERTYPES&quot;;
<span class="nocode"><a name="5562">5562: </a></span>
<span class="nocode"><a name="5563">5563: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="5564">5564: </a></span>
<span class="nocode"><a name="5565">5565: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5566">5566: </a></span>    }
<span class="nocode"><a name="5567">5567: </a></span>
<span class="nocode"><a name="5568">5568: </a></span>    /**
<span class="nocode"><a name="5569">5569: </a></span>     * Retrieves a description of the table hierarchies defined in a particular 
<span class="nocode"><a name="5570">5570: </a></span>     * schema in this database.
<span class="nocode"><a name="5571">5571: </a></span>     *
<span class="nocode"><a name="5572">5572: </a></span>     * &lt;P&gt;Only supertable information for tables matching the catalog, schema
<span class="nocode"><a name="5573">5573: </a></span>     * and table name are returned. The table name parameter may be a fully-
<span class="nocode"><a name="5574">5574: </a></span>     * qualified name, in which case, the catalog and schemaPattern parameters
<span class="nocode"><a name="5575">5575: </a></span>     * are ignored. If a table does not have a super table, it is not listed 
<span class="nocode"><a name="5576">5576: </a></span>     * here. Supertables have to be defined in the same catalog and schema as 
<span class="nocode"><a name="5577">5577: </a></span>     * the sub tables. Therefore, the type description does not need to include
<span class="nocode"><a name="5578">5578: </a></span>     * this information for the supertable.
<span class="nocode"><a name="5579">5579: </a></span>     *
<span class="nocode"><a name="5580">5580: </a></span>     * &lt;P&gt;Each type description has the following columns:
<span class="nocode"><a name="5581">5581: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5582">5582: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CAT&lt;/B&gt; String =&gt; the type's catalog (may be 
<span class="nocode"><a name="5583">5583: </a></span>     *  &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5584">5584: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; type's schema (may be 
<span class="nocode"><a name="5585">5585: </a></span>     *  &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5586">5586: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_NAME&lt;/B&gt; String =&gt; type name
<span class="nocode"><a name="5587">5587: </a></span>     *  &lt;LI&gt;&lt;B&gt;SUPERTABLE_NAME&lt;/B&gt; String =&gt; the direct super type's name
<span class="nocode"><a name="5588">5588: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5589">5589: </a></span>     *
<span class="nocode"><a name="5590">5590: </a></span>     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If the driver does not support type hierarchies, an 
<span class="nocode"><a name="5591">5591: </a></span>     * empty result set is returned.
<span class="nocode"><a name="5592">5592: </a></span>     *
<span class="nocode"><a name="5593">5593: </a></span>     * @param catalog a catalog name; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="5594">5594: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means drop catalog name from the selection 
<span class="nocode"><a name="5595">5595: </a></span>     *        criteria
<span class="nocode"><a name="5596">5596: </a></span>     * @param schemaPattern a schema name pattern; &quot;&quot; retrieves those 
<span class="nocode"><a name="5597">5597: </a></span>     *        without a schema
<span class="nocode"><a name="5598">5598: </a></span>     * @param tableNamePattern a table name pattern; may be a fully-qualified
<span class="nocode"><a name="5599">5599: </a></span>     *        name
<span class="nocode"><a name="5600">5600: </a></span>     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a type 
<span class="nocode"><a name="5601">5601: </a></span>     *         description
<span class="nocode"><a name="5602">5602: </a></span>     * @throws SQLException if a database access error occurs
<span class="nocode"><a name="5603">5603: </a></span>     */
<span class="nocode"><a name="5604">5604: </a></span>    public ResultSet getSuperTables(String catalog, String schemaPattern, String tableNamePattern) throws SQLException {
<span class="nocode"><a name="5605">5605: </a></span>        
<span class="nocode"><a name="5606">5606: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[4];
<span class="nocode"><a name="5607">5607: </a></span>
<span class="nocode"><a name="5608">5608: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="5609">5609: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5610">5610: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="5611">5611: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_CAT&quot;;
<span class="nocode"><a name="5612">5612: </a></span>        xsqlvars[0].relname = &quot;SUPERTABLES&quot;;
<span class="nocode"><a name="5613">5613: </a></span>
<span class="nocode"><a name="5614">5614: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="5615">5615: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5616">5616: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="5617">5617: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="5618">5618: </a></span>        xsqlvars[1].relname = &quot;SUPERTABLES&quot;;
<span class="nocode"><a name="5619">5619: </a></span>
<span class="nocode"><a name="5620">5620: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="5621">5621: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5622">5622: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="5623">5623: </a></span>        xsqlvars[2].sqlname = &quot;TABLE_NAME&quot;;
<span class="nocode"><a name="5624">5624: </a></span>        xsqlvars[2].relname = &quot;SUPERTABLES&quot;;
<span class="nocode"><a name="5625">5625: </a></span>
<span class="nocode"><a name="5626">5626: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="5627">5627: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5628">5628: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="5629">5629: </a></span>        xsqlvars[3].sqlname = &quot;SUPERTABLE_NAME&quot;;
<span class="nocode"><a name="5630">5630: </a></span>        xsqlvars[3].relname = &quot;SUPERTABLES&quot;;
<span class="nocode"><a name="5631">5631: </a></span>
<span class="nocode"><a name="5632">5632: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="5633">5633: </a></span>
<span class="nocode"><a name="5634">5634: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5635">5635: </a></span>    }
<span class="nocode"><a name="5636">5636: </a></span>
<span class="nocode"><a name="5637">5637: </a></span>    /**
<span class="nocode"><a name="5638">5638: </a></span>     * Retrieves whether this database supports the given results holdability.
<span class="nocode"><a name="5639">5639: </a></span>     *
<span class="nocode"><a name="5640">5640: </a></span>     * @param holdability one of the following constants: 
<span class="nocode"><a name="5641">5641: </a></span>     * &lt;code&gt;ResultSet.HOLD_CURSORS_OVER_COMMIT&lt;/code&gt; or 
<span class="nocode"><a name="5642">5642: </a></span>     * &lt;code&gt;ResultSet.CLOSE_CURSORS_AT_COMMIT&lt;/code&gt;
<span class="nocode"><a name="5643">5643: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if the holdability is supported, 
<span class="nocode"><a name="5644">5644: </a></span>     *         &lt;code&gt;false&lt;/code&gt; otherwise 
<span class="nocode"><a name="5645">5645: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5646">5646: </a></span>     */
<span class="nocode"><a name="5647">5647: </a></span>    public boolean supportsResultSetHoldability(int holdability) throws SQLException {
<span class="nocode"><a name="5648">5648: </a></span>        return holdability == ResultSet.CLOSE_CURSORS_AT_COMMIT ||
<span class="nocode"><a name="5649">5649: </a></span>            holdability == ResultSet.HOLD_CURSORS_OVER_COMMIT;
<span class="nocode"><a name="5650">5650: </a></span>    }
<span class="nocode"><a name="5651">5651: </a></span>
<span class="nocode"><a name="5652">5652: </a></span>    /**
<span class="nocode"><a name="5653">5653: </a></span>     * Retrieves the default holdability of this &lt;code&gt;ResultSet&lt;/code&gt;.
<span class="nocode"><a name="5654">5654: </a></span>     *
<span class="nocode"><a name="5655">5655: </a></span>     * @return the default holdability
<span class="nocode"><a name="5656">5656: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5657">5657: </a></span>     */
<span class="nocode"><a name="5658">5658: </a></span>    public int getResultSetHoldability() throws SQLException {
<span class="nocode"><a name="5659">5659: </a></span>        return ResultSet.CLOSE_CURSORS_AT_COMMIT; 
<span class="nocode"><a name="5660">5660: </a></span>    }
<span class="nocode"><a name="5661">5661: </a></span>
<span class="nocode"><a name="5662">5662: </a></span>    /**
<span class="nocode"><a name="5663">5663: </a></span>     * Get the major version number of the database.
<span class="nocode"><a name="5664">5664: </a></span>     *
<span class="nocode"><a name="5665">5665: </a></span>     * @return The major version number 
<span class="nocode"><a name="5666">5666: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5667">5667: </a></span>     */
<span class="nocode"><a name="5668">5668: </a></span>    public int getDatabaseMajorVersion() throws SQLException {
<span class="nocode"><a name="5669">5669: </a></span>        return gdsHelper.getDatabaseProductMajorVersion();
<span class="nocode"><a name="5670">5670: </a></span>    }
<span class="nocode"><a name="5671">5671: </a></span>
<span class="nocode"><a name="5672">5672: </a></span>    /**
<span class="nocode"><a name="5673">5673: </a></span>     * Get the minor version number of the database.
<span class="nocode"><a name="5674">5674: </a></span>     * @return The minor version number 
<span class="nocode"><a name="5675">5675: </a></span>     * @exception SQLException if a database access error occurs 
<span class="nocode"><a name="5676">5676: </a></span>     */
<span class="nocode"><a name="5677">5677: </a></span>    public int getDatabaseMinorVersion() throws SQLException {
<span class="nocode"><a name="5678">5678: </a></span>        return gdsHelper.getDatabaseProductMinorVersion();
<span class="nocode"><a name="5679">5679: </a></span>    }
<span class="nocode"><a name="5680">5680: </a></span>    
<span class="nocode"><a name="5681">5681: </a></span>    /**
<span class="nocode"><a name="5682">5682: </a></span>     * Get the major version of the ODS (On-Disk Structure) of the database.
<span class="nocode"><a name="5683">5683: </a></span>     * @return The major version number
<span class="nocode"><a name="5684">5684: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5685">5685: </a></span>     */
<span class="nocode"><a name="5686">5686: </a></span>    public int getOdsMajorVersion() throws SQLException {
<span class="nocode"><a name="5687">5687: </a></span>    	return gdsHelper.getIscDBHandle().getODSMajorVersion();
<span class="nocode"><a name="5688">5688: </a></span>    }
<span class="nocode"><a name="5689">5689: </a></span>    
<span class="nocode"><a name="5690">5690: </a></span>    /**
<span class="nocode"><a name="5691">5691: </a></span>     * Get the minor version of the ODS (On-Disk Structure) of the database.
<span class="nocode"><a name="5692">5692: </a></span>     * @return The minor version number
<span class="nocode"><a name="5693">5693: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5694">5694: </a></span>     */
<span class="nocode"><a name="5695">5695: </a></span>    public int getOdsMinorVersion() throws SQLException {
<span class="nocode"><a name="5696">5696: </a></span><span style="background-color: #ffffcc">    	return gdsHelper.getIscDBHandle().getODSMinorVersion();</span>
<span class="nocode"><a name="5697">5697: </a></span>    }
<span class="nocode"><a name="5698">5698: </a></span>
<span class="nocode"><a name="5699">5699: </a></span>    /**
<span class="nocode"><a name="5700">5700: </a></span>     * Indicates whether the SQLSTATEs returned by SQLException.getSQLState is 
<span class="nocode"><a name="5701">5701: </a></span>     * X/Open (now known as Open Group) SQL CLI or SQL99
<span class="nocode"><a name="5702">5702: </a></span>     *
<span class="nocode"><a name="5703">5703: </a></span>     * @return the type of SQLSTATEs
<span class="nocode"><a name="5704">5704: </a></span>     * @exception SQLException should never be thrown in this implementation 
<span class="nocode"><a name="5705">5705: </a></span>     */
<span class="nocode"><a name="5706">5706: </a></span>    public int getSQLStateType() throws SQLException {
<span class="nocode"><a name="5707">5707: </a></span><span style="background-color: #ffffcc">        return DatabaseMetaData.sqlStateSQL99;</span>
<span class="nocode"><a name="5708">5708: </a></span>    }
<span class="nocode"><a name="5709">5709: </a></span>
<span class="nocode"><a name="5710">5710: </a></span>    //-------------------------- JDBC 4.0 -------------------------------------
<span class="nocode"><a name="5711">5711: </a></span>    
<span class="nocode"><a name="5712">5712: </a></span>    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException {
<span class="nocode"><a name="5713">5713: </a></span>        return false;
<span class="nocode"><a name="5714">5714: </a></span>    }
<span class="nocode"><a name="5715">5715: </a></span>    
<span class="nocode"><a name="5716">5716: </a></span>    public boolean autoCommitFailureClosesAllResultSets() throws SQLException {
<span class="nocode"><a name="5717">5717: </a></span>        // the holdable result sets remain open, others are closed, but this
<span class="nocode"><a name="5718">5718: </a></span>        // happens before the statement is executed
<span class="nocode"><a name="5719">5719: </a></span>        return false;
<span class="nocode"><a name="5720">5720: </a></span>    }
<span class="nocode"><a name="5721">5721: </a></span>
<span class="nocode"><a name="5722">5722: </a></span>    /**
<span class="nocode"><a name="5723">5723: </a></span>     * Retrieves a list of the client info properties 
<span class="nocode"><a name="5724">5724: </a></span>     * that the driver supports.  The result set contains the following columns
<span class="nocode"><a name="5725">5725: </a></span>     * &lt;p&gt;
<span class="nocode"><a name="5726">5726: </a></span>         * &lt;ol&gt;
<span class="nocode"><a name="5727">5727: </a></span>     * &lt;li&gt;&lt;b&gt;NAME&lt;/b&gt; String=&gt; The name of the client info property&lt;br&gt;
<span class="nocode"><a name="5728">5728: </a></span>     * &lt;li&gt;&lt;b&gt;MAX_LEN&lt;/b&gt; int=&gt; The maximum length of the value for the property&lt;br&gt;
<span class="nocode"><a name="5729">5729: </a></span>     * &lt;li&gt;&lt;b&gt;DEFAULT_VALUE&lt;/b&gt; String=&gt; The default value of the property&lt;br&gt;
<span class="nocode"><a name="5730">5730: </a></span>     * &lt;li&gt;&lt;b&gt;DESCRIPTION&lt;/b&gt; String=&gt; A description of the property.  This will typically 
<span class="nocode"><a name="5731">5731: </a></span>     *                      contain information as to where this property is 
<span class="nocode"><a name="5732">5732: </a></span>     *                      stored in the database.
<span class="nocode"><a name="5733">5733: </a></span>     * &lt;/ol&gt;
<span class="nocode"><a name="5734">5734: </a></span>         * &lt;p&gt;
<span class="nocode"><a name="5735">5735: </a></span>     * The &lt;code&gt;ResultSet&lt;/code&gt; is sorted by the NAME column
<span class="nocode"><a name="5736">5736: </a></span>     * &lt;p&gt;
<span class="nocode"><a name="5737">5737: </a></span>     * @return  A &lt;code&gt;ResultSet&lt;/code&gt; object; each row is a supported client info
<span class="nocode"><a name="5738">5738: </a></span>         * property
<span class="nocode"><a name="5739">5739: </a></span>     * &lt;p&gt;
<span class="nocode"><a name="5740">5740: </a></span>     *  @exception SQLException if a database access error occurs
<span class="nocode"><a name="5741">5741: </a></span>     * &lt;p&gt;
<span class="nocode"><a name="5742">5742: </a></span>     * @since 1.6
<span class="nocode"><a name="5743">5743: </a></span>     */
<span class="nocode"><a name="5744">5744: </a></span>    public ResultSet getClientInfoProperties() throws SQLException {
<span class="nocode"><a name="5745">5745: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[4];
<span class="nocode"><a name="5746">5746: </a></span>
<span class="nocode"><a name="5747">5747: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="5748">5748: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5749">5749: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="5750">5750: </a></span>        xsqlvars[0].sqlname = &quot;NAME&quot;;
<span class="nocode"><a name="5751">5751: </a></span>        xsqlvars[0].relname = &quot;UDT&quot;;
<span class="nocode"><a name="5752">5752: </a></span>
<span class="nocode"><a name="5753">5753: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="5754">5754: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_LONG;
<span class="nocode"><a name="5755">5755: </a></span>        xsqlvars[1].sqllen = 4;
<span class="nocode"><a name="5756">5756: </a></span>        xsqlvars[1].sqlname = &quot;MAX_LEN&quot;;
<span class="nocode"><a name="5757">5757: </a></span>        xsqlvars[1].relname = &quot;UDT&quot;;
<span class="nocode"><a name="5758">5758: </a></span>
<span class="nocode"><a name="5759">5759: </a></span>        xsqlvars[2] = new XSQLVAR();
<span class="nocode"><a name="5760">5760: </a></span>        xsqlvars[2].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5761">5761: </a></span>        xsqlvars[2].sqllen = 31;
<span class="nocode"><a name="5762">5762: </a></span>        xsqlvars[2].sqlname = &quot;DEFAULT&quot;;
<span class="nocode"><a name="5763">5763: </a></span>        xsqlvars[2].relname = &quot;UDT&quot;;
<span class="nocode"><a name="5764">5764: </a></span>
<span class="nocode"><a name="5765">5765: </a></span>        xsqlvars[3] = new XSQLVAR();
<span class="nocode"><a name="5766">5766: </a></span>        xsqlvars[3].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5767">5767: </a></span>        xsqlvars[3].sqllen = 31;
<span class="nocode"><a name="5768">5768: </a></span>        xsqlvars[3].sqlname = &quot;DESCRIPTION&quot;;
<span class="nocode"><a name="5769">5769: </a></span>        xsqlvars[3].relname = &quot;UDT&quot;;
<span class="nocode"><a name="5770">5770: </a></span>
<span class="nocode"><a name="5771">5771: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="5772">5772: </a></span>
<span class="nocode"><a name="5773">5773: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5774">5774: </a></span>    }
<span class="nocode"><a name="5775">5775: </a></span>
<span class="nocode"><a name="5776">5776: </a></span>    /**
<span class="nocode"><a name="5777">5777: </a></span>     * Retrieves a description of the given catalog's system or user 
<span class="nocode"><a name="5778">5778: </a></span>     * function parameters and return type.
<span class="nocode"><a name="5779">5779: </a></span>     *
<span class="nocode"><a name="5780">5780: </a></span>     * &lt;P&gt;Only descriptions matching the schema,  function and
<span class="nocode"><a name="5781">5781: </a></span>     * parameter name criteria are returned. They are ordered by
<span class="nocode"><a name="5782">5782: </a></span>     * &lt;code&gt;FUNCTION_CAT&lt;/code&gt;, &lt;code&gt;FUNCTION_SCHEM&lt;/code&gt;,
<span class="nocode"><a name="5783">5783: </a></span>     * &lt;code&gt;FUNCTION_NAME&lt;/code&gt; and 
<span class="nocode"><a name="5784">5784: </a></span>     * &lt;code&gt;SPECIFIC_ NAME&lt;/code&gt;. Within this, the return value,
<span class="nocode"><a name="5785">5785: </a></span>     * if any, is first. Next are the parameter descriptions in call
<span class="nocode"><a name="5786">5786: </a></span>     * order. The column descriptions follow in column number order.
<span class="nocode"><a name="5787">5787: </a></span>     *
<span class="nocode"><a name="5788">5788: </a></span>     * &lt;P&gt;Each row in the &lt;code&gt;ResultSet&lt;/code&gt; 
<span class="nocode"><a name="5789">5789: </a></span>     * is a parameter description, column description or
<span class="nocode"><a name="5790">5790: </a></span>     * return type description with the following fields:
<span class="nocode"><a name="5791">5791: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5792">5792: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_CAT&lt;/B&gt; String =&gt; function catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5793">5793: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_SCHEM&lt;/B&gt; String =&gt; function schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5794">5794: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_NAME&lt;/B&gt; String =&gt; function name.  This is the name 
<span class="nocode"><a name="5795">5795: </a></span>     * used to invoke the function
<span class="nocode"><a name="5796">5796: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_NAME&lt;/B&gt; String =&gt; column/parameter name 
<span class="nocode"><a name="5797">5797: </a></span>     *  &lt;LI&gt;&lt;B&gt;COLUMN_TYPE&lt;/B&gt; Short =&gt; kind of column/parameter:
<span class="nocode"><a name="5798">5798: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="5799">5799: </a></span>     *      &lt;LI&gt; functionColumnUnknown - nobody knows
<span class="nocode"><a name="5800">5800: </a></span>     *      &lt;LI&gt; functionColumnIn - IN parameter
<span class="nocode"><a name="5801">5801: </a></span>     *      &lt;LI&gt; functionColumnInOut - INOUT parameter
<span class="nocode"><a name="5802">5802: </a></span>     *      &lt;LI&gt; functionColumnOut - OUT parameter
<span class="nocode"><a name="5803">5803: </a></span>     *      &lt;LI&gt; functionColumnReturn - function return value
<span class="nocode"><a name="5804">5804: </a></span>     *      &lt;LI&gt; functionColumnResult - Indicates that the parameter or column
<span class="nocode"><a name="5805">5805: </a></span>     *  is a column in the &lt;code&gt;ResultSet&lt;/code&gt;
<span class="nocode"><a name="5806">5806: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="5807">5807: </a></span>     *  &lt;LI&gt;&lt;B&gt;DATA_TYPE&lt;/B&gt; int =&gt; SQL type from java.sql.Types
<span class="nocode"><a name="5808">5808: </a></span>     *  &lt;LI&gt;&lt;B&gt;TYPE_NAME&lt;/B&gt; String =&gt; SQL type name, for a UDT type the
<span class="nocode"><a name="5809">5809: </a></span>     *  type name is fully qualified
<span class="nocode"><a name="5810">5810: </a></span>     *  &lt;LI&gt;&lt;B&gt;PRECISION&lt;/B&gt; int =&gt; precision
<span class="nocode"><a name="5811">5811: </a></span>     *  &lt;LI&gt;&lt;B&gt;LENGTH&lt;/B&gt; int =&gt; length in bytes of data
<span class="nocode"><a name="5812">5812: </a></span>     *  &lt;LI&gt;&lt;B&gt;SCALE&lt;/B&gt; short =&gt; scale -  null is returned for data types where  
<span class="nocode"><a name="5813">5813: </a></span>     * SCALE is not applicable.
<span class="nocode"><a name="5814">5814: </a></span>     *  &lt;LI&gt;&lt;B&gt;RADIX&lt;/B&gt; short =&gt; radix
<span class="nocode"><a name="5815">5815: </a></span>     *  &lt;LI&gt;&lt;B&gt;NULLABLE&lt;/B&gt; short =&gt; can it contain NULL.
<span class="nocode"><a name="5816">5816: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="5817">5817: </a></span>     *      &lt;LI&gt; functionNoNulls - does not allow NULL values
<span class="nocode"><a name="5818">5818: </a></span>     *      &lt;LI&gt; functionNullable - allows NULL values
<span class="nocode"><a name="5819">5819: </a></span>     *      &lt;LI&gt; functionNullableUnknown - nullability unknown
<span class="nocode"><a name="5820">5820: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="5821">5821: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; comment describing column/parameter
<span class="nocode"><a name="5822">5822: </a></span>     *  &lt;LI&gt;&lt;B&gt;CHAR_OCTET_LENGTH&lt;/B&gt; int  =&gt; the maximum length of binary 
<span class="nocode"><a name="5823">5823: </a></span>     * and character based parameters or columns.  For any other datatype the returned value 
<span class="nocode"><a name="5824">5824: </a></span>     * is a NULL
<span class="nocode"><a name="5825">5825: </a></span>     *  &lt;LI&gt;&lt;B&gt;ORDINAL_POSITION&lt;/B&gt; int  =&gt; the ordinal position, starting 
<span class="nocode"><a name="5826">5826: </a></span>     * from 1, for the input and output parameters. A value of 0
<span class="nocode"><a name="5827">5827: </a></span>     * is returned if this row describes the function's return value. 
<span class="nocode"><a name="5828">5828: </a></span>     * For result set columns, it is the
<span class="nocode"><a name="5829">5829: </a></span>     * ordinal position of the column in the result set starting from 1.  
<span class="nocode"><a name="5830">5830: </a></span>     *  &lt;LI&gt;&lt;B&gt;IS_NULLABLE&lt;/B&gt; String  =&gt; ISO rules are used to determine 
<span class="nocode"><a name="5831">5831: </a></span>     * the nullability for a parameter or column.
<span class="nocode"><a name="5832">5832: </a></span>     *       &lt;UL&gt;
<span class="nocode"><a name="5833">5833: </a></span>     *       &lt;LI&gt; YES           --- if the parameter or column can include NULLs
<span class="nocode"><a name="5834">5834: </a></span>     *       &lt;LI&gt; NO            --- if the parameter or column  cannot include NULLs
<span class="nocode"><a name="5835">5835: </a></span>     *       &lt;LI&gt; empty string  --- if the nullability for the 
<span class="nocode"><a name="5836">5836: </a></span>     * parameter  or column is unknown
<span class="nocode"><a name="5837">5837: </a></span>     *       &lt;/UL&gt;
<span class="nocode"><a name="5838">5838: </a></span>     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  =&gt; the name which uniquely identifies 
<span class="nocode"><a name="5839">5839: </a></span>     * this function within its schema.  This is a user specified, or DBMS
<span class="nocode"><a name="5840">5840: </a></span>     * generated, name that may be different then the &lt;code&gt;FUNCTION_NAME&lt;/code&gt; 
<span class="nocode"><a name="5841">5841: </a></span>     * for example with overload functions
<span class="nocode"><a name="5842">5842: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5843">5843: </a></span>     * 
<span class="nocode"><a name="5844">5844: </a></span>     * &lt;p&gt;The PRECISION column represents the specified column size for the given 
<span class="nocode"><a name="5845">5845: </a></span>     * parameter or column. 
<span class="nocode"><a name="5846">5846: </a></span>     * For numeric data, this is the maximum precision.  For character data, this is the length in characters. 
<span class="nocode"><a name="5847">5847: </a></span>     * For datetime datatypes, this is the length in characters of the String representation (assuming the 
<span class="nocode"><a name="5848">5848: </a></span>     * maximum allowed precision of the fractional seconds component). For binary data, this is the length in bytes.  For the ROWID datatype, 
<span class="nocode"><a name="5849">5849: </a></span>     * this is the length in bytes. Null is returned for data types where the
<span class="nocode"><a name="5850">5850: </a></span>     * column size is not applicable.
<span class="nocode"><a name="5851">5851: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="5852">5852: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="5853">5853: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="5854">5854: </a></span>     *        the search
<span class="nocode"><a name="5855">5855: </a></span>     * @param schemaPattern a schema name pattern; must match the schema name
<span class="nocode"><a name="5856">5856: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="5857">5857: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="5858">5858: </a></span>     *        the search
<span class="nocode"><a name="5859">5859: </a></span>     * @param functionNamePattern a procedure name pattern; must match the
<span class="nocode"><a name="5860">5860: </a></span>     *        function name as it is stored in the database 
<span class="nocode"><a name="5861">5861: </a></span>     * @param columnNamePattern a parameter name pattern; must match the 
<span class="nocode"><a name="5862">5862: </a></span>     * parameter or column name as it is stored in the database 
<span class="nocode"><a name="5863">5863: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row describes a 
<span class="nocode"><a name="5864">5864: </a></span>     * user function parameter, column  or return type
<span class="nocode"><a name="5865">5865: </a></span>     *
<span class="nocode"><a name="5866">5866: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5867">5867: </a></span>     * @see #getSearchStringEscape 
<span class="nocode"><a name="5868">5868: </a></span>     * @since 1.6
<span class="nocode"><a name="5869">5869: </a></span>     */
<span class="nocode"><a name="5870">5870: </a></span>    public ResultSet getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern, String columnNamePattern) throws SQLException {
<span class="nocode"><a name="5871">5871: </a></span>        // FIXME implement this method
<span class="nocode"><a name="5872">5872: </a></span>        throw new FBDriverNotCapableException();
<span class="nocode"><a name="5873">5873: </a></span>    }
<span class="nocode"><a name="5874">5874: </a></span>
<span class="nocode"><a name="5875">5875: </a></span>    /**
<span class="nocode"><a name="5876">5876: </a></span>     * Retrieves a description of the  system and user functions available 
<span class="nocode"><a name="5877">5877: </a></span>     * in the given catalog.
<span class="nocode"><a name="5878">5878: </a></span>     * &lt;P&gt;
<span class="nocode"><a name="5879">5879: </a></span>     * Only system and user function descriptions matching the schema and
<span class="nocode"><a name="5880">5880: </a></span>     * function name criteria are returned.  They are ordered by
<span class="nocode"><a name="5881">5881: </a></span>     * &lt;code&gt;FUNCTION_CAT&lt;/code&gt;, &lt;code&gt;FUNCTION_SCHEM&lt;/code&gt;,
<span class="nocode"><a name="5882">5882: </a></span>     * &lt;code&gt;FUNCTION_NAME&lt;/code&gt; and 
<span class="nocode"><a name="5883">5883: </a></span>     * &lt;code&gt;SPECIFIC_ NAME&lt;/code&gt;.
<span class="nocode"><a name="5884">5884: </a></span>     *
<span class="nocode"><a name="5885">5885: </a></span>     * &lt;P&gt;Each function description has the the following columns:
<span class="nocode"><a name="5886">5886: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5887">5887: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_CAT&lt;/B&gt; String =&gt; function catalog (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5888">5888: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_SCHEM&lt;/B&gt; String =&gt; function schema (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5889">5889: </a></span>     *  &lt;LI&gt;&lt;B&gt;FUNCTION_NAME&lt;/B&gt; String =&gt; function name.  This is the name 
<span class="nocode"><a name="5890">5890: </a></span>     * used to invoke the function
<span class="nocode"><a name="5891">5891: </a></span>     *  &lt;LI&gt;&lt;B&gt;REMARKS&lt;/B&gt; String =&gt; explanatory comment on the function
<span class="nocode"><a name="5892">5892: </a></span>     * &lt;LI&gt;&lt;B&gt;FUNCTION_TYPE&lt;/B&gt; short =&gt; kind of function:
<span class="nocode"><a name="5893">5893: </a></span>     *      &lt;UL&gt;
<span class="nocode"><a name="5894">5894: </a></span>     *      &lt;LI&gt;functionResultUnknown - Cannot determine if a return value
<span class="nocode"><a name="5895">5895: </a></span>     *       or table will be returned
<span class="nocode"><a name="5896">5896: </a></span>     *      &lt;LI&gt; functionNoTable- Does not return a table
<span class="nocode"><a name="5897">5897: </a></span>     *      &lt;LI&gt; functionReturnsTable - Returns a table
<span class="nocode"><a name="5898">5898: </a></span>     *      &lt;/UL&gt;
<span class="nocode"><a name="5899">5899: </a></span>     *  &lt;LI&gt;&lt;B&gt;SPECIFIC_NAME&lt;/B&gt; String  =&gt; the name which uniquely identifies 
<span class="nocode"><a name="5900">5900: </a></span>     *  this function within its schema.  This is a user specified, or DBMS
<span class="nocode"><a name="5901">5901: </a></span>     * generated, name that may be different then the &lt;code&gt;FUNCTION_NAME&lt;/code&gt; 
<span class="nocode"><a name="5902">5902: </a></span>     * for example with overload functions
<span class="nocode"><a name="5903">5903: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5904">5904: </a></span>     * &lt;p&gt;
<span class="nocode"><a name="5905">5905: </a></span>     * A user may not have permission to execute any of the functions that are
<span class="nocode"><a name="5906">5906: </a></span>     * returned by &lt;code&gt;getFunctions&lt;/code&gt;
<span class="nocode"><a name="5907">5907: </a></span>     *
<span class="nocode"><a name="5908">5908: </a></span>     * @param catalog a catalog name; must match the catalog name as it
<span class="nocode"><a name="5909">5909: </a></span>     *        is stored in the database; &quot;&quot; retrieves those without a catalog;
<span class="nocode"><a name="5910">5910: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the catalog name should not be used to narrow
<span class="nocode"><a name="5911">5911: </a></span>     *        the search
<span class="nocode"><a name="5912">5912: </a></span>     * @param schemaPattern a schema name pattern; must match the schema name
<span class="nocode"><a name="5913">5913: </a></span>     *        as it is stored in the database; &quot;&quot; retrieves those without a schema;
<span class="nocode"><a name="5914">5914: </a></span>     *        &lt;code&gt;null&lt;/code&gt; means that the schema name should not be used to narrow
<span class="nocode"><a name="5915">5915: </a></span>     *        the search
<span class="nocode"><a name="5916">5916: </a></span>     * @param functionNamePattern a function name pattern; must match the
<span class="nocode"><a name="5917">5917: </a></span>     *        function name as it is stored in the database 
<span class="nocode"><a name="5918">5918: </a></span>     * @return &lt;code&gt;ResultSet&lt;/code&gt; - each row is a function description 
<span class="nocode"><a name="5919">5919: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5920">5920: </a></span>     * @see #getSearchStringEscape 
<span class="nocode"><a name="5921">5921: </a></span>     * @since 1.6
<span class="nocode"><a name="5922">5922: </a></span>     */
<span class="nocode"><a name="5923">5923: </a></span>    public ResultSet getFunctions(String catalog, String schemaPattern, String functionNamePattern) throws SQLException {
<span class="nocode"><a name="5924">5924: </a></span>        throw new FBDriverNotCapableException();
<span class="nocode"><a name="5925">5925: </a></span>    }
<span class="nocode"><a name="5926">5926: </a></span>
<span class="nocode"><a name="5927">5927: </a></span>    /**
<span class="nocode"><a name="5928">5928: </a></span>     * Retrieves the schema names available in this database.  The results
<span class="nocode"><a name="5929">5929: </a></span>     * are ordered by &lt;code&gt;TABLE_CATALOG&lt;/code&gt; and 
<span class="nocode"><a name="5930">5930: </a></span>     * &lt;code&gt;TABLE_SCHEM&lt;/code&gt;.
<span class="nocode"><a name="5931">5931: </a></span>     *
<span class="nocode"><a name="5932">5932: </a></span>     * &lt;P&gt;The schema columns are:
<span class="nocode"><a name="5933">5933: </a></span>     *  &lt;OL&gt;
<span class="nocode"><a name="5934">5934: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_SCHEM&lt;/B&gt; String =&gt; schema name
<span class="nocode"><a name="5935">5935: </a></span>     *  &lt;LI&gt;&lt;B&gt;TABLE_CATALOG&lt;/B&gt; String =&gt; catalog name (may be &lt;code&gt;null&lt;/code&gt;)
<span class="nocode"><a name="5936">5936: </a></span>     *  &lt;/OL&gt;
<span class="nocode"><a name="5937">5937: </a></span>     *
<span class="nocode"><a name="5938">5938: </a></span>     *
<span class="nocode"><a name="5939">5939: </a></span>     * @param catalog a catalog name; must match the catalog name as it is stored
<span class="nocode"><a name="5940">5940: </a></span>     * in the database;&quot;&quot; retrieves those without a catalog; null means catalog
<span class="nocode"><a name="5941">5941: </a></span>     * name should not be used to narrow down the search.
<span class="nocode"><a name="5942">5942: </a></span>     * @param schemaPattern a schema name; must match the schema name as it is
<span class="nocode"><a name="5943">5943: </a></span>     * stored in the database; null means
<span class="nocode"><a name="5944">5944: </a></span>     * schema name should not be used to narrow down the search.
<span class="nocode"><a name="5945">5945: </a></span>     * @return a &lt;code&gt;ResultSet&lt;/code&gt; object in which each row is a
<span class="nocode"><a name="5946">5946: </a></span>     *         schema description
<span class="nocode"><a name="5947">5947: </a></span>     * @exception SQLException if a database access error occurs
<span class="nocode"><a name="5948">5948: </a></span>     * @see #getSearchStringEscape 
<span class="nocode"><a name="5949">5949: </a></span>     * @since 1.6
<span class="nocode"><a name="5950">5950: </a></span>     */
<span class="nocode"><a name="5951">5951: </a></span>    public ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
<span class="nocode"><a name="5952">5952: </a></span>        XSQLVAR[] xsqlvars = new XSQLVAR[2];
<span class="nocode"><a name="5953">5953: </a></span>
<span class="nocode"><a name="5954">5954: </a></span>        xsqlvars[0] = new XSQLVAR();
<span class="nocode"><a name="5955">5955: </a></span>        xsqlvars[0].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5956">5956: </a></span>        xsqlvars[0].sqllen = 31;
<span class="nocode"><a name="5957">5957: </a></span>        xsqlvars[0].sqlname = &quot;TABLE_SCHEM&quot;;
<span class="nocode"><a name="5958">5958: </a></span>        xsqlvars[0].relname = &quot;TABLESCHEMAS&quot;;
<span class="nocode"><a name="5959">5959: </a></span>        
<span class="nocode"><a name="5960">5960: </a></span>        xsqlvars[1] = new XSQLVAR();
<span class="nocode"><a name="5961">5961: </a></span>        xsqlvars[1].sqltype = ISCConstants.SQL_VARYING;
<span class="nocode"><a name="5962">5962: </a></span>        xsqlvars[1].sqllen = 31;
<span class="nocode"><a name="5963">5963: </a></span>        xsqlvars[1].sqlname = &quot;TABLE_CATALOG&quot;;
<span class="nocode"><a name="5964">5964: </a></span>        xsqlvars[1].relname = &quot;TABLESCHEMAS&quot;;
<span class="nocode"><a name="5965">5965: </a></span>
<span class="nocode"><a name="5966">5966: </a></span>        List&lt;byte[][]&gt; rows = Collections.emptyList();
<span class="nocode"><a name="5967">5967: </a></span>
<span class="nocode"><a name="5968">5968: </a></span>        return new FBResultSet(xsqlvars, rows);
<span class="nocode"><a name="5969">5969: </a></span>    }
<span class="nocode"><a name="5970">5970: </a></span>
<span class="nocode"><a name="5971">5971: </a></span>    public boolean isWrapperFor(Class&lt;?&gt; iface) throws SQLException {
<span class="nocode"><a name="5972">5972: </a></span>        return iface != null &amp;&amp; iface.isAssignableFrom(FBDatabaseMetaData.class);
<span class="nocode"><a name="5973">5973: </a></span>    }
<span class="nocode"><a name="5974">5974: </a></span>
<span class="nocode"><a name="5975">5975: </a></span>    public &lt;T&gt; T unwrap(Class&lt;T&gt; iface) throws SQLException {
<span class="nocode"><a name="5976">5976: </a></span>        if (!isWrapperFor(iface))
<span class="nocode"><a name="5977">5977: </a></span>            throw new FBSQLException(&quot;No compatible class found.&quot;);
<span class="nocode"><a name="5978">5978: </a></span>        
<span class="nocode"><a name="5979">5979: </a></span>        return iface.cast(this);
<span class="nocode"><a name="5980">5980: </a></span>    }    
<span class="nocode"><a name="5981">5981: </a></span>    
<span class="nocode"><a name="5982">5982: </a></span>    public boolean isAllCondition(String pattern) {
<span class="nocode"><a name="5983">5983: </a></span><span style="background-color: #ffffcc">        if (&quot;%&quot;.equals(pattern)) {</span>
<span class="nocode"><a name="5984">5984: </a></span>            //asks for everything, no condition needed
<span class="nocode"><a name="5985">5985: </a></span>            return true;
<span class="nocode"><a name="5986">5986: </a></span>        }
<span class="nocode"><a name="5987">5987: </a></span><span style="background-color: #ffffcc">        return false;</span>
<span class="nocode"><a name="5988">5988: </a></span>    }
<span class="nocode"><a name="5989">5989: </a></span>
<span class="nocode"><a name="5990">5990: </a></span>    /**
<span class="nocode"><a name="5991">5991: </a></span>     * Determine if there are no SQL wildcard characters ('%' or '_') in the 
<span class="nocode"><a name="5992">5992: </a></span>     * given pattern.
<span class="nocode"><a name="5993">5993: </a></span>     *
<span class="nocode"><a name="5994">5994: </a></span>     * @param pattern The pattern to be checked for wildcards
<span class="nocode"><a name="5995">5995: </a></span>     * @return &lt;code&gt;true&lt;/code&gt; if there are no wildcards in the pattern, 
<span class="nocode"><a name="5996">5996: </a></span>     *         &lt;code&gt;false&lt;/code&gt; otherwise
<span class="nocode"><a name="5997">5997: </a></span>     */
<span class="nocode"><a name="5998">5998: </a></span>    public boolean hasNoWildcards(String pattern) {
<span class="nocode"><a name="5999">5999: </a></span><span style="background-color: #ffffcc">        if (pattern == null)</span>
<span class="nocode"><a name="6000">6000: </a></span>            return true;
<span class="nocode"><a name="6001">6001: </a></span>
<span class="nocode"><a name="6002">6002: </a></span><span style="background-color: #ffffcc">        int scannedTo = 0;</span>
<span class="nocode"><a name="6003">6003: </a></span>        int pos;
<span class="nocode"><a name="6004">6004: </a></span><span style="background-color: #ffffcc">        while ((pos = pattern.indexOf('%', scannedTo)) &lt; pattern.length()) {</span>
<span class="nocode"><a name="6005">6005: </a></span><span style="background-color: #ffffcc">            if (pos == -1) {</span>
<span class="nocode"><a name="6006">6006: </a></span><span style="background-color: #ffffcc">                break;</span>
<span class="nocode"><a name="6007">6007: </a></span>            }
<span class="nocode"><a name="6008">6008: </a></span>            if ((pos == 0) || (pattern.charAt(pos - 1) != '\\')) {
<span class="nocode"><a name="6009">6009: </a></span>                return false;
<span class="nocode"><a name="6010">6010: </a></span>            }
<span class="nocode"><a name="6011">6011: </a></span>            scannedTo = ++pos;
<span class="nocode"><a name="6012">6012: </a></span>        }
<span class="nocode"><a name="6013">6013: </a></span><span style="background-color: #ffffcc">        scannedTo = 0;</span>
<span class="nocode"><a name="6014">6014: </a></span><span style="background-color: #ffffcc">        while ((pos = pattern.indexOf('_', scannedTo)) &lt; pattern.length()) {</span>
<span class="nocode"><a name="6015">6015: </a></span><span style="background-color: #ffffcc">            if (pos == -1) {</span>
<span class="nocode"><a name="6016">6016: </a></span><span style="background-color: #ffffcc">                break;</span>
<span class="nocode"><a name="6017">6017: </a></span>            }
<span class="nocode"><a name="6018">6018: </a></span>            if ((pos == 0) || (pattern.charAt(pos - 1) != '\\')) {
<span class="nocode"><a name="6019">6019: </a></span>                return false;
<span class="nocode"><a name="6020">6020: </a></span>            }
<span class="nocode"><a name="6021">6021: </a></span>            scannedTo = ++pos;
<span class="nocode"><a name="6022">6022: </a></span>        }
<span class="nocode"><a name="6023">6023: </a></span><span style="background-color: #ffffcc">        return true;</span>
<span class="nocode"><a name="6024">6024: </a></span>    }
<span class="nocode"><a name="6025">6025: </a></span>
<span class="nocode"><a name="6026">6026: </a></span>    /**
<span class="nocode"><a name="6027">6027: </a></span>     * Strips all backslash-escapes from a string.
<span class="nocode"><a name="6028">6028: </a></span>     *
<span class="nocode"><a name="6029">6029: </a></span>     * @param pattern The string to be stripped
<span class="nocode"><a name="6030">6030: </a></span>     * @return pattern with all backslash-escapes removed
<span class="nocode"><a name="6031">6031: </a></span>     */
<span class="nocode"><a name="6032">6032: </a></span>    public String stripEscape(String pattern) {
<span class="nocode"><a name="6033">6033: </a></span><span style="background-color: #ffffcc">        StringBuffer stripped = new StringBuffer(pattern.length());</span>
<span class="nocode"><a name="6034">6034: </a></span><span style="background-color: #ffffcc">        for (int pos = 0; pos &lt; pattern.length(); pos++) {</span>
<span class="nocode"><a name="6035">6035: </a></span><span style="background-color: #ffffcc">            if (pattern.charAt(pos) != '\\') {</span>
<span class="nocode"><a name="6036">6036: </a></span><span style="background-color: #ffffcc">                stripped.append(pattern.charAt(pos));</span>
<span class="nocode"><a name="6037">6037: </a></span>            }
<span class="nocode"><a name="6038">6038: </a></span>        }
<span class="nocode"><a name="6039">6039: </a></span><span style="background-color: #ffffcc">        return stripped.toString();</span>
<span class="nocode"><a name="6040">6040: </a></span>    }
<span class="nocode"><a name="6041">6041: </a></span>
<span class="nocode"><a name="6042">6042: </a></span>    protected String getWantsSystemTables(String[] types) {
<span class="nocode"><a name="6043">6043: </a></span>        for (int i = 0; i &lt; types.length; i++) {
<span class="nocode"><a name="6044">6044: </a></span>            if (SYSTEM_TABLE.equals(types[i])) {
<span class="nocode"><a name="6045">6045: </a></span>                return &quot;T&quot;;
<span class="nocode"><a name="6046">6046: </a></span>            }
<span class="nocode"><a name="6047">6047: </a></span>        }
<span class="nocode"><a name="6048">6048: </a></span>        return &quot;F&quot;;
<span class="nocode"><a name="6049">6049: </a></span>    }
<span class="nocode"><a name="6050">6050: </a></span>
<span class="nocode"><a name="6051">6051: </a></span>    protected String getWantsTables(String[] types) {
<span class="nocode"><a name="6052">6052: </a></span>        for (int i = 0; i &lt; types.length; i++) {
<span class="nocode"><a name="6053">6053: </a></span>            if (TABLE.equals(types[i])) {
<span class="nocode"><a name="6054">6054: </a></span>                return &quot;T&quot;;
<span class="nocode"><a name="6055">6055: </a></span>            }
<span class="nocode"><a name="6056">6056: </a></span>        }
<span class="nocode"><a name="6057">6057: </a></span>        return &quot;F&quot;;
<span class="nocode"><a name="6058">6058: </a></span>    }
<span class="nocode"><a name="6059">6059: </a></span>
<span class="nocode"><a name="6060">6060: </a></span>    protected String getWantsViews(String[] types) {
<span class="nocode"><a name="6061">6061: </a></span>        for (int i = 0; i &lt; types.length; i++) {
<span class="nocode"><a name="6062">6062: </a></span>            if (VIEW.equals(types[i])) {
<span class="nocode"><a name="6063">6063: </a></span>                return &quot;T&quot;;
<span class="nocode"><a name="6064">6064: </a></span>            }
<span class="nocode"><a name="6065">6065: </a></span>        }
<span class="nocode"><a name="6066">6066: </a></span>        return &quot;F&quot;;
<span class="nocode"><a name="6067">6067: </a></span>    }
<span class="nocode"><a name="6068">6068: </a></span>
<span class="nocode"><a name="6069">6069: </a></span>    /**
<span class="nocode"><a name="6070">6070: </a></span>     * Strips a leading and trailing quote (double or single) from a string.
<span class="nocode"><a name="6071">6071: </a></span>     *
<span class="nocode"><a name="6072">6072: </a></span>     * @param pattern the string to be stripped
<span class="nocode"><a name="6073">6073: </a></span>     * @return a copy of &lt;code&gt;pattern&lt;/code&gt; with leading and trailing quote 
<span class="nocode"><a name="6074">6074: </a></span>     * removed
<span class="nocode"><a name="6075">6075: </a></span>     */
<span class="nocode"><a name="6076">6076: </a></span>    public String stripQuotes(String pattern, boolean uppercase) {
<span class="nocode"><a name="6077">6077: </a></span><span style="background-color: #ffffcc">        if ((pattern.length() &gt;= 2)</span>
<span class="nocode"><a name="6078">6078: </a></span>            &amp;&amp; (pattern.charAt(0) == '\&quot;')
<span class="nocode"><a name="6079">6079: </a></span>            &amp;&amp; (pattern.charAt(pattern.length() - 1) == '\&quot;'))
<span class="nocode"><a name="6080">6080: </a></span>        {
<span class="nocode"><a name="6081">6081: </a></span>            return pattern.substring(1, pattern.length() - 1);
<span class="nocode"><a name="6082">6082: </a></span>        }
<span class="nocode"><a name="6083">6083: </a></span>        else {
<span class="nocode"><a name="6084">6084: </a></span><span style="background-color: #ffffcc">            if (uppercase)</span>
<span class="nocode"><a name="6085">6085: </a></span><span style="background-color: #ffffcc">                return pattern.toUpperCase();</span>
<span class="nocode"><a name="6086">6086: </a></span>            else
<span class="nocode"><a name="6087">6087: </a></span><span style="background-color: #ffffcc">                return pattern;</span>
<span class="nocode"><a name="6088">6088: </a></span>        }
<span class="nocode"><a name="6089">6089: </a></span>    }
<span class="nocode"><a name="6090">6090: </a></span>    
<span class="nocode"><a name="6091">6091: </a></span>    public ResultSet getPseudoColumns(String catalog, String schemaPattern,
<span class="nocode"><a name="6092">6092: </a></span>            String tableNamePattern, String columnNamePattern) throws SQLException {
<span class="nocode"><a name="6093">6093: </a></span>        // TODO Write implementation
<span class="nocode"><a name="6094">6094: </a></span>        throw new FBDriverNotCapableException();
<span class="nocode"><a name="6095">6095: </a></span>    }
<span class="nocode"><a name="6096">6096: </a></span>
<span class="nocode"><a name="6097">6097: </a></span>    public boolean generatedKeyAlwaysReturned() throws SQLException {
<span class="nocode"><a name="6098">6098: </a></span>        // TODO Double check if this is correct
<span class="nocode"><a name="6099">6099: </a></span>        return false;
<span class="nocode"><a name="6100">6100: </a></span>    }
<span class="nocode"><a name="6101">6101: </a></span>
<span class="nocode"><a name="6102">6102: </a></span>    /*
<span class="nocode"><a name="6103">6103: </a></span>     * (non-Javadoc)
<span class="nocode"><a name="6104">6104: </a></span>     * 
<span class="nocode"><a name="6105">6105: </a></span>     * @see org.firebirdsql.jdbc.FirebirdDatabaseMetaData#getProcedureSourceCode(java.lang.String)
<span class="nocode"><a name="6106">6106: </a></span>     */
<span class="nocode"><a name="6107">6107: </a></span>    public String getProcedureSourceCode(String procedureName)
<span class="nocode"><a name="6108">6108: </a></span>            throws SQLException {
<span class="nocode"><a name="6109">6109: </a></span>        String sResult = null;
<span class="nocode"><a name="6110">6110: </a></span>        String sql = &quot;Select RDB$PROCEDURE_SOURCE From RDB$PROCEDURES Where &quot;
<span class="nocode"><a name="6111">6111: </a></span>                + &quot;RDB$PROCEDURE_NAME = ?&quot;;
<span class="nocode"><a name="6112">6112: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="6113">6113: </a></span>        params.add(procedureName);
<span class="nocode"><a name="6114">6114: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="6115">6115: </a></span>        if (rs.next()) sResult = rs.getString(1);
<span class="nocode"><a name="6116">6116: </a></span>        rs.close();
<span class="nocode"><a name="6117">6117: </a></span>
<span class="nocode"><a name="6118">6118: </a></span>        return sResult;
<span class="nocode"><a name="6119">6119: </a></span>    } 
<span class="nocode"><a name="6120">6120: </a></span>
<span class="nocode"><a name="6121">6121: </a></span>    /*
<span class="nocode"><a name="6122">6122: </a></span>     * (non-Javadoc)
<span class="nocode"><a name="6123">6123: </a></span>     * 
<span class="nocode"><a name="6124">6124: </a></span>     * @see org.firebirdsql.jdbc.FirebirdDatabaseMetaData#getTriggerSourceCode(java.lang.String)
<span class="nocode"><a name="6125">6125: </a></span>     */
<span class="nocode"><a name="6126">6126: </a></span>    public String getTriggerSourceCode(String triggerName) throws SQLException {
<span class="nocode"><a name="6127">6127: </a></span>        String sResult = null;
<span class="nocode"><a name="6128">6128: </a></span>        String sql = &quot;Select RDB$TRIGGER_SOURCE From RDB$TRIGGERS Where &quot;
<span class="nocode"><a name="6129">6129: </a></span>                + &quot;RDB$TRIGGER_NAME = ?&quot;;
<span class="nocode"><a name="6130">6130: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="6131">6131: </a></span>        params.add(triggerName);
<span class="nocode"><a name="6132">6132: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="6133">6133: </a></span>        if (rs.next()) sResult = rs.getString(1);
<span class="nocode"><a name="6134">6134: </a></span>        rs.close();
<span class="nocode"><a name="6135">6135: </a></span>
<span class="nocode"><a name="6136">6136: </a></span>        return sResult;
<span class="nocode"><a name="6137">6137: </a></span>    }
<span class="nocode"><a name="6138">6138: </a></span>
<span class="nocode"><a name="6139">6139: </a></span>    /*
<span class="nocode"><a name="6140">6140: </a></span>     * (non-Javadoc)
<span class="nocode"><a name="6141">6141: </a></span>     * 
<span class="nocode"><a name="6142">6142: </a></span>     * @see org.firebirdsql.jdbc.FirebirdDatabaseMetaData#getViewSourceCode(java.lang.String)
<span class="nocode"><a name="6143">6143: </a></span>     */
<span class="nocode"><a name="6144">6144: </a></span>    public String getViewSourceCode(String viewName) throws SQLException {
<span class="nocode"><a name="6145">6145: </a></span>        String sResult = null;
<span class="nocode"><a name="6146">6146: </a></span>        String sql = &quot;Select RDB$VIEW_SOURCE From RDB$RELATIONS Where &quot;
<span class="nocode"><a name="6147">6147: </a></span>                + &quot;RDB$RELATION_NAME = ?&quot;;
<span class="nocode"><a name="6148">6148: </a></span>        List&lt;String&gt; params = new ArrayList&lt;String&gt;();
<span class="nocode"><a name="6149">6149: </a></span>        params.add(viewName);
<span class="nocode"><a name="6150">6150: </a></span>        ResultSet rs = doQuery(sql, params);
<span class="nocode"><a name="6151">6151: </a></span>        if (rs.next()) sResult = rs.getString(1);
<span class="nocode"><a name="6152">6152: </a></span>        rs.close();
<span class="nocode"><a name="6153">6153: </a></span>
<span class="nocode"><a name="6154">6154: </a></span>        return sResult;
<span class="nocode"><a name="6155">6155: </a></span>    }
<span class="nocode"><a name="6156">6156: </a></span>
<span class="nocode"><a name="6157">6157: </a></span>    protected void checkCatalogAndSchema(String catalog, String schema) throws SQLException {
<span class="nocode"><a name="6158">6158: </a></span>        /* 
<span class="nocode"><a name="6159">6159: </a></span>         * we ignore incorrect catalog and schema specification as 
<span class="nocode"><a name="6160">6160: </a></span>         * suggested by Thomas Kellerer in JDBC Forum 
<span class="nocode"><a name="6161">6161: </a></span>        */
<span class="nocode"><a name="6162">6162: </a></span><span style="background-color: #ffffcc">    }</span>
<span class="nocode"><a name="6163">6163: </a></span>
<span class="nocode"><a name="6164">6164: </a></span>    protected class Clause {
<span class="nocode"><a name="6165">6165: </a></span><span style="background-color: #ffffcc">        private String condition = &quot;&quot;;</span>
<span class="nocode"><a name="6166">6166: </a></span>        private String value;
<span class="nocode"><a name="6167">6167: </a></span>        private String originalCaseValue;
<span class="nocode"><a name="6168">6168: </a></span>
<span class="nocode"><a name="6169">6169: </a></span>        public Clause (String columnName, String pattern) {
<span class="nocode"><a name="6170">6170: </a></span><span style="background-color: #ffffcc">            if (pattern == null) {</span>
<span class="nocode"><a name="6171">6171: </a></span>                return;
<span class="nocode"><a name="6172">6172: </a></span>            }
<span class="nocode"><a name="6173">6173: </a></span><span style="background-color: #ffffcc">            else if (isAllCondition(pattern)) {</span>
<span class="nocode"><a name="6174">6174: </a></span>                //do nothing to tableCondition
<span class="nocode"><a name="6175">6175: </a></span>                return;
<span class="nocode"><a name="6176">6176: </a></span>            }
<span class="nocode"><a name="6177">6177: </a></span><span style="background-color: #ffffcc">            else if (hasNoWildcards(pattern)) {</span>
<span class="nocode"><a name="6178">6178: </a></span><span style="background-color: #ffffcc">                value = stripQuotes(stripEscape(pattern), true);</span>
<span class="nocode"><a name="6179">6179: </a></span><span style="background-color: #ffffcc">                originalCaseValue = stripQuotes(stripEscape(pattern), false);</span>
<span class="nocode"><a name="6180">6180: </a></span><span style="background-color: #ffffcc">                condition = columnName + &quot; = ? and &quot;;</span>
<span class="nocode"><a name="6181">6181: </a></span>            }
<span class="nocode"><a name="6182">6182: </a></span>            else {
<span class="nocode"><a name="6183">6183: </a></span>                value = stripQuotes(pattern, true) + SPACES + &quot;%&quot;;
<span class="nocode"><a name="6184">6184: </a></span>                originalCaseValue = stripQuotes(pattern, false) + SPACES + &quot;%&quot;;
<span class="nocode"><a name="6185">6185: </a></span>                condition = columnName + &quot; || '&quot; + SPACES + &quot;' like ? escape '\\' and &quot;;
<span class="nocode"><a name="6186">6186: </a></span>            }
<span class="nocode"><a name="6187">6187: </a></span><span style="background-color: #ffffcc">        }</span>
<span class="nocode"><a name="6188">6188: </a></span>
<span class="nocode"><a name="6189">6189: </a></span>        public String getCondition() {
<span class="nocode"><a name="6190">6190: </a></span><span style="background-color: #ffffcc">            return condition;</span>
<span class="nocode"><a name="6191">6191: </a></span>        }
<span class="nocode"><a name="6192">6192: </a></span>
<span class="nocode"><a name="6193">6193: </a></span>        public String getValue() {
<span class="nocode"><a name="6194">6194: </a></span>            return value;
<span class="nocode"><a name="6195">6195: </a></span>        }
<span class="nocode"><a name="6196">6196: </a></span>        
<span class="nocode"><a name="6197">6197: </a></span>        public String getOriginalCaseValue() {
<span class="nocode"><a name="6198">6198: </a></span><span style="background-color: #ffffcc">            return originalCaseValue;</span>
<span class="nocode"><a name="6199">6199: </a></span>        }
<span class="nocode"><a name="6200">6200: </a></span>    }
<span class="nocode"><a name="6201">6201: </a></span>
<span class="nocode"><a name="6202">6202: </a></span>    protected byte[] getBytes(String value){
<span class="nocode"><a name="6203">6203: </a></span><span style="background-color: #ffffcc">        if (value !=null)</span>
<span class="nocode"><a name="6204">6204: </a></span><span style="background-color: #ffffcc">            return value.getBytes();</span>
<span class="nocode"><a name="6205">6205: </a></span>        else
<span class="nocode"><a name="6206">6206: </a></span>            return null;
<span class="nocode"><a name="6207">6207: </a></span>    }
<span class="nocode"><a name="6208">6208: </a></span>    
<span class="nocode"><a name="6209">6209: </a></span>    private AbstractPreparedStatement getStatement(String sql) throws SQLException {
<span class="nocode"><a name="6210">6210: </a></span><span style="background-color: #ffffcc">        AbstractPreparedStatement s = statements.get(sql);</span>
<span class="nocode"><a name="6211">6211: </a></span>        
<span class="nocode"><a name="6212">6212: </a></span><span style="background-color: #ffffcc">        if (s != null &amp;&amp; s.isClosed()) {</span>
<span class="nocode"><a name="6213">6213: </a></span>            statements.remove(sql);
<span class="nocode"><a name="6214">6214: </a></span>            s = null;
<span class="nocode"><a name="6215">6215: </a></span>        }
<span class="nocode"><a name="6216">6216: </a></span>        
<span class="nocode"><a name="6217">6217: </a></span><span style="background-color: #ffffcc">        if (s != null) </span>
<span class="nocode"><a name="6218">6218: </a></span>            return s;
<span class="nocode"><a name="6219">6219: </a></span>        
<span class="nocode"><a name="6220">6220: </a></span><span style="background-color: #ffffcc">        if (connection == null) {</span>
<span class="nocode"><a name="6221">6221: </a></span><span style="background-color: #ffffcc">            InternalTransactionCoordinator.MetaDataTransactionCoordinator metaDataTransactionCoordinator = </span>
<span class="nocode"><a name="6222">6222: </a></span>                new InternalTransactionCoordinator.MetaDataTransactionCoordinator();
<span class="nocode"><a name="6223">6223: </a></span>            
<span class="nocode"><a name="6224">6224: </a></span><span style="background-color: #ffffcc">            s = new FBPreparedStatement(gdsHelper, sql,</span>
<span class="nocode"><a name="6225">6225: </a></span>                    ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY,
<span class="nocode"><a name="6226">6226: </a></span>                    ResultSet.CLOSE_CURSORS_AT_COMMIT, 
<span class="nocode"><a name="6227">6227: </a></span>                    metaDataTransactionCoordinator, metaDataTransactionCoordinator,
<span class="nocode"><a name="6228">6228: </a></span>                    true, true, false);
<span class="nocode"><a name="6229">6229: </a></span>        } else {
<span class="nocode"><a name="6230">6230: </a></span>            s = (AbstractPreparedStatement)connection.prepareMetaDataStatement(
<span class="nocode"><a name="6231">6231: </a></span>                sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
<span class="nocode"><a name="6232">6232: </a></span>        }
<span class="nocode"><a name="6233">6233: </a></span>            
<span class="nocode"><a name="6234">6234: </a></span>        statements.put(sql, s);
<span class="nocode"><a name="6235">6235: </a></span>        
<span class="nocode"><a name="6236">6236: </a></span>        return s;
<span class="nocode"><a name="6237">6237: </a></span>    }
<span class="nocode"><a name="6238">6238: </a></span>
<span class="nocode"><a name="6239">6239: </a></span>    /**
<span class="nocode"><a name="6240">6240: </a></span>     * Execute an sql query with a given set of parameters.
<span class="nocode"><a name="6241">6241: </a></span>     * 
<span class="nocode"><a name="6242">6242: </a></span>     * @param sql
<span class="nocode"><a name="6243">6243: </a></span>     *            The sql statement to be used for the query
<span class="nocode"><a name="6244">6244: </a></span>     * @param params
<span class="nocode"><a name="6245">6245: </a></span>     *            The parameters to be used in the query
<span class="nocode"><a name="6246">6246: </a></span>     * @throws SQLException
<span class="nocode"><a name="6247">6247: </a></span>     *             if a database access error occurs
<span class="nocode"><a name="6248">6248: </a></span>     */
<span class="nocode"><a name="6249">6249: </a></span>    public ResultSet doQuery(String sql, List&lt;String&gt; params)
<span class="nocode"><a name="6250">6250: </a></span>            throws SQLException {
<span class="nocode"><a name="6251">6251: </a></span>        
<span class="nocode"><a name="6252">6252: </a></span><span style="background-color: #ffffcc">        AbstractPreparedStatement s = getStatement(sql);</span>
<span class="nocode"><a name="6253">6253: </a></span>        
<span class="nocode"><a name="6254">6254: </a></span>        for (int i = 0; i &lt; params.size(); i++)
<span class="nocode"><a name="6255">6255: </a></span>            s.setStringForced(i + 1, params.get(i));
<span class="nocode"><a name="6256">6256: </a></span>
<span class="nocode"><a name="6257">6257: </a></span>        return s.executeMetaDataQuery();
<span class="nocode"><a name="6258">6258: </a></span>    }
<span class="nocode"><a name="6259">6259: </a></span>}
</pre>
</p></div>
</div><div id="post"><h2 id=parameters>EvoSuite Parameters</h2>
<div class=statistics><ul>
<li>inheritance_file: evosuite-files/inheritance.xml.gz
<li>client_on_thread: false
<li>alternative_fitness_range: 100.0
<li>starve_by_fitness: true
<li>dynamic_pool_size: 50
<li>old_statistics: true
<li>test_includes: test.includes
<li>TT_stack: 10
<li>dynamic_pool: 0.5
<li>minimization_timeout: 600
<li>kincompensation: 1.0
<li>max_generic_depth: 1
<li>local_search_rate: -1
<li>target_method: 
<li>selection_function: RANK
<li>ctg_schedule: SIMPLE
<li>assertion_strategy: MUTATION
<li>tt_scope: ALL
<li>process_communication_port: 14116
<li>TT: false
<li>chromosome_length: 40
<li>adaptive_local_search_dse: false
<li>UI_BACKGROUND_COVERAGE_DELAY: -1
<li>random_perturbation: 0.2
<li>test_factory: RANDOM
<li>enable_alternative_fitness_calculation: false
<li>debug: false
<li>plot: false
<li>log_goals: false
<li>alternative_fitness_calculation_mode: SUM
<li>inline: true
<li>crossover_function: SINGLEPOINTRELATIVE
<li>local_search_budget: 100
<li>static_hack: false
<li>OUTPUT_DIR: evosuite-files
<li>dse_keep_all_tests: false
<li>junit_extend: 
<li>junit_prefix: 
<li>hierarchy_data: hierarchy.xml
<li>num_tests: 2
<li>max_size: 100
<li>statistics_backend: CSV
<li>max_length: 0
<li>mutation_generations: 10
<li>rank_bias: 1.7
<li>primitive_reuse_probability: 0.5
<li>num_random_tests: 20
<li>filter_assertions: true
<li>global_timeout: 600
<li>log.level: null
<li>new_statistics: false
<li>assertions: true
<li>object_pool: 0.0
<li>timeline_interval: 60000
<li>concolic_timeout: 15000
<li>crossover_rate: 0.75
<li>recycle_chromosomes: false
<li>assertion_timeout: 600
<li>serialize_result: false
<li>string_length: 20
<li>testability_transformation: false
<li>p_special_type_call: 0.05
<li>filter_sandbox_tests: false
<li>connection_data: connection.xml
<li>dse_budget: 1
<li>show_progress: true
<li>ctg_cores: 1
<li>p_test_delete: 0.3333333333333333
<li>local_search_references: true
<li>dse_rate: -1
<li>primitive_pool: 0.5
<li>object_reuse_probability: 0.9
<li>shuffle_goals: true
<li>use_deprecated: false
<li>max_coverage_depth: -1
<li>penalize_overwriting_definitions_flat: false
<li>max_attempts: 1000
<li>print_current_goals: false
<li>PROJECT_PREFIX: org
<li>TARGET_CLASS: org.firebirdsql.jdbc.AbstractDatabaseMetaData
<li>p_test_insertion: 0.1
<li>make_accessible: false
<li>population: 50
<li>check_best_length: true
<li>seed_types: true
<li>PROJECT_DIR: null
<li>skip_covered: true
<li>check_contracts: false
<li>write_cfg: false
<li>minimize: true
<li>seed_clone: 0.2
<li>target_method_prefix: 
<li>mutation_timeouts: 3
<li>instrument_parent: false
<li>junit_tests: true
<li>coverage: true
<li>sandbox: true
<li>randomize_difficulty: true
<li>break_on_exception: true
<li>html: true
<li>CP: lib/ant.jar:lib/ant-junit.jar:lib/ant-launcher.jar:lib/antlr-runtime-3.4.jar:lib/connector-api-1.5.jar:lib/cpptasks.jar:lib/firebird_resources.jar:lib/fscontext.jar:lib/j2ee.jar:lib/jaybird-2.3.0.jar:lib/junit.jar:lib/log4j-core.jar:lib/providerutil.jar:lib/serializer-2.7.1.jar:lib/xalan-2.7.1.jar:firebird.jar
<li>search_budget: 60
<li>max_replace_mutants: 100
<li>check_contracts_end: false
<li>log.target: null
<li>array_limit: 1000000
<li>minimize_values: false
<li>secondary_objectives: totallength
<li>log_timeout: false
<li>p_test_change: 0.3333333333333333
<li>restricted_read: false
<li>null_probability: 0.1
<li>configuration_id: null
<li>save_all_data: true
<li>branch_eval: false
<li>remote_testing: false
<li>dse_adaptive_rate: 2.0
<li>local_search_budget_type: STATEMENTS
<li>branch_statement: false
<li>check_parents_length: false
<li>dse_constraint_solver_timeout_millis: 0
<li>elite: 1
<li>local_search_probes: 10
<li>enable_asserts_for_sut: true
<li>output_granularity: MERGED
<li>criterion: BRANCH
<li>restrict_pool: false
<li>shutdown_timeout: 1000
<li>output_variables: null
<li>structured_tests: false
<li>random_tests: 0
<li>initially_enforced_randomness: 0.4
<li>selected_junit: null
<li>p_change_parameter: 0.1
<li>port: 1044
<li>defuse_aliases: true
<li>dse_constraint_length: 100000
<li>reuse_budget: true
<li>test_dir: evosuite-tests
<li>replace_calls: false
<li>max_initial_tests: 10
<li>TARGET_CLASS_PREFIX: 
<li>dse_adaptive_probability: 0.0
<li>algorithm: STEADYSTATEGA
<li>report_dir: evosuite-report
<li>target_method_list: 
<li>local_search_arrays: true
<li>dse_constant_probability: 0.5
<li>max_int: 2048
<li>error_branches: false
<li>stopping_condition: MAXTIME
<li>local_search_primitives: true
<li>minimize_old: false
<li>max_mutants_per_method: 700
<li>adaptive_local_search: OFF
<li>replacement_function: DEFAULT
<li>number_of_mutations: 1
<li>test_comments: true
<li>defuse_debug_mode: false
<li>shutdown_hook: true
<li>bloat_factor: 2
<li>dse_variable_resets: 2
<li>test_format: JUNIT4
<li>penalize_overwriting_definitions_linearly: false
<li>max_stalled_threads: 10
<li>insertion_score_object: 1
<li>instrumentation_skip_debug: false
<li>sandbox_mode: RECOMMENDED
<li>call_probability: 0.0
<li>check_max_length: true
<li>max_recursion: 10
<li>usage_rate: 0.5
<li>max_mutants: 100
<li>p_statement_insertion: 0.5
<li>usage_models: 
<li>test_carving: false
<li>evosuite_use_uispec: false
<li>instrument_context: false
<li>ctg_time: 2
<li>ctg_memory: 1000
<li>classpath: 
<li>max_array: 10
<li>dse_negate_all_conditions: false
<li>seed_mutations: 2
<li>tournament_size: 10
<li>dse_budget_type: INDIVIDUALS
<li>dse_rank_branch_conditions: false
<li>concolic_mutation: 0.0
<li>stop_zero: true
<li>parent_check: true
<li>insertion_score_parameter: 1
<li>junit_suffix: EvoSuiteTest
<li>min_initial_tests: 1
<li>max_delta: 20
<li>cpu_timeout: false
<li>dynamic_limit: false
<li>min_free_mem: 50000000
<li>test_excludes: test.excludes
<li>write_pool: false
<li>epsilon: 0.0010
<li>enable_asserts_for_evosuite: false
<li>analysis_criteria: 
<li>junit_strict: false
<li>print_to_system: false
<li>virtual_fs: false
<li>sandbox_folder: evosuite-sandbox
<li>strategy: EVOSUITE
<li>enable_alternative_suite_fitness: false
<li>max_mutants_per_test: 100
<li>stopping_port: -1
<li>insertion_score_uut: 1
<li>sourcepath: 
<li>print_covered_goals: false
<li>extra_timeout: 120
<li>string_replacement: true
<li>cluster_recursion: 10
<li>population_limit: INDIVIDUALS
<li>p_test_insert: 0.3333333333333333
<li>constraint_solution_attempts: 3
<li>timeout: 5000
</ul></div>
</div><p><br><a href="../report-generation.html">Back to Overview</a></p>
</div>
</body>
</html>
