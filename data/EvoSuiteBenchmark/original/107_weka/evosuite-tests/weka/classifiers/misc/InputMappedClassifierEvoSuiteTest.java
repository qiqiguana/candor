/*
 * This file was automatically generated by EvoSuite
 */

package weka.classifiers.misc;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.junit.EvoSuiteRunner;
import static org.junit.Assert.*;
import java.util.ArrayList;
import java.util.Enumeration;
import org.junit.BeforeClass;
import weka.classifiers.AbstractClassifier;
import weka.classifiers.Classifier;
import weka.classifiers.misc.InputMappedClassifier;
import weka.core.Attribute;
import weka.core.Environment;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.SparseInstance;

@RunWith(EvoSuiteRunner.class)
public class InputMappedClassifierEvoSuiteTest {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.Properties.REPLACE_CALLS = true; 
  } 


  @Test
  public void test0()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances("Abstract class for nearest neighbour search All algorithms (classes) that do nearest neighbour search should extend this class.", arrayList0, 33);
      inputMappedClassifier0.setModelHeader(instances0);
      double[] doubleArray0 = new double[8];
      SparseInstance sparseInstance0 = new SparseInstance((double) 33, doubleArray0);
      inputMappedClassifier0.classifyInstance((Instance) sparseInstance0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test1()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setTestStructure((Instances) null);
      try {
        inputMappedClassifier0.buildClassifier((Instances) null);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test2()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      double[] doubleArray0 = new double[8];
      SparseInstance sparseInstance0 = new SparseInstance((double) 33, doubleArray0);
      try {
        inputMappedClassifier0.distributionForInstance((Instance) sparseInstance0);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test3()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String[] stringArray0 = new String[6];
      stringArray0[0] = "Whether to use binary splits on nominal attributes when building the trees.";
      stringArray0[1] = "Whether to use binary splits on nominal attributes when building the trees.";
      stringArray0[2] = "Whether to use binary splits on nominal attributes when building the trees.";
      stringArray0[3] = "Whether to use binary splits on nominal attributes when building the trees.";
      stringArray0[4] = "Whether to use binary splits on nominal attributes when building the trees.";
      stringArray0[5] = "Whether to use binary splits on nominal attributes when building the trees.";
      inputMappedClassifier0.setOptions(stringArray0);
      inputMappedClassifier0.getOptions();
      assertEquals(false, inputMappedClassifier0.getTrim());
      assertEquals(false, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
  }

  @Test
  public void test4()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Environment environment0 = Environment.getSystemWide();
      inputMappedClassifier0.setEnvironment(environment0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
  }

  @Test
  public void test5()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.trimTipText();
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("Trim white space from each end of attribute names and nominal values before matching.", string0);
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
  }

  @Test
  public void test6()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.getRevision();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertNotNull(string0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals("8034", string0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
  }

  @Test
  public void test7()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.globalInfo();
      assertEquals("Wrapper classifier that addresses incompatible training and test data by building a mapping between the training data that a classifier has been built with and the incoming test instances' structure. Model attributes that are not found in the incoming instances receive missing values, so do incoming nominal attribute values that the classifier has not seen before. A new classifier can be trained or an existing one loaded from a file.", string0);
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test8()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.ignoreCaseForNamesTipText();
      assertEquals("Ignore case when matching attribute names and nomina values.", string0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test9()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.suppressMappingReportTipText();
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("Don't output a report of model-to-input mappings.", string0);
  }

  @Test
  public void test10()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      double[] doubleArray0 = new double[8];
      SparseInstance sparseInstance0 = new SparseInstance((double) 33, doubleArray0);
      try {
        inputMappedClassifier0.classifyInstance((Instance) sparseInstance0);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test11()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.modelPathTipText();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("Set the path from which to load a model. Loading occurs when the first test instance is received. Environment variables can be used in the supplied path.", string0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test12()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath((String) null);
      inputMappedClassifier0.setModelPath((String) null);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
  }

  @Test
  public void test13()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      Enumeration<Option> enumeration0 = inputMappedClassifier0.listOptions();
      assertNotNull(enumeration0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test14()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      
      inputMappedClassifier0.setSuppressMappingReport(true);
      inputMappedClassifier0.getOptions();
      assertEquals(true, inputMappedClassifier0.getSuppressMappingReport());
  }

  @Test
  public void test15()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath((String) null);
      String[] stringArray0 = inputMappedClassifier0.getOptions();
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertNotNull(stringArray0);
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
  }

  @Test
  public void test16()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath("ij{82 otq >s}11");
      String[] stringArray0 = inputMappedClassifier0.getOptions();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertNotNull(stringArray0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test17()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath((String) null);
      String string0 = inputMappedClassifier0.toString();
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("InputMappedClassifier:\n\nZeroR: No model built yet.", string0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertNotNull(string0);
  }

  @Test
  public void test18()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath("Don't output a report of model-to-input mappings.");
      InputMappedClassifier inputMappedClassifier1 = (InputMappedClassifier)AbstractClassifier.makeCopy((Classifier) inputMappedClassifier0);
      inputMappedClassifier0.setClassifier((Classifier) inputMappedClassifier1);
      String string0 = inputMappedClassifier0.toString();
      assertNotNull(string0);
      assertEquals("InputMappedClassifier:\n\nModel sourced from: Don't output a report of model-to-input mappings.\n\nInputMappedClassifier:\n\nModel sourced from: Don't output a report of model-to-input mappings.\n\nZeroR: No model built yet.", inputMappedClassifier0.toString());
      assertEquals("InputMappedClassifier:\n\nModel sourced from: Don't output a report of model-to-input mappings.\n\nInputMappedClassifier:\n\nModel sourced from: Don't output a report of model-to-input mappings.\n\nZeroR: No model built yet.", string0);
  }

  @Test
  public void test19()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      try {
        inputMappedClassifier0.buildClassifier((Instances) null);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test20()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setModelPath("8034");
      inputMappedClassifier0.setTestStructure((Instances) null);
      inputMappedClassifier0.buildClassifier((Instances) null);
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test21()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances("Abstract class for nearest neighbour search All algorithms (classes) that do nearest neighbour search should extend this class.", arrayList0, 33);
      inputMappedClassifier0.setModelHeader(instances0);
      Instances instances1 = inputMappedClassifier0.getModelHeader(instances0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertNotNull(instances1);
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
  }

  @Test
  public void test22()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      try {
        inputMappedClassifier0.getModelHeader((Instances) null);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test23()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      try {
        inputMappedClassifier0.getMappedClassIndex();
        fail("Expecting exception: Exception");
      } catch(Exception e) {
        /*
         * [InputMappedClassifier] No model available!
         */
      }
  }

  @Test
  public void test24()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      
      SparseInstance sparseInstance0 = new SparseInstance(117);
      inputMappedClassifier0.setSuppressMappingReport(true);
      try {
        inputMappedClassifier0.classifyInstance((Instance) sparseInstance0);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test25()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      String string0 = inputMappedClassifier0.toString();
      assertNotNull(string0);
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertEquals("InputMappedClassifier:\n\nZeroR: No model built yet.", string0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
  }

  @Test
  public void test26()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      
      inputMappedClassifier0.setSuppressMappingReport(true);
      String string0 = inputMappedClassifier0.toString();
      assertEquals(true, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals("InputMappedClassifier:\n\nZeroR: No model built yet.", string0);
  }

  @Test
  public void test27()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      int int0 = inputMappedClassifier0.graphType();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(0, int0);
      assertEquals(true, inputMappedClassifier0.getTrim());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
  }

  @Test
  public void test28()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setClassifier((Classifier) inputMappedClassifier0);
      // Undeclared exception!
      try {
        inputMappedClassifier0.graphType();
        fail("Expecting exception: StackOverflowError");
      } catch(StackOverflowError e) {
      }
  }

  @Test
  public void test29()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      InputMappedClassifier inputMappedClassifier1 = (InputMappedClassifier)AbstractClassifier.makeCopy((Classifier) inputMappedClassifier0);
      inputMappedClassifier0.setClassifier((Classifier) inputMappedClassifier1);
      Enumeration<Object> enumeration0 = inputMappedClassifier0.enumerateMeasures();
      assertEquals(false, inputMappedClassifier0.getSuppressMappingReport());
      assertEquals(true, inputMappedClassifier0.getIgnoreCaseForNames());
      assertNotNull(enumeration0);
      assertEquals(true, inputMappedClassifier0.getTrim());
  }

  @Test
  public void test30()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      // Undeclared exception!
      try {
        inputMappedClassifier0.getMeasure("Ignore case when matching attribute names and nomina values.");
        fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
        /*
         * Ignore case when matching attribute names and nomina values. not supported (InputMappedClassifier)
         */
      }
  }

  @Test
  public void test31()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setClassifier((Classifier) inputMappedClassifier0);
      // Undeclared exception!
      try {
        inputMappedClassifier0.getMeasure("Ignore case when matching attribute names and nomina values.");
        fail("Expecting exception: StackOverflowError");
      } catch(StackOverflowError e) {
      }
  }

  @Test
  public void test32()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setClassifier((Classifier) null);
      try {
        inputMappedClassifier0.graph();
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test33()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      try {
        inputMappedClassifier0.graph();
        fail("Expecting exception: Exception");
      } catch(Exception e) {
        /*
         * Classifier: weka.classifiers.rules.ZeroR  cannot be graphed
         */
      }
  }

  @Test
  public void test34()  throws Throwable  {
      InputMappedClassifier inputMappedClassifier0 = new InputMappedClassifier();
      inputMappedClassifier0.setClassifier((Classifier) inputMappedClassifier0);
      // Undeclared exception!
      try {
        inputMappedClassifier0.graph();
        fail("Expecting exception: StackOverflowError");
      } catch(StackOverflowError e) {
      }
  }
}
