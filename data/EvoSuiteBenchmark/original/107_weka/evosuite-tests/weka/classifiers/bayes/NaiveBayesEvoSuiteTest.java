/*
 * This file was automatically generated by EvoSuite
 */

package weka.classifiers.bayes;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.junit.EvoSuiteRunner;
import static org.junit.Assert.*;
import java.util.Enumeration;
import org.junit.BeforeClass;
import weka.classifiers.bayes.NaiveBayes;
import weka.classifiers.bayes.NaiveBayesUpdateable;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SparseInstance;
import weka.core.UnassignedDatasetException;

@RunWith(EvoSuiteRunner.class)
public class NaiveBayesEvoSuiteTest {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.Properties.REPLACE_CALLS = true; 
  } 


  @Test
  public void test0()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      String string0 = naiveBayesUpdateable0.useKernelEstimatorTipText();
      assertEquals(false, naiveBayesUpdateable0.getUseSupervisedDiscretization());
      assertEquals("Use a kernel estimator for numeric attributes rather than a normal distribution.", string0);
      assertEquals(false, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      assertEquals(false, naiveBayesUpdateable0.getUseKernelEstimator());
  }

  @Test
  public void test1()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      String string0 = naiveBayes0.displayModelInOldFormatTipText();
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
      assertEquals("Use old format for model output. The old format is better when there are many class values. The new format is better when there are fewer classes and many attributes.", string0);
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
  }

  @Test
  public void test2()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      try {
        naiveBayesUpdateable0.buildClassifier((Instances) null);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test3()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      boolean boolean0 = naiveBayesUpdateable0.getUseSupervisedDiscretization();
      assertEquals(false, boolean0);
      assertEquals(false, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      assertEquals(false, naiveBayesUpdateable0.getUseKernelEstimator());
  }

  @Test
  public void test4()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      String string0 = naiveBayes0.globalInfo();
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
      assertEquals("Class for a Naive Bayes classifier using estimator classes. Numeric estimator precision values are chosen based on analysis of the  training data. For this reason, the classifier is not an UpdateableClassifier (which in typical usage are initialized with zero training instances) -- if you need the UpdateableClassifier functionality, use the NaiveBayesUpdateable classifier. The NaiveBayesUpdateable classifier will  use a default precision of 0.1 for numeric attributes when buildClassifier is called with zero training instances.\n\nFor more information on Naive Bayes classifiers, see\n\nGeorge H. John, Pat Langley: Estimating Continuous Distributions in Bayesian Classifiers. In: Eleventh Conference on Uncertainty in Artificial Intelligence, San Mateo, 338-345, 1995.", string0);
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      assertNotNull(string0);
  }

  @Test
  public void test5()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      String string0 = naiveBayes0.getRevision();
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals("8034", string0);
      assertNotNull(string0);
  }

  @Test
  public void test6()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      String string0 = naiveBayes0.useSupervisedDiscretizationTipText();
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals("Use supervised discretization to convert numeric attributes to nominal ones.", string0);
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
  }

  @Test
  public void test7()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      boolean boolean0 = naiveBayes0.getUseKernelEstimator();
      assertEquals(false, boolean0);
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
  }

  @Test
  public void test8()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      Enumeration<Object> enumeration0 = naiveBayes0.listOptions();
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals(false, naiveBayes0.getDisplayModelInOldFormat());
      assertNotNull(enumeration0);
  }

  @Test
  public void test9()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      boolean boolean0 = naiveBayes0.getDisplayModelInOldFormat();
      assertEquals(false, naiveBayes0.getUseKernelEstimator());
      assertEquals(false, boolean0);
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
  }

  @Test
  public void test10()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "Use old format for model output. The old format is better when there are many class values. The new format is better when there are fewer classes and many attributes.";
      stringArray0[1] = "Use old format for model output. The old format is better when there are many class values. The new format is better when there are fewer classes and many attributes.";
      try {
        naiveBayes0.setOptions(stringArray0);
        fail("Expecting exception: Exception");
      } catch(Exception e) {
        /*
         * Illegal options: Use old format for model output. The old format is better when there are many class values. The new format is better when there are fewer classes and many attributes. Use old format for model output. The old format is better when there are many class values. The new format is better when there are fewer classes and many attributes. 
         */
      }
  }

  @Test
  public void test11()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      double[] doubleArray0 = new double[2];
      SparseInstance sparseInstance0 = new SparseInstance(2003.3575196031657, doubleArray0);
      try {
        naiveBayesUpdateable0.classifyInstance((Instance) sparseInstance0);
        fail("Expecting exception: UnassignedDatasetException");
      } catch(UnassignedDatasetException e) {
        /*
         * DenseInstance doesn't have access to a dataset!
         */
      }
  }

  @Test
  public void test12()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      
      naiveBayes0.setUseSupervisedDiscretization(true);
      double[] doubleArray0 = new double[7];
      SparseInstance sparseInstance0 = new SparseInstance((-13.330483058427678), doubleArray0);
      try {
        naiveBayes0.classifyInstance((Instance) sparseInstance0);
        fail("Expecting exception: NullPointerException");
      } catch(NullPointerException e) {
      }
  }

  @Test
  public void test13()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      assertEquals(false, naiveBayesUpdateable0.getUseKernelEstimator());
      
      naiveBayesUpdateable0.setUseKernelEstimator(true);
      String[] stringArray0 = naiveBayesUpdateable0.getOptions();
      naiveBayesUpdateable0.setOptions(stringArray0);
      assertEquals(true, naiveBayesUpdateable0.getUseKernelEstimator());
  }

  @Test
  public void test14()  throws Throwable  {
      NaiveBayes naiveBayes0 = new NaiveBayes();
      assertEquals(false, naiveBayes0.getUseSupervisedDiscretization());
      
      naiveBayes0.setUseSupervisedDiscretization(true);
      naiveBayes0.getOptions();
      assertEquals(true, naiveBayes0.getUseSupervisedDiscretization());
  }

  @Test
  public void test15()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      assertEquals(false, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      
      naiveBayesUpdateable0.setDisplayModelInOldFormat(true);
      naiveBayesUpdateable0.getOptions();
      assertEquals(true, naiveBayesUpdateable0.getDisplayModelInOldFormat());
  }

  @Test
  public void test16()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      String string0 = naiveBayesUpdateable0.toString();
      assertEquals(false, naiveBayesUpdateable0.getUseKernelEstimator());
      assertEquals("Naive Bayes Classifier: No model built yet.", string0);
      assertEquals(false, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      assertEquals(false, naiveBayesUpdateable0.getUseSupervisedDiscretization());
      assertNotNull(string0);
  }

  @Test
  public void test17()  throws Throwable  {
      NaiveBayesUpdateable naiveBayesUpdateable0 = new NaiveBayesUpdateable();
      assertEquals(false, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      
      naiveBayesUpdateable0.setDisplayModelInOldFormat(true);
      String string0 = naiveBayesUpdateable0.toString();
      assertEquals(true, naiveBayesUpdateable0.getDisplayModelInOldFormat());
      assertEquals("Naive Bayes Classifier: No model built yet.", string0);
  }
}
