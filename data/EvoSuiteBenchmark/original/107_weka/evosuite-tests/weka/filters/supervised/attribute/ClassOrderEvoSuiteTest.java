/*
 * This file was automatically generated by EvoSuite
 */

package weka.filters.supervised.attribute;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.junit.EvoSuiteRunner;
import static org.junit.Assert.*;
import java.util.ArrayList;
import java.util.Enumeration;
import org.junit.BeforeClass;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.SparseInstance;
import weka.core.WekaException;
import weka.filters.supervised.attribute.ClassOrder;

@RunWith(EvoSuiteRunner.class)
public class ClassOrderEvoSuiteTest {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.Properties.REPLACE_CALLS = true; 
  } 


  @Test
  public void test0()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances("", arrayList0, 0);
      try {
        classOrder0.setInputFormat(instances0);
        fail("Expecting exception: WekaException");
      } catch(WekaException e) {
        /*
         * weka.filters.supervised.attribute.ClassOrder: No attributes!
         */
      }
  }

  @Test
  public void test1()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      classOrder0.setClassOrder((-1253));
      assertEquals(-1253, classOrder0.getClassOrder());
      assertEquals(1L, classOrder0.getSeed());
  }

  @Test
  public void test2()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String string0 = classOrder0.seedTipText();
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the seed of randomization of the class order", string0);
      assertEquals(1L, classOrder0.getSeed());
  }

  @Test
  public void test3()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      Enumeration<Object> enumeration0 = classOrder0.listOptions();
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(0, classOrder0.getClassOrder());
      assertNotNull(enumeration0);
  }

  @Test
  public void test4()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String string0 = classOrder0.classOrderTipText();
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals("Specify the class order after the filtering", string0);
  }

  @Test
  public void test5()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String string0 = classOrder0.getRevision();
      assertEquals(1L, classOrder0.getSeed());
      assertEquals("8034", string0);
      assertNotNull(string0);
      assertEquals(0, classOrder0.getClassOrder());
  }

  @Test
  public void test6()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      classOrder0.setSeed(2029L);
      assertEquals(2029L, classOrder0.getSeed());
  }

  @Test
  public void test7()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      long long0 = classOrder0.getSeed();
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals(1L, long0);
  }

  @Test
  public void test8()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String string0 = classOrder0.globalInfo();
      assertEquals("Changes the order of the classes so that the class values are no longer of in the order specified in the header. The values will be in the order specified by the user -- it could be either in ascending/descending order by the class frequency or in random order. Note that this filter currently does not change the header, only the class values of the instances, so there is not much point in using it in conjunction with the FilteredClassifier. The value can also be converted back using 'originalValue(double value)' procedure.", string0);
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals(1L, classOrder0.getSeed());
  }

  @Test
  public void test9()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      int int0 = classOrder0.getClassOrder();
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(0, int0);
  }

  @Test
  public void test10()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "r-MGTBqQI";
      stringArray0[1] = "r-MGTBqQI";
      classOrder0.setOptions(stringArray0);
      assertEquals(0, classOrder0.getClassOrder());
      assertEquals(1L, classOrder0.getSeed());
  }

  @Test
  public void test11()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      String[] stringArray0 = classOrder0.getOptions();
      assertNotNull(stringArray0);
      
      classOrder0.setOptions(stringArray0);
      assertEquals(1L, classOrder0.getSeed());
      assertEquals(0, classOrder0.getClassOrder());
  }

  @Test
  public void test12()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      SparseInstance sparseInstance0 = new SparseInstance(680);
      // Undeclared exception!
      try {
        classOrder0.input((Instance) sparseInstance0);
        fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
        /*
         * No input instance format defined
         */
      }
  }

  @Test
  public void test13()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      try {
        classOrder0.batchFinished();
        fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
        /*
         * No input instance format defined
         */
      }
  }

  @Test
  public void test14()  throws Throwable  {
      ClassOrder classOrder0 = new ClassOrder();
      try {
        classOrder0.originalValue((double) 1L);
        fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
        /*
         * Coverter table not defined yet!
         */
      }
  }
}
