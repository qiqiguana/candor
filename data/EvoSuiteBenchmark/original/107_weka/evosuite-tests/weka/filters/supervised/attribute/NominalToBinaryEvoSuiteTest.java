/*
 * This file was automatically generated by EvoSuite
 */

package weka.filters.supervised.attribute;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.junit.EvoSuiteRunner;
import static org.junit.Assert.*;
import java.util.ArrayList;
import org.junit.BeforeClass;
import weka.core.Attribute;
import weka.core.DenseInstance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.WekaException;
import weka.filters.Filter;
import weka.filters.supervised.attribute.NominalToBinary;

@RunWith(EvoSuiteRunner.class)
public class NominalToBinaryEvoSuiteTest {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.Properties.REPLACE_CALLS = true; 
  } 


  @Test
  public void test0()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String[] stringArray0 = new String[2];
      stringArray0[0] = "Converts all nominal attributes into binary numeric attributes. An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach). Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al. (i.e. taking the average class value associated with each attribute value into account)\n\nFor more information, see:\n\nL. Breiman, J.H. Friedman, R.A. Olshen, C.J. Stone (1984). Classification and Regression Trees. Wadsworth Inc.";
      stringArray0[1] = "Converts all nominal attributes into binary numeric attributes. An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach). Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al. (i.e. taking the average class value associated with each attribute value into account)\n\nFor more information, see:\n\nL. Breiman, J.H. Friedman, R.A. Olshen, C.J. Stone (1984). Classification and Regression Trees. Wadsworth Inc.";
      Filter.runFilter((Filter) nominalToBinary0, stringArray0);
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      assertEquals(false, nominalToBinary0.getTransformAllValues());
  }

  @Test
  public void test1()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String string0 = nominalToBinary0.globalInfo();
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Converts all nominal attributes into binary numeric attributes. An attribute with k values is transformed into k binary attributes if the class is nominal (using the one-attribute-per-value approach). Binary attributes are left binary, if option '-A' is not given.If the class is numeric, k - 1 new binary attributes are generated in the manner described in \"Classification and Regression Trees\" by Breiman et al. (i.e. taking the average class value associated with each attribute value into account)\n\nFor more information, see:\n\nL. Breiman, J.H. Friedman, R.A. Olshen, C.J. Stone (1984). Classification and Regression Trees. Wadsworth Inc.", string0);
      assertEquals(false, nominalToBinary0.getTransformAllValues());
      assertNotNull(string0);
  }

  @Test
  public void test2()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      ArrayList<Attribute> arrayList0 = new ArrayList<Attribute>();
      Instances instances0 = new Instances("", arrayList0, 874);
      try {
        nominalToBinary0.setInputFormat(instances0);
        fail("Expecting exception: WekaException");
      } catch(WekaException e) {
        /*
         * weka.filters.supervised.attribute.NominalToBinary: No attributes!
         */
      }
  }

  @Test
  public void test3()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String string0 = nominalToBinary0.getRevision();
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      assertEquals(false, nominalToBinary0.getTransformAllValues());
      assertEquals("8097", string0);
      assertNotNull(string0);
  }

  @Test
  public void test4()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String[] stringArray0 = nominalToBinary0.getOptions();
      assertNotNull(stringArray0);
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      assertEquals(false, nominalToBinary0.getTransformAllValues());
  }

  @Test
  public void test5()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String string0 = nominalToBinary0.binaryAttributesNominalTipText();
      assertEquals(false, nominalToBinary0.getTransformAllValues());
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      assertEquals("Whether resulting binary attributes will be nominal.", string0);
  }

  @Test
  public void test6()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      String string0 = nominalToBinary0.transformAllValuesTipText();
      assertEquals(false, nominalToBinary0.getTransformAllValues());
      assertEquals("Whether all nominal values are turned into new attributes, not only if there are more than 2.", string0);
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
  }

  @Test
  public void test7()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      DenseInstance denseInstance0 = new DenseInstance(19);
      // Undeclared exception!
      try {
        nominalToBinary0.input((Instance) denseInstance0);
        fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
        /*
         * No input instance format defined
         */
      }
  }

  @Test
  public void test8()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      // Undeclared exception!
      try {
        nominalToBinary0.batchFinished();
        fail("Expecting exception: IllegalStateException");
      } catch(IllegalStateException e) {
        /*
         * No input instance format defined
         */
      }
  }

  @Test
  public void test9()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertEquals(false, nominalToBinary0.getBinaryAttributesNominal());
      
      nominalToBinary0.setBinaryAttributesNominal(true);
      nominalToBinary0.getOptions();
      assertEquals(true, nominalToBinary0.getBinaryAttributesNominal());
  }

  @Test
  public void test10()  throws Throwable  {
      NominalToBinary nominalToBinary0 = new NominalToBinary();
      assertEquals(false, nominalToBinary0.getTransformAllValues());
      
      nominalToBinary0.setTransformAllValues(true);
      nominalToBinary0.getOptions();
      assertEquals(true, nominalToBinary0.getTransformAllValues());
  }
}
