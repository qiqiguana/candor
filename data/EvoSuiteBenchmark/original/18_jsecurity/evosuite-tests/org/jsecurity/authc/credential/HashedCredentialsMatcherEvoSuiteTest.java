/*
 * This file was automatically generated by EvoSuite
 */

package org.jsecurity.authc.credential;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.evosuite.junit.EvoSuiteRunner;
import static org.junit.Assert.*;
import org.jsecurity.authc.AuthenticationInfo;
import org.jsecurity.authc.AuthenticationToken;
import org.jsecurity.authc.SimpleAccount;
import org.jsecurity.authc.UsernamePasswordToken;
import org.jsecurity.authc.credential.Md2CredentialsMatcher;
import org.jsecurity.authc.credential.Sha256CredentialsMatcher;
import org.jsecurity.authc.credential.Sha384CredentialsMatcher;
import org.jsecurity.authc.credential.Sha512CredentialsMatcher;
import org.jsecurity.crypto.hash.Md2Hash;
import org.jsecurity.crypto.hash.Sha384Hash;
import org.jsecurity.subject.PrincipalCollection;
import org.jsecurity.subject.SimplePrincipalCollection;
import org.junit.BeforeClass;

@RunWith(EvoSuiteRunner.class)
public class HashedCredentialsMatcherEvoSuiteTest {

  @BeforeClass 
  public static void initEvoSuiteFramework(){ 
    org.evosuite.Properties.REPLACE_CALLS = true; 
  } 


  @Test
  public void test0()  throws Throwable  {
      Sha384CredentialsMatcher sha384CredentialsMatcher0 = new Sha384CredentialsMatcher();
      assertEquals(false, sha384CredentialsMatcher0.isHashSalted());
      
      sha384CredentialsMatcher0.setHashSalted(true);
      UsernamePasswordToken usernamePasswordToken0 = new UsernamePasswordToken("Warni~g: bad loghierarchy. ", "Warni~g: bad loghierarchy. ");
      Sha384Hash sha384Hash0 = (Sha384Hash)sha384CredentialsMatcher0.getCredentials((AuthenticationToken) usernamePasswordToken0);
      assertEquals(true, sha384CredentialsMatcher0.isHashSalted());
      assertEquals("d05af6a1e19b9b86bf501bcde10c01afd854da40a56a4d1ad4bcca719789627c4d3ff9717d222bebc42a8d6f1da7d2e4", sha384Hash0.toHex());
  }

  @Test
  public void test1()  throws Throwable  {
      Sha512CredentialsMatcher sha512CredentialsMatcher0 = new Sha512CredentialsMatcher();
      assertEquals(true, sha512CredentialsMatcher0.isStoredCredentialsHexEncoded());
      
      sha512CredentialsMatcher0.setStoredCredentialsHexEncoded(false);
      SimpleAccount simpleAccount0 = new SimpleAccount((Object) "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000", (Object) "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000", "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000");
      sha512CredentialsMatcher0.getCredentials((AuthenticationInfo) simpleAccount0);
      assertEquals(false, sha512CredentialsMatcher0.isStoredCredentialsHexEncoded());
  }

  @Test
  public void test2()  throws Throwable  {
      Sha512CredentialsMatcher sha512CredentialsMatcher0 = new Sha512CredentialsMatcher();
      SimpleAccount simpleAccount0 = new SimpleAccount((Object) "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000", (Object) "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000", "\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000");
      // Undeclared exception!
      try {
        sha512CredentialsMatcher0.getCredentials((AuthenticationInfo) simpleAccount0);
        fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
        /*
         * Illegal hexadecimal charcter \u0000 at index 0
         */
      }
  }

  @Test
  public void test3()  throws Throwable  {
      Sha512CredentialsMatcher sha512CredentialsMatcher0 = new Sha512CredentialsMatcher();
      sha512CredentialsMatcher0.setHashIterations(97);
      assertEquals(97, sha512CredentialsMatcher0.getHashIterations());
      assertEquals(true, sha512CredentialsMatcher0.isStoredCredentialsHexEncoded());
  }

  @Test
  public void test4()  throws Throwable  {
      Sha384CredentialsMatcher sha384CredentialsMatcher0 = new Sha384CredentialsMatcher();
      sha384CredentialsMatcher0.setHashIterations((-4));
      assertEquals(false, sha384CredentialsMatcher0.isHashSalted());
      assertEquals(true, sha384CredentialsMatcher0.isStoredCredentialsHexEncoded());
      assertEquals(1, sha384CredentialsMatcher0.getHashIterations());
  }

  @Test
  public void test5()  throws Throwable  {
      Md2CredentialsMatcher md2CredentialsMatcher0 = new Md2CredentialsMatcher();
      UsernamePasswordToken usernamePasswordToken0 = new UsernamePasswordToken("czXnH,vG,", "czXnH,vG,");
      Md2Hash md2Hash0 = (Md2Hash)md2CredentialsMatcher0.getCredentials((AuthenticationToken) usernamePasswordToken0);
      assertEquals(1, md2CredentialsMatcher0.getHashIterations());
      assertNotNull(md2Hash0);
      assertEquals(true, md2CredentialsMatcher0.isStoredCredentialsHexEncoded());
      assertEquals("6015c6911247520151127d42742031ef", md2Hash0.toString());
  }

  @Test
  public void test6()  throws Throwable  {
      UsernamePasswordToken usernamePasswordToken0 = new UsernamePasswordToken("9O?j5vq,]}", "9O?j5vq,]}", true);
      Object object0 = usernamePasswordToken0.getCredentials();
      Sha256CredentialsMatcher sha256CredentialsMatcher0 = new Sha256CredentialsMatcher();
      SimplePrincipalCollection simplePrincipalCollection0 = new SimplePrincipalCollection(object0, "9O?j5vq,]}");
      SimpleAccount simpleAccount0 = new SimpleAccount((PrincipalCollection) simplePrincipalCollection0, object0);
      // Undeclared exception!
      try {
        sha256CredentialsMatcher0.getCredentials((AuthenticationInfo) simpleAccount0);
        fail("Expecting exception: IllegalArgumentException");
      } catch(IllegalArgumentException e) {
        /*
         * Illegal hexadecimal charcter O at index 1
         */
      }
  }
}
