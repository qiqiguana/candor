<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>id_2503.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">leetcode</a> &gt; <a href="index.source.html" class="el_package">original</a> &gt; <span class="el_source">id_2503.java</span></div><h1>id_2503.java</h1><pre class="source lang-java linenums">package original;

import java.util.PriorityQueue;
import java.util.Arrays;
import java.util.Queue;
<span class="fc" id="L6">class Solution2503 {</span>
    public int[] maxPoints(int[][] grid, int[] queries) {
  /**
  You are given an m x n integer matrix grid and an array queries of size k. Find an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process: If queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right. Otherwise, you do not get any points, and you end this process. After the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times. Return the resulting array answer. &amp;nbsp; Example 1: Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2] Output: [5,8,1] Explanation: The diagrams above show which cells we visit to get points for each query. Example 2: Input: grid = [[5,2,1],[1,1,2]], queries = [3] Output: [0] Explanation: We can not get any points because the value of the top left cell is already greater than or equal to 3. &amp;nbsp; Constraints: m == grid.length n == grid[i].length 2 &amp;lt;= m, n &amp;lt;= 1000 4 &amp;lt;= m * n &amp;lt;= 105 k == queries.length 1 &amp;lt;= k &amp;lt;= 104 1 &amp;lt;= grid[i][j], queries[i] &amp;lt;= 106
  */
<span class="fc" id="L11">        int k = queries.length;</span>
<span class="fc" id="L12">        int[][] qs = new int[k][2];</span>
<span class="fc bfc" id="L13" title="All 2 branches covered.">        for (int i = 0; i &lt; k; ++i) {</span>
<span class="fc" id="L14">            qs[i] = new int[] {queries[i], i};</span>
        }
<span class="pc" id="L16">        Arrays.sort(qs, (a, b) -&gt; a[0] - b[0]);</span>
<span class="fc" id="L17">        int[] ans = new int[k];</span>
<span class="fc" id="L18">        int m = grid.length, n = grid[0].length;</span>
<span class="fc" id="L19">        boolean[][] vis = new boolean[m][n];</span>
<span class="fc" id="L20">        vis[0][0] = true;</span>
<span class="fc" id="L21">        PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; a[0] - b[0]);</span>
<span class="fc" id="L22">        q.offer(new int[] {grid[0][0], 0, 0});</span>
<span class="fc" id="L23">        int[] dirs = new int[] {-1, 0, 1, 0, -1};</span>
<span class="fc" id="L24">        int cnt = 0;</span>
<span class="fc bfc" id="L25" title="All 2 branches covered.">        for (var e : qs) {</span>
<span class="fc" id="L26">            int v = e[0];</span>
<span class="fc" id="L27">            k = e[1];</span>
<span class="pc bpc" id="L28" title="1 of 4 branches missed.">            while (!q.isEmpty() &amp;&amp; q.peek()[0] &lt; v) {</span>
<span class="fc" id="L29">                var p = q.poll();</span>
<span class="fc" id="L30">                ++cnt;</span>
<span class="fc bfc" id="L31" title="All 2 branches covered.">                for (int h = 0; h &lt; 4; ++h) {</span>
<span class="fc" id="L32">                    int x = p[1] + dirs[h], y = p[2] + dirs[h + 1];</span>
<span class="fc bfc" id="L33" title="All 10 branches covered.">                    if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; !vis[x][y]) {</span>
<span class="fc" id="L34">                        vis[x][y] = true;</span>
<span class="fc" id="L35">                        q.offer(new int[] {grid[x][y], x, y});</span>
                    }
                }
<span class="fc" id="L38">            }</span>
<span class="fc" id="L39">            ans[k] = cnt;</span>
        }
<span class="fc" id="L41">        return ans;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>