<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>id_1307.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">leetcode</a> &gt; <a href="index.source.html" class="el_package">original</a> &gt; <span class="el_source">id_1307.java</span></div><h1>id_1307.java</h1><pre class="source lang-java linenums">package original;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
<span class="nc" id="L7">class Solution1307 {</span>
    private boolean isAnyMapping(List&lt;String&gt; words, int row, int col, int bal,
  /**
  Given an equation, represented by words on the left side and the result on the right side. You need to check if the equation is solvable under the following rules: Each character is decoded as one digit (0 - 9). No two characters can map to the same digit. Each words[i] and result are decoded as one number without leading zeros. Sum of numbers on the left side (words) will equal to the number on the right side (result). Return true if the equation is solvable, otherwise return false. &amp;nbsp; Example 1: Input: words = [&amp;quot;SEND&amp;quot;,&amp;quot;MORE&amp;quot;], result = &amp;quot;MONEY&amp;quot; Output: true Explanation: Map &amp;#39;S&amp;#39;-&amp;gt; 9, &amp;#39;E&amp;#39;-&amp;gt;5, &amp;#39;N&amp;#39;-&amp;gt;6, &amp;#39;D&amp;#39;-&amp;gt;7, &amp;#39;M&amp;#39;-&amp;gt;1, &amp;#39;O&amp;#39;-&amp;gt;0, &amp;#39;R&amp;#39;-&amp;gt;8, &amp;#39;Y&amp;#39;-&amp;gt;&amp;#39;2&amp;#39; Such that: &amp;quot;SEND&amp;quot; + &amp;quot;MORE&amp;quot; = &amp;quot;MONEY&amp;quot; , 9567 + 1085 = 10652 Example 2: Input: words = [&amp;quot;SIX&amp;quot;,&amp;quot;SEVEN&amp;quot;,&amp;quot;SEVEN&amp;quot;], result = &amp;quot;TWENTY&amp;quot; Output: true Explanation: Map &amp;#39;S&amp;#39;-&amp;gt; 6, &amp;#39;I&amp;#39;-&amp;gt;5, &amp;#39;X&amp;#39;-&amp;gt;0, &amp;#39;E&amp;#39;-&amp;gt;8, &amp;#39;V&amp;#39;-&amp;gt;7, &amp;#39;N&amp;#39;-&amp;gt;2, &amp;#39;T&amp;#39;-&amp;gt;1, &amp;#39;W&amp;#39;-&amp;gt;&amp;#39;3&amp;#39;, &amp;#39;Y&amp;#39;-&amp;gt;4 Such that: &amp;quot;SIX&amp;quot; + &amp;quot;SEVEN&amp;quot; + &amp;quot;SEVEN&amp;quot; = &amp;quot;TWENTY&amp;quot; , 650 + 68782 + 68782 = 138214 Example 3: Input: words = [&amp;quot;LEET&amp;quot;,&amp;quot;CODE&amp;quot;], result = &amp;quot;POINT&amp;quot; Output: false Explanation: There is no possible mapping to satisfy the equation, so we return false. Note that two different characters cannot map to the same digit. &amp;nbsp; Constraints: 2 &amp;lt;= words.length &amp;lt;= 5 1 &amp;lt;= words[i].length, result.length &amp;lt;= 7 words[i], result contain only uppercase English letters. The number of different characters used in the expression is at most 10.
  */
        HashMap&lt;Character, Integer&gt; letToDig, char[] digToLet, int totalRows, int totalCols) {
        // If traversed all columns.
<span class="nc bnc" id="L14" title="All 2 branches missed.">        if (col == totalCols) {</span>
<span class="nc bnc" id="L15" title="All 2 branches missed.">            return bal == 0;</span>
        }

        // At the end of a particular column.
<span class="nc bnc" id="L19" title="All 2 branches missed.">        if (row == totalRows) {</span>
<span class="nc bnc" id="L20" title="All 2 branches missed.">            return (bal % 10 == 0</span>
<span class="nc bnc" id="L21" title="All 2 branches missed.">                &amp;&amp; isAnyMapping(</span>
                    words, 0, col + 1, bal / 10, letToDig, digToLet, totalRows, totalCols));
        }

<span class="nc" id="L25">        String w = words.get(row);</span>

        // If the current string 'w' has no character in the ('col')th index.
<span class="nc bnc" id="L28" title="All 2 branches missed.">        if (col &gt;= w.length()) {</span>
<span class="nc" id="L29">            return isAnyMapping(words, row + 1, col, bal, letToDig, digToLet, totalRows, totalCols);</span>
        }

        // Take the current character in the variable letter.
<span class="nc" id="L33">        char letter = w.charAt(w.length() - 1 - col);</span>

        // Create a variable 'sign' to check whether we have to add it or subtract it.
<span class="nc bnc" id="L36" title="All 2 branches missed.">        int sign = (row &lt; totalRows - 1) ? 1 : -1;</span>

        // If we have a prior valid mapping, then use that mapping.
        // The second condition is for the leading zeros.
<span class="nc bnc" id="L40" title="All 2 branches missed.">        if (letToDig.containsKey(letter)</span>
<span class="nc bnc" id="L41" title="All 6 branches missed.">            &amp;&amp; (letToDig.get(letter) != 0 || (letToDig.get(letter) == 0 &amp;&amp; w.length() == 1)</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">                || col != w.length() - 1)) {</span>

<span class="nc" id="L44">            return isAnyMapping(words, row + 1, col, bal + sign * letToDig.get(letter), letToDig,</span>
                digToLet, totalRows, totalCols);

        } else {
            // Choose a new mapping.
<span class="nc bnc" id="L49" title="All 2 branches missed.">            for (int i = 0; i &lt; 10; i++) {</span>
                // If 'i'th mapping is valid then select it.
<span class="nc bnc" id="L51" title="All 6 branches missed.">                if (digToLet[i] == '-'</span>
<span class="nc bnc" id="L52" title="All 4 branches missed.">                    &amp;&amp; (i != 0 || (i == 0 &amp;&amp; w.length() == 1) || col != w.length() - 1)) {</span>
<span class="nc" id="L53">                    digToLet[i] = letter;</span>
<span class="nc" id="L54">                    letToDig.put(letter, i);</span>

                    // Call the function again with the new mapping.
<span class="nc bnc" id="L57" title="All 2 branches missed.">                    if (isAnyMapping(words, row + 1, col, bal + sign * letToDig.get(letter),</span>
                            letToDig, digToLet, totalRows, totalCols)) {
<span class="nc" id="L59">                        return true;</span>
                    }

                    // Unselect the mapping.
<span class="nc" id="L63">                    digToLet[i] = '-';</span>
<span class="nc" id="L64">                    letToDig.remove(letter);</span>
                }
            }
        }

        // If nothing is correct then just return false.
<span class="nc" id="L70">        return false;</span>
    }

    public boolean isSolvable(String[] wordsArr, String result) {
        // Add the string 'result' in the list 'words'.
<span class="nc" id="L75">        List&lt;String&gt; words = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        for (String word : wordsArr) {</span>
<span class="nc" id="L77">            words.add(word);</span>
        }
<span class="nc" id="L79">        words.add(result);</span>

<span class="nc" id="L81">        int totalRows = words.size();</span>

        // Find the longest string in the list and set 'totalCols' with the size of that string.
<span class="nc" id="L84">        int totalCols = 0;</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        for (String word : words) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">            if (totalCols &lt; word.length()) {</span>
<span class="nc" id="L87">                totalCols = word.length();</span>
            }
<span class="nc" id="L89">        }</span>

        // Create a HashMap for the letter to digit mapping.
<span class="nc" id="L92">        HashMap&lt;Character, Integer&gt; letToDig = new HashMap&lt;&gt;();</span>

        // Create a char array for the digit to letter mapping.
<span class="nc" id="L95">        char[] digToLet = new char[10];</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L97">            digToLet[i] = '-';</span>
        }

<span class="nc" id="L100">        return isAnyMapping(words, 0, 0, 0, letToDig, digToLet, totalRows, totalCols);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>